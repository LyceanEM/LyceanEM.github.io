<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="content"></div>
<script type="text/javascript">
!function(){var e={334:function(){const e=document.querySelector("head");e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement("link");n.setAttribute("rel","icon"),n.setAttribute("href",`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute("sizes",`${t}x${t}`),n.setAttribute("type","image/png"),e.appendChild(n)}))},819:function(e,t,n){"use strict";n.r(t),n.d(t,{initLocalFileLoader:function(){return cI},load:function(){return lI}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return y},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return V},fromRotation:function(){return O},fromRotationTranslation:function(){return D},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return F},fromScaling:function(){return P},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return E},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return T},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return De},multiplyScalarAndAdd:function(){return Ve},normalFromMat4:function(){return we},projection:function(){return Pe},rotate:function(){return Te},scale:function(){return be},set:function(){return de},str:function(){return Oe},sub:function(){return _e},subtract:function(){return Ee},translate:function(){return ye},transpose:function(){return fe}}),n(334);var a=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(o*O-r*R-a*P)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*T)*M,e[7]=(u*S-p*b+f*T)*M,e[8]=(i*O-s*w+c*A)*M,e[9]=(r*w-n*O-a*A)*M,e[10]=(g*C-m*b+v*y)*M,e[11]=(d*b-u*C-f*y)*M,e[12]=(s*I-i*P-l*A)*M,e[13]=(n*P-r*I+o*A)*M,e[14]=(m*T-g*x-h*y)*M,e[15]=(u*x-d*T+p*y)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function T(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],y=t[15],T=n[0],b=n[1],x=n[2],C=n[3];return e[0]=T*r+b*s+x*d+C*m,e[1]=T*o+b*l+x*p+C*h,e[2]=T*a+b*c+x*f+C*v,e[3]=T*i+b*u+x*g+C*y,T=n[4],b=n[5],x=n[6],C=n[7],e[4]=T*r+b*s+x*d+C*m,e[5]=T*o+b*l+x*p+C*h,e[6]=T*a+b*c+x*f+C*v,e[7]=T*i+b*u+x*g+C*y,T=n[8],b=n[9],x=n[10],C=n[11],e[8]=T*r+b*s+x*d+C*m,e[9]=T*o+b*l+x*p+C*h,e[10]=T*a+b*c+x*f+C*v,e[11]=T*i+b*u+x*g+C*y,T=n[12],b=n[13],x=n[14],C=n[15],e[12]=T*r+b*s+x*d+C*m,e[13]=T*o+b*l+x*p+C*h,e[14]=T*a+b*c+x*f+C*v,e[15]=T*i+b*u+x*g+C*y,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,y,T,b,x,C,S,A,I,w,P,O,R=r[0],M=r[1],E=r[2],D=Math.hypot(R,M,E);return D<a?null:(R*=D=1/D,M*=D,E*=D,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],y=t[10],T=t[11],b=R*R*s+i,x=M*R*s+E*o,C=E*R*s-M*o,S=R*M*s-E*o,A=M*M*s+i,I=E*M*s+R*o,w=R*E*s+M*o,P=M*E*s-R*o,O=E*E*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+y*C,e[3]=d*b+m*x+T*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+y*I,e[7]=d*S+m*A+T*I,e[8]=l*w+p*P+h*O,e[9]=c*w+f*P+v*O,e[10]=u*w+g*P+y*O,e[11]=d*w+m*P+T*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function O(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,y=i*c;return e[0]=1-(f+m),e[1]=d+y,e[2]=p-v,e[3]=0,e[4]=d-y,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function V(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),D(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,y=s*c,T=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+T)*b,e[2]=(f-y)*b,e[3]=0,e[4]=(p-T)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+y)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function F(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,y=l*c,T=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],P=(1-(m+v))*x,O=(f+b)*x,R=(g-T)*x,M=(f-b)*C,E=(1-(p+v))*C,D=(h+y)*C,V=(g+T)*S,L=(h-y)*S,B=(1-(p+m))*S;return e[0]=P,e[1]=O,e[2]=R,e[3]=0,e[4]=M,e[5]=E,e[6]=D,e[7]=0,e[8]=V,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(P*A+M*I+V*w),e[13]=n[1]+I-(O*A+E*I+L*w),e[14]=n[2]+w-(R*A+D*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],y=t[2],T=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(y-A)<a?g(e):(d=h-C,p=v-S,f=y-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-T*f,s=T*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*y),e[13]=-(l*h+c*v+u*y),e[14]=-(d*h+p*v+f*y),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],y=e[15],T=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],P=t[8],O=t[9],R=t[10],M=t[11],E=t[12],D=t[13],V=t[14],L=t[15];return Math.abs(n-T)<=a*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-P)<=a*Math.max(1,Math.abs(d),Math.abs(P))&&Math.abs(p-O)<=a*Math.max(1,Math.abs(p),Math.abs(O))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-E)<=a*Math.max(1,Math.abs(m),Math.abs(E))&&Math.abs(h-D)<=a*Math.max(1,Math.abs(h),Math.abs(D))&&Math.abs(v-V)<=a*Math.max(1,Math.abs(v),Math.abs(V))&&Math.abs(y-L)<=a*Math.max(1,Math.abs(y),Math.abs(L))}var oe=T,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],y=n[6],T=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=y*r+T*i+b*c,e[7]=y*o+T*s+b*u,e[8]=y*a+T*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*O-s*w+c*A)*M,e[3]=(o*O-r*R-a*P)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*O-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*T)*M,e[8]=(g*C-m*b+v*y)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Oe(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function Ee(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function De(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Ve(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],y=t[6],T=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-y)<=a*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(u-T)<=a*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,_e=Ee,Fe=n(152),ke=n.n(Fe),Ge=n(177);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error("Invalid VTK object"),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&"object"==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=Symbol("void"),$e={};function qe(){}["log","debug","info","warn","error","time","timeEnd","group","groupEnd"].forEach((e=>{$e[e]=qe})),Ue.console=console.hasOwnProperty("log")?console:$e;const Xe={debug:qe,error:Ue.console.error||qe,info:Ue.console.info||qe,log:Ue.console.log||qe,warn:Ue.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st("_"===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=["TB","GB","MB","KB"];let o=Number(e),a="B";for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:" ";const n=[];let r=e;for(;r>1e3;)n.push(("000"+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return Object.values(ot).some((t=>e instanceof t))}function gt(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function mt(e){return e&&e.isA?e.getState():e}function ht(e){setTimeout(e,0)}function vt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function yt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),"classHierarchy"in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He("vtkObject");function r(e){n[e]=null}function o(e){return Object.freeze({unsubscribe:function(){r(e)}})}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et("instance deleted - cannot call any method"):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et("instance deleted - cannot call any method"),null;const r=n.length;return n.push(e),o(r)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==["mtime"].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||"_"===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(mt):ft(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort(),i=Object.keys(o).sort();i.forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(", ")}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object:(e,t,n)=>function(){return{...t[n.name]}}};function bt(e,t,n){n.forEach((n=>{if("object"==typeof n){const r=Tt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const xt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if("string"==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError("Set Enum with invalid string argument")}if("number"==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError("Set Enum outside numeric range")}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(e,t,n){1===n.params?.length&&tt('Setter of type "object" with a single "param" field is not supported');const r=`_on${lt(n.name)}Changed`;return function(){for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];let s;if(s=a.length>1&&n.params?.length?n.params.reduce(((e,t,n)=>Object.assign(e,{[t]:a[n]})),{}):a[0],!ke()(t[n.name],s)){const o=t[n.name];return t[n.name]=s,t[r]?.(e,t,s,o),e.modified(),!0}return!1}}};function Ct(e){if("object"==typeof e){const t=xt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError("No setter for field")}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et("instance deleted - cannot call any method"),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function St(e,t,n){n.forEach((n=>{"object"==typeof n?e[`set${lt(n.name)}`]=Ct(n)(e,t):e[`set${lt(n)}`]=Ct(n)(e,t)}))}function At(e,t,n){bt(e,t,n),St(e,t,n)}function It(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et("instance deleted - cannot call any method"),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function Pt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;It(e,t,n),wt(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Rt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et("instance deleted - cannot call any method"):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et("instance deleted - cannot call any method");else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=" input ports. To add more input ports, use addInputConnection()",void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et("instance deleted - cannot call any method"),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et("instance deleted - cannot call any method"):o(e,i())},e.addInputConnection=function(e){t.deleted?et("instance deleted - cannot call any method"):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.shouldUpdate()&&e.requestData&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"Scalars";for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Mt=Symbol("Event abort");function Et(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}function s(e){return Object.freeze({unsubscribe:function(){i(e)}})}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et("instance deleted - cannot call any method");const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Mt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et("instance deleted - cannot call any method"),null;const i=a++;return r.push([i,e,o]),r.sort(((e,t)=>t[2]-e[2])),s(i)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Dt(e,t){const n=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={},r={};return e(r,n,t),Object.freeze(r)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Lt(e){return e&&e.isA&&e.isA("vtkObject")}function Bt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Lt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Bt(e,t,n,r)})):Bt(o,t,n,r)}))}return n}function Nt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=()=>{o=null,n||e.apply(l,i)},u=n&&!o;clearTimeout(o),o=setTimeout(c,t),u&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function _t(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let kt=1;const Gt="__root__";function Ut(e,t){Ft(e,t);const n=e.delete;t.proxyId=""+kt++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),bt(e,t,["proxyId","proxyGroup","proxyName"]),At(e,t,["proxyManager"]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;return o[e]}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],o=t.proxyId,a=i(n)||[];for(let t=0;t<a.length;t++){const n=a[t],i=e[`get${lt(n)}`],l={id:o,name:n,value:i?i():void 0},c=s(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!gt(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}function c(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}}function u(){for(;o.length;)o.pop().subscription.unsubscribe()}const d={bind:c,unbind:l,unsubscribe:u,persistent:n};return t.propertyLinkMap[e]=d,d},e.listPropertyNames=()=>s().map((e=>e.name)),e.getPropertyByName=e=>s().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:s()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,ht((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if("application"===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,"application"),n.bind(e,o,i)}}}))}function zt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Wt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&bt(e,t,a)}function Ht(e){let t=0,n=0,r=0,o=0;return"detail"in e&&(n=e.detail),"wheelDelta"in e&&(n=-e.wheelDelta/120),"wheelDeltaY"in e&&(n=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var jt={algo:Rt,capitalize:st,chain:Vt,debounce:Nt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Et,EVENT_ABORT:Mt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:bt,getArray:It,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:mt,isVtkObject:Lt,keystore:Ft,measurePromiseExecution:vt,moveToProtected:Ot,newInstance:Dt,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:Ht,obj:yt,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,safeArrays:pt,set:St,setArray:wt,setGet:At,setGetArray:Pt,setImmediate:ht,setLoggerFunction:Ye,throttle:_t,traverseInstanceTree:Bt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt,objectSetterMap:xt},Kt=Object.freeze({__proto__:null,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:ht,measurePromiseExecution:vt,obj:yt,get:bt,set:St,setGet:At,getArray:It,setArray:wt,setGetArray:Pt,moveToProtected:Ot,algo:Rt,EVENT_ABORT:Mt,event:Et,newInstance:Dt,chain:Vt,isVtkObject:Lt,traverseInstanceTree:Bt,debounce:Nt,throttle:_t,keystore:Ft,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,normalizeWheel:Ht,default:jt});const{vtkErrorMacro:$t}=jt;function qt(e,t){t.classHierarchy.push("vtkViewNode"),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.getLastAncestorOfType=e=>{if(!t._parent)return null;return t._parent.getLastAncestorOfType(e)||(t._parent.isA(e)?t._parent:null)},e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)return r.setVisited(!0),r;const o=e.createViewNode(n);return o?(o.setParent(e),o.setVisited(!0),t._renderableChildMap.set(n,o),t.children.push(o),o):void 0},e.addMissingNodes=t=>{if(t&&t.length)for(let n=0;n<t.length;++n){const r=t[n];e.addMissingNode(r)}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];if(-1===t.children.indexOf(o)){o.setParent(e),t.children.push(o);const n=o.getRenderable();n&&t._renderableChildMap.set(n,o)}o.setVisited(!0)}},e.removeNode=e=>{const n=t.children.findIndex((t=>t===e));if(n<0)return!1;const r=e.getRenderable();return r&&t._renderableChildMap.delete(r),e.delete(),t.children.splice(n,1),!0},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return $t("Cannot create view nodes without my own factory"),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}const Xt={renderable:null,myFactory:null,children:[],visited:!1};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),jt.obj(e,t),jt.event(e,t,"event"),t._renderableChildMap=new Map,jt.get(e,t,["visited"]),jt.setGet(e,t,["_parent","renderable","myFactory"]),jt.getArray(e,t,["children"]),jt.moveToProtected(e,t,["parent"]),qt(e,t)}var Zt={newInstance:jt.newInstance(Yt,"vtkViewNode"),extend:Yt,PASS_TYPES:["Build","Render"]};function Qt(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push("vtkViewNodeFactory"),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s}}const Jt={};function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jt,n),jt.obj(e,t),Qt(e,t)}var tn={newInstance:jt.newInstance(en,"vtkViewNodeFactory"),extend:en};const nn=Object.create(null);function rn(e,t){nn[e]=t}function on(e,t){t.classHierarchy.push("vtkOpenGLViewNodeFactory")}const an={};function sn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,an,n),t.overrides=nn,tn.extend(e,t,n),on(0,t)}var ln={newInstance:jt.newInstance(sn,"vtkOpenGLViewNodeFactory"),extend:sn};function cn(e,t){t.classHierarchy.push("vtkOpenGLCamera"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),T(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}const un={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const dn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},At(e,t,["context","keyMatrixTime"]),cn(e,t)}));rn("vtkCamera",dn);const{vtkDebugMacro:pn}=Kt;function fn(e,t){t.classHierarchy.push("vtkOpenGLRenderer"),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps()),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(pn("No lights are on, creating one."),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();r.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,r.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const gn={context:null,_openGLRenderWindow:null,selector:null};const mn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gn,n),Zt.extend(e,t,n),bt(e,t,["shaderCache"]),At(e,t,["selector"]),Ot(0,t,["openGLRenderWindow"]),fn(e,t)}),"vtkOpenGLRenderer");function hn(e,t){t.classHierarchy.push("vtkOpenGLActor"),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(t._openGLRenderer.getSelector()&&t.renderable.getNestedPickable()),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkRenderer",mn);const vn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const yn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vn,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),hn(e,t)}));function Tn(e,t){t.classHierarchy.push("vtkOpenGLActor2D"),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}rn("vtkActor",yn);const bn={context:null,activeTextures:null};const xn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bn,n),Zt.extend(e,t,n),At(e,t,["context"]),bt(e,t,["activeTextures"]),Tn(e,t)}));function Cn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Sn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function An(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function In(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function wn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Pn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function On(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Rn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Mn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function En(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Dn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function Vn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function Ln(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Bn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Nn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}rn("vtkActor2D",xn);var _n=Pn,Fn=(Cn(),Math.sqrt(50)),kn=Math.sqrt(10),Gn=Math.sqrt(2);function Un(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Fn?10:a>=kn?5:a>=Gn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Fn?10:a>=kn?5:a>=Gn?2:1)}function zn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Wn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=zn,r=(t,n)=>zn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Hn=Wn(zn),jn=Hn.right;Hn.left,Wn((function(e){return null===e?NaN:+e})).center;var Kn=jn;function $n(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function qn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Xn(){}var Yn=.7,Zn=1/Yn,Qn="\\s*([+-]?\\d+)\\s*",Jn="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",er="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",tr=/^#([0-9a-f]{3,8})$/,nr=new RegExp(`^rgb\\(${Qn},${Qn},${Qn}\\)$`),rr=new RegExp(`^rgb\\(${er},${er},${er}\\)$`),or=new RegExp(`^rgba\\(${Qn},${Qn},${Qn},${Jn}\\)$`),ar=new RegExp(`^rgba\\(${er},${er},${er},${Jn}\\)$`),ir=new RegExp(`^hsl\\(${Jn},${er},${er}\\)$`),sr=new RegExp(`^hsla\\(${Jn},${er},${er},${Jn}\\)$`),lr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function cr(){return this.rgb().formatHex()}function ur(){return this.rgb().formatRgb()}function dr(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=tr.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?pr(t):3===n?new hr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?fr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?fr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=nr.exec(e))?new hr(t[1],t[2],t[3],1):(t=rr.exec(e))?new hr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=or.exec(e))?fr(t[1],t[2],t[3],t[4]):(t=ar.exec(e))?fr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=ir.exec(e))?Cr(t[1],t[2]/100,t[3]/100,1):(t=sr.exec(e))?Cr(t[1],t[2]/100,t[3]/100,t[4]):lr.hasOwnProperty(e)?pr(lr[e]):"transparent"===e?new hr(NaN,NaN,NaN,0):null}function pr(e){return new hr(e>>16&255,e>>8&255,255&e,1)}function fr(e,t,n,r){return r<=0&&(e=t=n=NaN),new hr(e,t,n,r)}function gr(e){return e instanceof Xn||(e=dr(e)),e?new hr((e=e.rgb()).r,e.g,e.b,e.opacity):new hr}function mr(e,t,n,r){return 1===arguments.length?gr(e):new hr(e,t,n,null==r?1:r)}function hr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function vr(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}`}function yr(){const e=Tr(this.opacity);return`${1===e?"rgb(":"rgba("}${br(this.r)}, ${br(this.g)}, ${br(this.b)}${1===e?")":`, ${e})`}`}function Tr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function br(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function xr(e){return((e=br(e))<16?"0":"")+e.toString(16)}function Cr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new Ar(e,t,n,r)}function Sr(e){if(e instanceof Ar)return new Ar(e.h,e.s,e.l,e.opacity);if(e instanceof Xn||(e=dr(e)),!e)return new Ar;if(e instanceof Ar)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new Ar(i,s,l,e.opacity)}function Ar(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Ir(e){return(e=(e||0)%360)<0?e+360:e}function wr(e){return Math.max(0,Math.min(1,e||0))}function Pr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function Or(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}$n(Xn,dr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:cr,formatHex:cr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return Sr(this).formatHsl()},formatRgb:ur,toString:ur}),$n(hr,mr,qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new hr(br(this.r),br(this.g),br(this.b),Tr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vr,formatHex:vr,formatHex8:function(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}${xr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:yr,toString:yr})),$n(Ar,(function(e,t,n,r){return 1===arguments.length?Sr(e):new Ar(e,t,n,null==r?1:r)}),qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new hr(Pr(e>=240?e-240:e+120,o,r),Pr(e,o,r),Pr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new Ar(Ir(this.h),wr(this.s),wr(this.l),Tr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Tr(this.opacity);return`${1===e?"hsl(":"hsla("}${Ir(this.h)}, ${100*wr(this.s)}%, ${100*wr(this.l)}%${1===e?")":`, ${e})`}`}}));var Rr=e=>()=>e;function Mr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Rr(isNaN(e)?t:e)}var Er=function e(t){var n=function(e){return 1==(e=+e)?Mr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Rr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=mr(e)).r,(t=mr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Mr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function Dr(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=mr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+""}}}function Vr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Ur(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Lr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Br(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Nr(e,t){var n,r={},o={};for(n in null!==e&&"object"==typeof e||(e={}),null!==t&&"object"==typeof t||(t={}),t)n in e?r[n]=Ur(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Dr((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return Or((n-r/t)*t,i,o,a,s)}})),Dr((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return Or((n-r/t)*t,o,a,i,s)}}));var _r=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Fr=new RegExp(_r.source,"g");function kr(e,t){var n,r,o,a=_r.lastIndex=Fr.lastIndex=0,i=-1,s=[],l=[];for(e+="",t+="";(n=_r.exec(e))&&(r=Fr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Br(n,r)})),a=Fr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join("")})}function Gr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Ur(e,t){var n,r=typeof t;return null==t||"boolean"===r?Rr(t):("number"===r?Br:"string"===r?(n=dr(t))?(t=n,Er):kr:t instanceof dr?Er:t instanceof Date?Lr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Gr:Array.isArray(t)?Vr:"function"!=typeof t.valueOf&&"function"!=typeof t.toString||isNaN(t)?Nr:Br)(e,t)}function zr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Wr(e){return+e}var Hr=[0,1];function jr(e){return e}function Kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function $r(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Kr(o,r),a=n(i,a)):(r=Kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function qr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Kn(e,t,1,r)-1;return a[n](o[n](t))}}function Xr(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function Yr(){return function(){var e,t,n,r,o,a,i=Hr,s=Hr,l=Ur,c=jr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==jr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?qr:$r,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Br)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Wr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=zr,u()},d.clamp=function(e){return arguments.length?(c=!!e||jr,u()):c!==jr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(jr,jr)}function Zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Qr,Jr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function eo(e){if(!(t=Jr.exec(e)))throw new Error("invalid format: "+e);var t;return new to({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function to(e){this.fill=void 0===e.fill?" ":e.fill+"",this.align=void 0===e.align?">":e.align+"",this.sign=void 0===e.sign?"-":e.sign+"",this.symbol=void 0===e.symbol?"":e.symbol+"",this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?"":e.type+""}function no(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function ro(e){return(e=no(Math.abs(e)))?e[1]:NaN}function oo(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+r:r.length>o+1?r.slice(0,o+1)+"."+r.slice(o+1):r+new Array(o-r.length+2).join("0")}eo.prototype=to.prototype,to.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var ao={"%":(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>oo(100*e,t),r:oo,s:function(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1],a=o-(Qr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join("0"):a>0?r.slice(0,a)+"."+r.slice(a):"0."+new Array(1-a).join("0")+no(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function io(e){return e}var so,lo,co,uo=Array.prototype.map,po=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];function fo(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Un(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Fn?o*=10:a>=kn?o*=5:a>=Gn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=eo(null==r?",f":r)).type){case"s":var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3)))-ro(Math.abs(e)))}(a,i))||(r.precision=o),co(r,i);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,ro(t)-ro(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(o=function(e){return Math.max(0,-ro(Math.abs(e)))}(a))||(r.precision=o-2*("%"===r.type))}return lo(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Un(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function go(){var e=Yr();return e.copy=function(){return Xr(e,go())},Zr.apply(e,arguments),fo(e)}so=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?io:(t=uo.call(e.grouping,Number),n=e.thousands+"",function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?"":e.currency[0]+"",a=void 0===e.currency?"":e.currency[1]+"",i=void 0===e.decimal?".":e.decimal+"",s=void 0===e.numerals?io:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(uo.call(e.numerals,String)),l=void 0===e.percent?"%":e.percent+"",c=void 0===e.minus?"":e.minus+"",u=void 0===e.nan?"NaN":e.nan+"";function d(e){var t=(e=eo(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,y=e.type;"n"===y?(m=!0,y="g"):ao[y]||(void 0===h&&(h=12),v=!0,y="g"),(f||"0"===t&&"="===n)&&(f=!0,t="0",n="=");var T="$"===p?o:"#"===p&&/[boxX]/.test(y)?"0"+y.toLowerCase():"",b="$"===p?a:/[%p]/.test(y)?l:"",x=ao[y],C=/[defgprs%]/.test(y);function S(e){var o,a,l,p=T,S=b;if("c"===y)S=x(e)+S,e="";else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case".":o=t=r;break;case"0":0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&"+"!==d&&(A=!1),p=(A?"("===d?d:c:"-"===d||"("===d?"":d)+p,S=("s"===y?po[8+Qr/3]:"")+S+(A&&"("===d?")":""),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):"";switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=""),n){case"<":e=p+e+S+w;break;case"=":e=p+w+e+S;break;case"^":e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+""},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=eo(e)).type="f",e)),r=3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3))),o=Math.pow(10,-r),a=po[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:",",grouping:[3],currency:["$",""]}),lo=so.format,co=so.formatPrefix;var mo=n(640),ho=n.n(mo);const vo=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],yo=[1,0,0,0,1,0,0,0,1],To=1e-6,bo=1e-12,{vtkErrorMacro:xo,vtkWarningMacro:Co}=jt;let So=0;function Ao(e){return()=>xo(`vtkMath::${e} - NOT IMPLEMENTED`)}function Io(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function wo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function Po(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function Oo(e){return e/180*Math.PI}function Ro(e){return 180*e/Math.PI}const{round:Mo,floor:Eo,ceil:Do,min:Vo,max:Lo}=Math;const Bo=Ao("ceilLog2"),No=Ao("factorial");function _o(e){let t=1;for(;t<e;)t*=2;return t}function Fo(e){return e===_o(e)}const ko=Ao("gaussian");function Go(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Uo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function zo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Wo(e,t){return e[0]*=t,e[1]*=t,e}function Ho(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function jo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ko(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function $o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function qo(e){const t=$o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Xo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Qo(e){const t=Zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Jo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function ea(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function ta(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function na(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function ra(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function oa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To;if(e.length!==t.length)return!1;function r(e,r){return Math.abs(e-t[r])<=n}return e.every(r)}const aa=oa;function ia(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function sa(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function la(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ca(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes("e"))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split("e");let r="";return+n[1]+t>0&&(r="+"),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ca(e[0],n),t[1]=ca(e[1],n),t[2]=ca(e[2],n),t}function da(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,y,T;const b=Po(t),x=Po(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(sa(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),y=1/Math.sqrt(1+p*p),m=p*y,f=m/(1+y),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return Co("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(a=0;a<t-1;a++){for(i=a,T=n[i],o=a+1;o<t;o++)(n[o]>=T||Math.abs(n[o]-T)<bo)&&(i=o,T=n[i]);i!==a&&(n[i]=n[a],n[a]=T,wo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function pa(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];da([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function fa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=Po(3),r=Po(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(wo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,wo(t,3,1,2)),r[2]=2;let u=0;if(ra(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=Po(4);if(pa(t,d),la(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&wo(t,3,r[1],1),0!==r[0]&&wo(t,3,r[0],0)}function ga(e,t,n){let r,o,a,i,s,l;if(da([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(na(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,Io(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Ko([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);qo(e);const c=Ko(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void na(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,Io(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,Io(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);ra(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),na(n,n)}else ia(n)}function ma(e,t,n){let r,o,a,i,s,l,c,u=0;const d=Po(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return Co("Unable to factor linear system"),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=bo)return Co("Unable to factor linear system"),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ha(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function va(e,t,n){if(2===n){const n=Po(2),r=Jo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=Po(n);return 0===ma(e,r,n)?0:(ha(e,r,t,n),1)}function ya(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const a=r||Po(n),i=o||Po(n);if(0===ma(e,a,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)i[e]=0;i[r]=1,ha(e,a,i,n);for(let e=0;e<n;e++)t[e*n+r]=i[e]}return t}function Ta(e,t,n,r){if(e<n)return Co("Insufficient number of samples. Underdetermined."),0;let o,a,i;const s=Po(n*n),l=Po(n),c=Po(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(da(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ba(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?.3333333333333333+s*(i-o)/(l-c):.6666666666666666+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function xa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function Ca(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function Sa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function Aa(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function Ia(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function wa(e,t){const n=[0,0,0];Ia(e,n),Sa(n,t)}function Pa(e,t){const n=[0,0,0];Ca(e,n),Aa(n,t)}function Oa(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function Ra(e){return!(e[1]-e[0]<0)}function Ma(e,t,n){return e<t?t:e>n?n:e}function Ea(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=Ma(e[0],t[0],n[0]),r[1]=Ma(e[1],t[1],n[1]),r[2]=Ma(e[2],t[2],n[2]),r}const Da=Ao("GetScalarTypeFittingRange"),Va=Ao("GetAdjustedScalarRange");const La=e=>!Number.isFinite(e),{isFinite:Ba,isNaN:Na}=Number,_a=Na;function Fa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ga(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ua(e){return Math.round(255*e)}var za={Pi:()=>Math.PI,ldexp:function(e,t){return t>1023?e*2**1023*2**(t-1023):t<-1074?5e-324*e*2**(t+1074):e*2**t},radiansFromDegrees:Oo,degreesFromRadians:Ro,round:Mo,floor:Eo,ceil:Do,ceilLog2:Bo,min:Vo,max:Lo,arrayMin:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0;for(let o=t,a=e.length;o<a;o+=n)e[o]<r&&(r=e[o]);return r},arrayMax:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=-1/0;for(let o=t,a=e.length;o<a;o+=n)r<e[o]&&(r=e[o]);return r},arrayRange:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0,o=-1/0;for(let a=t,i=e.length;a<i;a+=n)e[a]<r&&(r=e[a]),o<e[a]&&(o=e[a]);return[r,o]},isPowerOfTwo:Fo,nearestPowerOfTwo:_o,factorial:No,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=Po(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){ho()(`${e}`,{global:!0}),So=e},getSeed:function(){return So},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=t-e;return e+n*Math.random()},gaussian:ko,add:Go,subtract:Uo,multiplyScalar:zo,multiplyScalar2D:Wo,multiplyAccumulate:Ho,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:jo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Ko,norm:$o,normalize:qo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=jo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=jo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return zo(n,o),!0},projectVector2D:function(e,t,n){const r=Xo(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Xo(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Wo(n,o),!0},distance2BetweenPoints:Yo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Ko(e,t,n),Math.atan2($o(n),jo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Xo,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Zo,normalize2D:Qo,determinant2x2:Jo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(Io(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,Io(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Jo(s,u,l,d),f=-Jo(i,c,l,d),g=+Jo(i,c,s,u),m=-Jo(o,u,a,d),h=+Jo(r,c,a,d),v=-Jo(r,c,o,u),y=+Jo(o,s,a,l),T=-Jo(r,i,a,l),b=+Jo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+y*t[2],S=f*t[0]+h*t[1]+T*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:ea,multiply3x3_mat3:ta,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&xo("Number of columns of A must match number of rows of B.");const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:na,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Jo(i,c,s,u),p=-Jo(a,l,s,u),f=+Jo(a,l,i,c),g=-Jo(r,c,o,u),m=+Jo(n,l,o,u),h=-Jo(n,l,r,c),v=+Jo(r,i,o,s),y=-Jo(n,a,o,s),T=+Jo(n,a,r,i),b=n*d+r*p+o*f;0===b&&Co("Matrix has 0 determinant"),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=y/b,t[8]=T/b},identity3x3:ia,identity:sa,isIdentity:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,vo,t)},isIdentity3x3:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,yo,t)},determinant3x3:ra,quaternionToMatrix3x3:la,areEquals:oa,areMatricesEqual:aa,roundNumber:ca,roundVector:ua,matrix3x3ToQuaternion:pa,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],y=e[3]*t[3];n[0]=r-l-f-y,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:fa,diagonalize3x3:ga,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=ra(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];fa(a,t),na(a,a),ta(a,t,r),ga(r,n,r),ta(t,r,t),na(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:va,invertMatrix:ya,luFactorLinearSystem:ma,luSolveLinearSystem:ha,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return da(e,3,t,n)},jacobiN:da,solveHomogeneousLeastSquares:Ta,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return Co("Insufficient number of samples. Underdetermined."),0;const s=Po(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>bo&&(p=0,s[u]=0);if(p&&1===o)return Co("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),Ta(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=Po(n),f=Ta(e,t,n,l));const m=Po(n*n),h=Po(n*n),v=Po(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const y=ya(m,h,n);if(y)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&y:y},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ba,hsv2rgb:xa,lab2xyz:Ca,xyz2lab:Sa,xyz2rgb:Aa,rgb2xyz:Ia,rgb2lab:wa,lab2rgb:Pa,uninitializeBounds:Oa,areBoundsInitialized:Ra,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:Ma,clampVector:Ea,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Da,getAdjustedScalarRange:Va,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=Po(3),a=Po(3),i=Po(3),s=Po(3),l=Po(3),c=Po(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=$o(s),d=$o(l),p=$o(i),f=Po(3);Ko(o,a,f);const g=$o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*jo(o,c)/h,y=p*p*jo(s,a)/h,T=u*u*jo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+y*t[o]+T*n[o];return m},inf:1/0,negInf:-1/0,isInf:La,isNan:Na,isNaN:Na,isFinite:Ba,createUninitializedBounds:Fa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:ka,floatToHex2:Ga,floatRGB2HexCode:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#";return`${t}${e.map(Ga).join("")}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ua).join(", ")})`:`rgba(${Ua(e[0]||0)}, ${Ua(e[1]||0)}, ${Ua(e[2]||0)}, ${e[3]||0})`}};function Wa(e,t){t.classHierarchy.push("vtkImplicitFunction"),e.functionValue=n=>{if(!t.transform)return e.evaluateFunction(n);const r=[];return t.transform.transformPoint(n,r),e.evaluateFunction(r)},e.evaluateFunction=e=>{jt.vtkErrorMacro("not implemented")}}const Ha={};function ja(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ha,n),jt.obj(e,t),jt.setGet(e,t,["transform"]),Wa(e,t)}var Ka={newInstance:jt.newInstance(ja,"vtkImplicitFunction"),extend:ja};const $a=1e-6,qa="coincide",Xa="disjoint";function Ya(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function Za(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function Qa(e,t,n){const r=jo(e,t);let o=jo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Ja(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o),i=jo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function ei(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Uo(t,e,a),Uo(n,e,i);const s=jo(r,i),l=jo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*$a:s*$a,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function ti(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Ko(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<$a){const r=[];return Uo(e,n,r),0===jo(t,r)?o.error=qa:o.error=Xa,o}let s;s=i[0]>i[1]&&i[0]>i[2]?"x":i[1]>i[2]?"y":"z";const l=[],c=-jo(t,e),u=-jo(r,n);switch(s){case"x":l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case"y":l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case"z":l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Go(l,a,o.l1),o.intersection=!0,o}const ni={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ya,projectPoint:Za,projectVector:Qa,generalizedProjectPoint:Ja,intersectWithLine:ei,intersectWithPlane:ti,DISJOINT:Xa,COINCIDE:qa};function ri(e,t){t.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>Ya(e,t.origin,t.normal),e.projectPoint=(e,n)=>{Za(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>Qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Ja(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>ei(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>ti(e,n,t.origin,t.normal)}const oi={normal:[0,0,1],origin:[0,0,0]};function ai(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oi,n),Ka.extend(e,t,n),jt.setGetArray(e,t,["normal","origin"],3),ri(e,t)}var ii={newInstance:jt.newInstance(ai,"vtkPlane"),extend:ai,...ni};const si=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function li(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ci(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ui(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function di(e){return ui(e,si)}function pi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function fi(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)pi(e,...t[n]);else for(let n=0;n<t.length;n+=3)pi(e,...t.slice(n,n+3));return e}function gi(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function mi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function hi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function vi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function yi(e,t,n,r){return!!ci(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function Ti(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function bi(e,t){return e[2*t+1]-e[2*t]}function xi(e){return[bi(e,0),bi(e,1),bi(e,2)]}function Ci(e){return e.slice(0,2)}function Si(e){return e.slice(2,4)}function Ai(e){return e.slice(4,6)}function Ii(e){const t=xi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function wi(e){if(ci(e)){const t=xi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Pi(e){return[e[0],e[2],e[4]]}function Oi(e){return[e[1],e[3],e[5]]}function Ri(e,t){return e<=0&&t>=0||e>=0&&t<=0}function Mi(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function Ei(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Di(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=Mi(e,[]);for(let e=0;e<r.length;++e)Vn(r[e],r[e],t);return di(n),fi(n,r)}function Vi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Li(e,t,n,r){const o=[].concat(si),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=jo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=jo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=jo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Bi(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ni(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ii.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function _i(e,t){if(!ci(e)||!ci(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Fi(e,t){if(!ci(e)||!ci(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function ki(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Gi(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ii.evaluate(n,t,l)}let i=2;for(;i--&&!(Ri(o[r[i][0]],o[r[i][4]])&&Ri(o[r[i][1]],o[r[i][5]])&&Ri(o[r[i][2]],o[r[i][6]])&&Ri(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class Ui{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(si))}getBounds(){return this.bounds}equals(e){return li(this.bounds,e)}isValid(){return ci(this.bounds)}setBounds(e){return ui(this.bounds,e)}reset(){return di(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return pi(this.bounds,...t)}addPoints(e){return fi(this.bounds,e)}addBounds(e,t,n,r,o,a){return gi(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return mi(this.bounds,e,t,n)}setMaxPoint(e,t,n){return hi(this.bounds,e,t,n)}inflate(e){return vi(this.bounds,e)}scale(e,t,n){return yi(this.bounds,e,t,n)}getCenter(){return Ti(this.bounds)}getLength(e){return bi(this.bounds,e)}getLengths(){return xi(this.bounds)}getMaxLength(){return Ii(this.bounds)}getDiagonalLength(){return wi(this.bounds)}getMinPoint(){return Pi(this.bounds)}getMaxPoint(){return Oi(this.bounds)}getXRange(){return Ci(this.bounds)}getYRange(){return Si(this.bounds)}getZRange(){return Ai(this.bounds)}getCorners(e){return Mi(this.bounds,e)}computeCornerPoints(e,t){return Ei(this.bounds,e,t)}computeLocalBounds(e,t,n){return Li(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Di(this.bounds,e,t)}computeScale3(e){return Vi(this.bounds,e)}cutWithPlane(e,t){return Gi(this.bounds,e,t)}intersectBox(e,t,n,r){return Bi(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ni(this.bounds,e,t)}intersect(e){return _i(this.bounds,e)}intersects(e){return Fi(this.bounds,e)}containsPoint(e,t,n){return ki(this.bounds,e,t,n)}contains(e){return Fi(this.bounds,e)}}var zi,Wi={newInstance:function(e){const t=e&&e.bounds;return new Ui(t)},equals:li,isValid:ci,setBounds:ui,reset:di,addPoint:pi,addPoints:fi,addBounds:gi,setMinPoint:mi,setMaxPoint:hi,inflate:vi,scale:yi,scaleAboutCenter:function(e,t,n,r){if(!ci(e))return!1;const o=Ti(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],yi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:Ti,getLength:bi,getLengths:xi,getMaxLength:Ii,getDiagonalLength:wi,getMinPoint:Pi,getMaxPoint:Oi,getXRange:Ci,getYRange:Si,getZRange:Ai,getCorners:Mi,computeCornerPoints:Ei,computeLocalBounds:Li,transformBounds:Di,computeScale3:Vi,cutWithPlane:Gi,intersectBox:Bi,intersectPlane:Ni,intersect:_i,intersects:Fi,containsPoint:ki,contains:function(e,t){return!!Fi(e,t)&&!!ki(e,...Pi(t))&&!!ki(e,...Oi(t))},INIT_BOUNDS:si};function Hi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function ji(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Ki(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function $i(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}zi=new i(4),i!=Float32Array&&(zi[0]=0,zi[1]=0,zi[2]=0,zi[3]=0);var qi=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};Cn(),An(1,0,0),An(0,1,0),ji(),ji(),ie();var Xi={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Yi}=Xi;function Zi(e){return()=>jt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}function Qi(e,t){t.classHierarchy.push("vtkProp"),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=Zi("pick"),e.hasKey=Zi("hasKey"),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Yi.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Yi.DISPLAY)}const Ji={allocatedRenderTime:10,coordinateSystem:Yi.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),jt.obj(e,t),jt.get(e,t,["estimatedRenderTime","allocatedRenderTime"]),jt.setGet(e,t,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),jt.moveToProtected(e,t,["parentProp"]),Qi(e,t)}var ts={newInstance:jt.newInstance(es,"vtkProp"),extend:es,...Xi};function ns(e,t){t.classHierarchy.push("vtkProp3D"),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=ji();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[Ro(r),n[0],n[1],n[2]]},e.getOrientationQuaternion=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return N(e,t.rotation)},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=Oo(n),s=ji();Ki(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),T(t.rotation,t.rotation,l),e.modified()},e.rotateQuaternion=n=>{if(Math.abs(n[3])>=.999999)return;const r=k(new Float64Array(16),n);T(t.rotation,t.rotation,r),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!aa(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&T(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),T(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getCenter=()=>Wi.getCenter(t.bounds),e.getLength=()=>Wi.getLength(t.bounds),e.getXRange=()=>Wi.getXRange(t.bounds),e.getYRange=()=>Wi.getYRange(t.bounds),e.getZRange=()=>Wi.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()}))}const rs={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function os(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rs,n),ts.extend(e,t,n),t.matrixMTime={},jt.obj(t.matrixMTime),jt.get(e,t,["bounds","isIdentity"]),jt.getArray(e,t,["orientation"]),jt.setGetArray(e,t,["origin","position","scale"],3),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,ns(e,t)}var as={newInstance:jt.newInstance(os,"vtkProp3D"),extend:os};const is={FLAT:0,GOURAUD:1,PHONG:2},ss={POINTS:0,WIREFRAME:1,SURFACE:2};var ls={Shading:is,Representation:ss,Interpolation:is};const{Representation:cs,Interpolation:us}=ls;function ds(e){return()=>jt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}function ps(e,t){t.classHierarchy.push("vtkProperty"),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ds("ComputeCompositeColor"),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ds("AddShaderVariable"),e.setInterpolationToFlat=()=>e.setInterpolation(us.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(us.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(us.PHONG),e.getInterpolationAsString=()=>jt.enumToString(us,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(cs.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(cs.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(cs.POINTS),e.getRepresentationAsString=()=>jt.enumToString(cs,t.representation)}const fs={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:us.GOURAUD,representation:cs.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function gs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fs,n),jt.obj(e,t),jt.setGet(e,t,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture"]),jt.setGetArray(e,t,["ambientColor","specularColor","diffuseColor","edgeColor"],3),ps(e,t)}var ms={newInstance:jt.newInstance(gs,"vtkProperty"),extend:gs,...ls};const{vtkDebugMacro:hs}=jt;function vs(e,t){t.classHierarchy.push("vtkActor");const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(null===t.property&&e.setProperty(e.makeProperty()),!e.getIsOpaque()),e.makeProperty=ms.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||n[0]!==t.mapperBounds[0]||n[1]!==t.mapperBounds[1]||n[2]!==t.mapperBounds[2]||n[3]!==t.mapperBounds[3]||n[4]!==t.mapperBounds[4]||n[5]!==t.mapperBounds[5]||e.getMTime()>t.boundsMTime.getMTime()){hs("Recomputing bounds..."),t.mapperBounds=n.concat();const r=[];Wi.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}return t.bounds},e.getMTime=()=>{let e=n.getMTime();if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}const ys={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function Ts(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ys,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),vs(e,t)}var bs={newInstance:jt.newInstance(Ts,"vtkActor"),extend:Ts};const xs={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},Cs={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",UNSIGNED_CHAR_CLAMPED:"Uint8ClampedArray",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"};var Ss={DefaultDataType:Cs.FLOAT,DataTypeByteSize:xs,VtkDataTypes:Cs};const{vtkErrorMacro:As}=Kt,{DefaultDataType:Is}=Ss,ws=1e-6;function Ps(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function Os(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return Ps(r,0,1)}return Ps(e,t<0?0:t,n)}function Rs(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function Ms(e){return Object.prototype.toString.call(e).slice(8,-1)}const Es={computeRange:Os,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get:()=>({min:e,max:t,count:n,sum:r,mean:r/n}),getRange:()=>({min:e,max:t})}},fastComputeRange:Ps,getDataType:Ms,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=$o(r,t);a>n&&(n=a)}return n}};function Ds(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push("vtkDataArray"),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=Rs(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=Os(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=Rs(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ws;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return e*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>Bs({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=Ms(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||As("numberOfComponents must match");const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}const Vs={name:"",numberOfComponents:1,dataType:Is,rangeTuple:[0,0]};function Ls(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Vs,n),Array.isArray(n.values)&&void 0===n.dataType&&console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"),!t.empty&&!t.values&&!t.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=Ms(t.values)),yt(e,t),St(e,t,["name","numberOfComponents"]),t.size%t.numberOfComponents!=0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");Ds(e,t)}const Bs=Dt(Ls,"vtkDataArray");var Ns={newInstance:Bs,extend:Ls,...Es,...Ss};function _s(e,t){t.classHierarchy.push("vtkAbstractMapper"),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA("vtkPlane")&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}jt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Fs={clippingPlanes:[]};var ks=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fs,n),jt.obj(e,t),jt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),_s(e,t)};function Gs(e,t){e.getBounds=()=>(jt.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),Fa()),e.getCenter=()=>{const n=e.getBounds();return t.center=Wi.isValid(n)?Wi.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return Wi.getDiagonalLength(t)}}const Us=e=>({bounds:[...Wi.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e});var zs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Us(n)),ks(e,t,n),jt.setGet(e,t,["viewSpecificProperties"]),Gs(e,t)};const{vtkErrorMacro:Ws,vtkWarningMacro:Hs}=jt;function js(e,t){t.classHierarchy.push("vtkFieldData");const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>"number"==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():""},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else Ws("Unhandled case in passData");else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Ns.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:jt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Hs("Unexpected case in interpolateData")}else t.insertTuples(s.getTuples());else Ws("Unhandled case in interpolateData");else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Ns.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:jt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}const Ks={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function $s(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ks,n),jt.obj(e,t),js(e,t)}var qs={newInstance:jt.newInstance($s,"vtkFieldData"),extend:$s};const Xs={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ys={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:Xs,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:"vtkGhostType"};const{AttributeTypes:Zs,AttributeCopyOperations:Qs}=Ys,{vtkWarningMacro:Js}=jt;function el(e,t){const n=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function r(e){let t=n.find((t=>Zs[t.toUpperCase()]===e||"number"!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push("vtkDataSetAttributes");const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&"PEDIGREEIDS"===a.toUpperCase()&&!n.isA("vtkDataArray"))return Js(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Js(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if("PEDIGREEIDS"!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA("vtkDataArray"))return Js(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Js(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Qs.PASSDATA][Zs[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Qs.PASSDATA][Zs[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(Qs).filter((e=>"ALLCOPY"!==e)).forEach((e=>{t.copyAttributeFlags[Qs[e]]=Object.keys(Zs).filter((e=>"NUM_ATTRIBUTES"!==e)).reduce(((e,t)=>(e[Zs[t]]=!0,e)),[])})),t.copyAttributeFlags[Qs.COPYTUPLE][Zs.GLOBALIDS]=!1,t.copyAttributeFlags[Qs.INTERPOLATE][Zs.GLOBALIDS]=!1,t.copyAttributeFlags[Qs.COPYTUPLE][Zs.PEDIGREEIDS]=!1},e.initialize=jt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||"vtkDataArray"!==t.dataArrays[n].type||e.addArray(Ns.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}const tl={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function nl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tl,n),qs.extend(e,t,n),jt.setGet(e,t,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),t.arrays||(t.arrays={}),el(e,t)}var rl={newInstance:jt.newInstance(nl,"vtkDataSetAttributes"),extend:nl,...Ys};const ol=["pointData","cellData","fieldData"];function al(e,t){t.classHierarchy.push("vtkDataSet"),ol.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=rl.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),ol.forEach((n=>{t[n]=rl.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}const il={};function sl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,il,n),jt.obj(e,t),jt.setGet(e,t,ol),al(e,t)}var ll={newInstance:jt.newInstance(sl,"vtkDataSet"),extend:sl,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const cl={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var ul={StructuredType:cl};const{StructuredType:dl}=ul;var pl={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?dl.EMPTY:3===t?dl.XYZ_GRID:2===t?e[0]===e[1]?dl.YZ_PLANE:e[2]===e[3]?dl.XZ_PLANE:dl.XY_PLANE:1===t?e[0]<e[1]?dl.X_LINE:e[2]<e[3]?dl.Y_LINE:dl.Z_LINE:dl.SINGLE_POINT},...ul};const{vtkErrorMacro:fl}=jt;function gl(e,t){t.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(t.deleted)return fl("instance deleted - cannot call any method"),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=pl.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)fl("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void fl("Bad dimension specification");n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return fl("Requesting a point from an empty image."),null;const o=new Float64Array(3);switch(t.dataDescription){case cl.EMPTY:return null;case cl.SINGLE_POINT:break;case cl.X_LINE:o[0]=n;break;case cl.Y_LINE:o[1]=n;break;case cl.Z_LINE:o[2]=n;break;case cl.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case cl.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case cl.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case cl.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:fl("Invalid dataDescription")}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>Wi.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>Wi.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Wi.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Wi.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>Wi.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];Wi.computeCornerPoints(r,o,a),ua(o,o),ua(a,a);const i=e.getDimensions();Ea(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Ea(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0,v=Math.sqrt(h);return{minimum:d,maximum:u,average:m,variance:h,sigma:v,count:g}},e.computeIncrements=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=[];let r=t;for(let t=0;t<3;++t)n[t]=r,r*=e[2*t+1]-e[2*t]+1;return n},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return fl(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return fl(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}const ml={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:cl.EMPTY};function hl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ml,n),ll.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),jt.get(e,t,["indexToWorld","worldToIndex"]),jt.setGetArray(e,t,["origin","spacing"],3),jt.setGetArray(e,t,["direction"],9),jt.getArray(e,t,["extent"],6),gl(e,t)}var vl={newInstance:jt.newInstance(hl,"vtkImageData"),extend:hl};const yl={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var Tl={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:yl},bl={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:xl,VectorMode:Cl}=Tl,{VtkDataTypes:Sl}=Ns,{ColorMode:Al}=bl,{vtkErrorMacro:Il}=jt;function wl(e){return e}function Pl(e){return Math.floor(255*e+.5)}function Ol(e,t){t.classHierarchy.push("vtkScalarsToColors"),e.setVectorModeToMagnitude=()=>e.setVectorMode(Cl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(Cl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(Cl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)Il("Values and annotations do not have the same number of tuples so ignoring");else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===Al.DEFAULT&&(t.getDataType()===Sl.UNSIGNED_CHAR||t.getDataType()===Sl.UNSIGNED_CHAR_CLAMPED)||n===Al.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:Sl.UNSIGNED_CHAR},i=jt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Ns.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,xl.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,xl.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===Cl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==Cl.MAGNITUDE||1!==c&&1!==s||(i=Cl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case Cl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case Cl.RGBCOLORS:break;case Cl.MAGNITUDE:default:{const o=Ns.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=Pl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Sl.UNSIGNED_CHAR)return n;const i=Ns.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Sl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=wl;switch(n.getDataType()!==Sl.FLOAT&&n.getDataType()!==Sl.DOUBLE||(s=Pl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return Il("Cannot convert colors"),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==Al.DEFAULT||n.getDataType()!==Sl.UNSIGNED_CHAR)&&r!==Al.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}const Rl={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:Cl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function Ml(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rl,n),jt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],jt.setGet(e,t,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),jt.setArray(e,t,["mappingRange"],2),jt.getArray(e,t,["mappingRange"]),Ol(e,t)}var El={newInstance:jt.newInstance(Ml,"vtkScalarsToColors"),extend:Ml,...Tl};const{vtkErrorMacro:Dl}=jt;function Vl(e,t){t.classHierarchy.push("vtkLookupTable"),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4-3,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=_a(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===yl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===yl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,xa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return Dl("Expected 4 components for RGBA colors"),!1;if(n.getDataType()!==Cs.UNSIGNED_CHAR)return Dl("Expected unsigned char values for RGBA colors"),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}const Ll={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Bl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ll,n),El.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},jt.obj(t.buildTime),t.opaqueFlagBuildTime={},jt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},jt.obj(t.insertTime,{mtime:0}),jt.get(e,t,["buildTime"]),jt.setGet(e,t,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),jt.setArray(e,t,["alphaRange","hueRange","saturationRange","valueRange"],2),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),Vl(e,t)}var Nl={newInstance:jt.newInstance(Bl,"vtkLookupTable"),extend:Bl};const _l={Off:0,PolygonOffset:1};let Fl=_l.PolygonOffset,kl=_l.Off;const Gl=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function Ul(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=kl===e;return kl=e,t}var zl={Resolve:_l,getResolveCoincidentTopologyAsString:function(){return Gl[kl]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return Fl},getResolveCoincidentTopology:function(){return kl},setResolveCoincidentTopology:Ul,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){const t=Fl===e;return Fl=e,t},setResolveCoincidentTopologyToDefault:function(){return Ul(_l.Off)},setResolveCoincidentTopologyToOff:function(){return Ul(_l.Off)},setResolveCoincidentTopologyToPolygonOffset:function(){return Ul(_l.PolygonOffset)}};function Wl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=jt.objectSetterMap.object(e,t,{name:n.key,params:["factor","offset"]})}))}const Hl=["Polygon","Line","Point"],jl={modified:()=>{}};Wl(jl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},Hl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Kl={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),jt.setGet(e,t,["resolveCoincidentTopology"]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(zl).forEach((t=>{e[t]=zl[t]})),Object.keys(jl).filter((e=>"modified"!==e)).forEach((t=>{e[t]=jl[t]})),Wl(e,t.topologyOffset,Hl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=jl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=jl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=jl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:jl,otherStaticMethods:zl,CATEGORIES:Hl,Resolve:_l};const $l={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var ql={PassTypes:$l};const{FieldAssociations:Xl}=ll,{staticOffsetAPI:Yl,otherStaticMethods:Zl}=Kl,{ColorMode:Ql,ScalarMode:Jl,GetArray:ec}=bl,{VectorMode:tc}=Tl,{VtkDataTypes:nc}=Ns;function rc(e){return()=>jt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function oc(e,t){const n=e[1]%2==0?1:-1;if(e[0]+=n,e[0]>=t[0]||e[0]<0){const r=e[2]%2==0?1:-1;e[0]-=n,e[1]+=r,(e[1]>=t[1]||e[1]<0)&&(e[1]-=r,e[2]++)}}function ac(e,t,n){const r=Math.floor(t),o=r%(2*n[0]);let a,i;o<n[0]?(e[0]=o,a=1,i=e[0]===n[0]-1):(e[0]=2*n[0]-1-o,a=-1,i=0===e[0]);const s=Math.floor(r/n[0]),l=s%(2*n[1]);let c,u;l<n[1]?(e[1]=l,c=1,u=e[1]===n[1]-1):(e[1]=2*n[1]-1-l,c=-1,u=0===e[1]),e[2]=Math.floor(s/n[1]);const d=t-r;i?u?e[2]+=d:e[1]+=c*d:e[0]+=a*d,e[0]=(e[0]+.5)/n[0],e[1]=(e[1]+.5)/n[1],e[2]=(e[2]+.5)/n[2]}const ic=new WeakMap;function sc(e,t){t.classHierarchy.push("vtkMapper"),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=Nl.newInstance()},e.getColorModeAsString=()=>jt.enumToString(Ql,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(Jl,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFlag:!1};let i=null,s=!1;if(n===Jl.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===Jl.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===Jl.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===Jl.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Jl.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Jl.USE_FIELD_DATA){const t=e.getFieldData();i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const{scalars:o,cellFlag:a}=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName);if(t.areScalarsMappedFromCells=a,!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const i=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==i){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(o,a))t.mapScalarsToTexture(o,a,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},t.mapScalarsToTexture=(n,r,o)=>{const a=t.lookupTable.getRange(),i=t.lookupTable.usingLogScale();i&&Nl.getLogRange(a,a);const s=t.lookupTable.getAlpha();if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==o){t.lookupTable.setAlpha(o),t.colorTextureMap=null,t.lookupTable.build();const e=t.lookupTable.getNumberOfAvailableColors(),n=2048,u=n**3-3,d=4094,p=2,f=r?u:d;t.numberOfColorsInRange=Math.min(Math.max(e,p),f);const g=t.numberOfColorsInRange+3,m=t.numberOfColorsInRange+2,h=r?[Math.min(Math.ceil(g/n**0),n),Math.min(Math.ceil(g/n**1),n),Math.min(Math.ceil(g/n**2),n)]:[m,2,1],v=h[0]*h[1]*h[2],y=new Float64Array(v);y.fill(NaN);const T=t.numberOfColorsInRange,b=T+2,x=[0,0,0],C=a[0],S=a[1]-a[0];for(let e=0;e<b;++e){const t=C+S*(e-1)/(T-1);y[(c=h,(l=x)[0]+c[0]*(l[1]+c[1]*l[2]))]=i?10**t:t,oc(x,h)}const A=Ns.newInstance({numberOfComponents:1,values:y}),I=t.lookupTable.mapScalars(A,t.colorMode,0);t.colorTextureMap=vl.newInstance(),t.colorTextureMap.setDimensions(h),t.colorTextureMap.getPointData().setScalars(I),t.lookupTable.setAlpha(s)}var l,c;const u=t.lookupTable.getVectorMode()===tc.MAGNITUDE&&n.getNumberOfComponents()>1?-1:t.lookupTable.getVectorComponent();t.colorCoordinates=function(e,t,n,r,o,a,i){const s=new Array(arguments.length);for(let e=0;e<arguments.length;++e){const t=arguments[e];s[e]=t.getMTime?.()??t}const l=s.join("/"),c=ic.get(e);if(c&&c.stringHash===l)return c.textureCoordinates;const u=(n[1]-n[0])/(r-1),[d,p]=[n[0]-u,n[1]+u],f=d-.5*u,g=1/(p-d+u),m=d,h=(r+1)/(p-d),v=e.getData(),y=e.getNumberOfTuples(),T=e.getNumberOfComponents(),b=t<0||t>=T,x=o[2]<=1?2:3,C=Ns.newInstance({numberOfComponents:x,values:new Float32Array(y*x)}),S=C.getData(),A=[0,0,0];ac(A,r+2,o);let I=0,w=0;const P=[.5,.5,.5];for(let e=0;e<y;++e){let e;if(b){let t=0;for(let e=0;e<T;++e){const n=v[I+e];t+=n*n}e=Math.sqrt(t)}else e=v[I+t];if(I+=T,a&&(e=Nl.applyLogScale(e,n,n)),_a(e))P[0]=A[0],P[1]=A[1],P[2]=A[2];else if(i){let t=(e-m)*h;t<1?t=0:t>r&&(t=r+1),ac(P,t,o)}else{P[1]=.49;const t=(e-f)*g;P[0]=t>1e3?1e3:t<-1e3?-1e3:t}for(let e=0;e<x;++e)S[w++]=P[e]}return ic.set(e,{stringHash:l,textureCoordinates:C}),C}(n,u,a,t.numberOfColorsInRange,t.colorTextureMap.getDimensions(),i,r)},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=(e,n)=>!((!n||t.colorMode===Ql.DIRECT_SCALARS)&&(!t.interpolateScalarsBeforeMapping||t.lookupTable&&t.lookupTable.getIndexedLookup()||!e||t.colorMode===Ql.DEFAULT&&e.getDataType()===nc.UNSIGNED_CHAR||t.colorMode===Ql.DIRECT_SCALARS)),e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=rc("AcquireInvertibleLookupTable"),e.valueToColor=rc("ValueToColor"),e.colorToValue=rc("ColorToValue"),e.useInvertibleColorFor=rc("UseInvertibleColorFor"),e.clearInvertibleColor=rc("ClearInvertibleColor"),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer($l.ID_LOW24),o=e.getRawPixelBuffer($l.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Xl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Xl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===$l.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer($l.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===$l.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n];e.getPixelBuffer($l.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}const lc={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lc,n),zs(e,t,n),jt.get(e,t,["areScalarsMappedFromCells","colorCoordinates","colorMapColors","colorTextureMap","numberOfColorsInRange","selectionWebGLIdsToVTKIds"]),jt.setGet(e,t,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),Kl.implementCoincidentTopologyMethods(e,t),sc(e,t)}var uc={newInstance:jt.newInstance(cc,"vtkMapper"),extend:cc,...Yl,...Zl,...bl};function dc(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function pc(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const fc={extractCellSizes:dc,getNumberOfCells:pc};function gc(e,t){t.classHierarchy.push("vtkCellArray");const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=pc(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=dc(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}function mc(e){return{empty:!0,numberOfComponents:1,dataType:Cs.UNSIGNED_INT,...e}}function hc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Ns.extend(e,t,mc(n)),gc(e,t)}var vc={newInstance:jt.newInstance(hc,"vtkCellArray"),extend:hc,...fc};const{vtkErrorMacro:yc}=jt,Tc=[1,-1,1,-1,1,-1];function bc(e,t){t.classHierarchy.push("vtkPoints"),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=jt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return yc(`getBounds called on an array with components of\n        ${e.getNumberOfComponents()}`),Tc;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}const xc={empty:!0,numberOfComponents:3,dataType:Cs.FLOAT,bounds:[1,-1,1,-1,1,-1]};function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xc,n),Ns.extend(e,t,n),bc(e,t)}var Sc={newInstance:jt.newInstance(Cc,"vtkPoints"),extend:Cc};function Ac(e,t){t.classHierarchy.push("vtkCell"),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=jt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else Oa(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{jt.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}const Ic={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function wc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ic,n),jt.obj(e,t),t.points||(t.points=Sc.newInstance()),jt.get(e,t,["points","pointsIds"]),Ac(e,t)}var Pc={newInstance:jt.newInstance(wc,"vtkCell"),extend:wc};function Oc(e,t){t.classHierarchy.push("vtkCellLinks"),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA("vtkPolyData")){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Pc.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Pc.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}const Rc={array:null,maxId:0,extend:0};function Mc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rc,n),jt.obj(e,t),Oc(e,t)}var Ec={newInstance:jt.newInstance(Mc,"vtkCellLinks"),extend:Mc};const Dc=0,Vc=1,Lc=2,Bc=3,Nc=4,_c=5,Fc=6,kc=7,Gc=9,Uc=21,zc=41,Wc=42,Hc=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"],jc={getClassNameFromTypeId:function(e){return e<Hc.length?Hc[e]:"UnknownClass"},getTypeIdFromClassName:function(e){return Hc.findIndex(e)},isLinear:function(e){return e<Uc||e===zc||e===Wc},hasSubCells:function(e){return e===Fc||e===Nc||e===Lc}};function Kc(e,t){t.classHierarchy.push("vtkCellTypes"),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=Dc},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}const $c={size:0,maxId:-1,extend:1e3};function qc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$c,n),jt.obj(e,t),jt.get(e,t,["size","maxId","extend"]),jt.getArray(e,t,["typeArray","locationArray"]),Kc(e,t)}var Xc={newInstance:jt.newInstance(qc,"vtkCellTypes"),extend:qc,...jc},Yc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Zc}=Yc;function Qc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=jo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Yo(i,e),o}function Jc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Uo(t,e,i),Uo(r,n,s),Uo(n,e,l);const c=[jo(i,i),-jo(i,s),-jo(i,s),jo(s,s)],u=[];if(u[0]=jo(i,l),u[1]=-jo(s,l),0===va(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Qc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance);return Zc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Zc.YES_INTERSECTION:Zc.NO_INTERSECTION}const eu={distanceToLine:Qc,intersection:Jc};function tu(e,t){t.classHierarchy.push("vtkLine"),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=Jc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Zc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Yo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Qc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Qc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Qc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Qc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}const nu={orientations:null};function ru(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nu,n),Pc.extend(e,t,n),jt.setGet(e,t,["orientations"]),tu(e,t)}var ou={newInstance:jt.newInstance(ru,"vtkLine"),extend:ru,...eu,...Yc};function au(e,t){t.classHierarchy.push("vtkPointSet"),t.points?t.points=We(t.points):t.points=Sc.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),t.points=Sc.newInstance(),t.points.shallowCopy(e.getPoints())}}const iu={};function su(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iu,n),ll.extend(e,t,n),jt.setGet(e,t,["points"]),au(e,t)}var lu={newInstance:jt.newInstance(su,"vtkPointSet"),extend:su};function cu(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function uu(e,t,n,r){cu(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const du={computeNormalDirection:cu,computeNormal:uu,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];uu(e,t,n,d),uu(r,o,a,p);const f=-jo(d,e),g=-jo(p,r),m=[jo(p,e)+g,jo(p,t)+g,jo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[jo(d,r)+f,jo(d,o)+f,jo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],y=[r,o,a],T=jo(d,p),b=(f-g*T)/(T*T-1),x=(g-f*T)/(T*T-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Ko(d,p,[]);qo(S);let A=0,I=0;const w=[],P=[];let O,R,M=50,E=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ii.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=jo(a.x,S)-jo(C,S));const s=ii.intersectWithLine(y[n],y[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(E=I),P[I++]=jo(s.x,S)-jo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=P[2];P[2]=P[E],P[E]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(P[0])||Number.isNaN(P[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(P[0]>P[1]){const e=P[1];P[1]=P[0],P[0]=e}return w[1]<P[0]||P[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<P[0]?w[1]<P[1]?(u[0]=2,u[1]=1,O=P[0],R=w[1]):(u[0]=2,u[1]=2,O=P[0],R=P[1]):w[1]<P[1]?(u[0]=1,u[1]=1,O=w[0],R=w[1]):(u[0]=1,u[1]=2,O=w[0],R=P[1]),Ho(C,S,O,l),Ho(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}};function pu(e,t){t.classHierarchy.push("vtkTriangle"),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(uu(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ii.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Yo(u,d),h=Yo(d,p),v=Yo(p,u);t.line||(t.line=ou.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const y=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=y.betweenPoints,s.t=y.t,y.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=jo(n,e)/v,i[1]=jo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const y=[];let T,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),cu(l,c,u,d),ii.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(y[s++]=i);for(i=0;i<2;i++)f[i]=I[y[i]]-u[y[i]],g[i]=l[y[i]]-u[y[i]],m[i]=c[y[i]]-u[y[i]];if(h=Jo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Jo(f,m)/h,r[1]=Jo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Yo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(T=Yo(e,u),b=ou.distanceToLine(e,l,u,t,S),x=ou.distanceToLine(e,u,c,t,A),T<b?(a.dist2=T,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(T=Yo(e,l),b=ou.distanceToLine(e,l,u,t,S),x=ou.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(T=Yo(e,c),b=ou.distanceToLine(e,c,u,t,S),x=ou.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=ou.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=ou.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=ou.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}const fu={};function gu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fu,n),Pc.extend(e,t,n),pu(e,t)}var mu={newInstance:jt.newInstance(gu,"vtkTriangle"),extend:gu,...du};const hu=["verts","lines","polys","strips"],{vtkWarningMacro:vu}=jt,yu={[Bc]:ou,[Nc]:ou,[_c]:mu};function Tu(e,t){t.classHierarchy.push("vtkPolyData"),hu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(e=>e.toUpperCase())).replace(/\s+/g,"")}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=vc.newInstance()})),e.getNumberOfCells=()=>hu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),hu.forEach((n=>{t[n]=vc.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?Lc:Vc,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?Nc:Bc,1===t&&vu("Building VTK_LINE ",n," with only one point, but VTK_LINE needs at least two points. Check the input."),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=_c;break;case 4:l[n]=Gc;break;default:l[n]=kc}t<3&&vu("Building VTK_TRIANGLE ",n," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(Fc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=Xc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Ec.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case Vc:case Lc:o=t.verts;break;case Bc:case Nc:o=t.lines;break;case _c:case Gc:case kc:o=t.polys;break;case Fc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||yu[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}const bu={};function xu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bu,n),lu.extend(e,t,n),jt.get(e,t,["cells","links"]),jt.setGet(e,t,["verts","lines","polys","strips"]),Tu(e,t)}var Cu={newInstance:jt.newInstance(xu,"vtkPolyData"),extend:xu};function Su(e,t){t.classHierarchy.push("vtkTexture"),e.imageLoaded=()=>{t.image.removeEventListener("load",e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener("load",e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData();if(t.canvas)return t.canvas.getContext("2d").getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=document.createElement("canvas");e.width=t.image.width,e.height=t.image.height;const n=e.getContext("2d");return n.translate(0,e.height),n.scale(1,-1),n.drawImage(t.image,0,0,t.image.width,t.image.height),n.getImageData(0,0,e.width,e.height)}return null}}const Au={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function Iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Au,n),jt.obj(e,t),jt.algo(e,t,6,0),jt.get(e,t,["canvas","image","jsImageData","imageLoaded","resizable"]),jt.setGet(e,t,["repeat","edgeClamp","interpolate","mipLevel"]),Su(e,t)}const wu={generateMipmaps:(e,t,n,r)=>{const o=[1,2,1],a=e.length/(t*n);let i=t,s=n,l=e;const c=[l];for(let e=0;e<r;e++){const e=[...l];i/=2,s/=2,l=new Uint8ClampedArray(i*s*a);const t=a*i;let n=0;for(let r=0;r<l.length;r+=a){r%t==0&&(n+=2*a*i);for(let o=0;o<a;o++){let i=e[n+o];i+=e[n+a+o],i+=e[n-2*t+o],i+=e[n-2*t+a+o],i/=4,l[r+o]=i}n+=2*a}let r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let i=-(o.length-1)/2,s=4,c=0;for(let l=0;l<o.length;l++){let u=e+n+i*a;const d=u%t-(e+n)%t;d>a&&(u+=t),d<-a&&(u-=t),r[u]?c+=r[u]*o[l]:s-=o[l],i+=1}l[e+n]=c/s}r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let a=-(o.length-1)/2,i=4,s=0;for(let l=0;l<o.length;l++){const c=e+n+a*t;r[c]?s+=r[c]*o[l]:i-=o[l],a+=1}l[e+n]=s/i}c.push(l)}return c}};var Pu={newInstance:jt.newInstance(Iu,"vtkTexture"),extend:Iu,...wu};const Ou=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],Ru=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],Mu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Eu=[0,1,0,1,0,1,0,1,2,2,2,2],Du=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Vu=new Float64Array(3),Lu=new Float64Array(3),Bu=new Float64Array(3),Nu=new Float64Array(3),_u=new Float64Array(3),Fu=new Float64Array(3),ku=new Float64Array(16);function Gu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Uu(e){const t=[],n=[];for(let r=0;r<3;r++){const o=go().domain([e[2*r],e[2*r+1]]);t[r]=o.ticks(5);const a=o.tickFormat(5);n[r]=t[r].map(a)}return{ticks:t,tickStrings:n}}function zu(e,t){t.classHierarchy.push("vtkCubeAxesActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Vu[0]=c[3*n],Vu[1]=c[3*n+1],Vu[2]=c[3*n+2],Vn(Bu,Vu,r),Bu[0]+=.1,Vn(Lu,Bu,o),Pn(_u,Lu,Vu),Bu[0]-=.1,Bu[1]+=.1,Vn(Lu,Bu,o),Pn(Fu,Lu,Vu);for(let e=0;e<3;e++)_u[e]/=.05*u[0],Fu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Vu[0]=c[3*n],Vu[1]=c[3*n+1],Vu[2]=c[3*n+2],a[0]<-.5?On(Bu,_u,a[0]*i-l.width):a[0]>.5?On(Bu,_u,a[0]*i):On(Bu,_u,a[0]*i-l.width/2),wn(Vu,Vu,Bu),On(Bu,Fu,a[1]*i-l.height/2),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,On(Bu,_u,l.width),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,On(Bu,Fu,l.height),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,On(Bu,_u,l.width),Pn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(ku,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Vu[0]=f[3*u],Vu[1]=f[3*u+1],Vu[2]=f[3*u+2],Vn(Bu,Vu,n),Vu[0]=f[3*u+3],Vu[1]=f[3*u+4],Vu[2]=f[3*u+5],Vn(Nu,Vu,n),Pn(Bu,Bu,Nu);const r=[Bu[0],Bu[1]];Qo(r),e.createPolyDataForOneLabel(g[d],u,n,ku,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,ku,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Ns.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}const Wu=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),t.tmPolyData=Cu.newInstance(),t.tmMapper=uc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=bs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),jt.setGet(e,t,["renderable"]),jt.get(e,t,["lastSize","lastAspectRatio","axisTextStyle","tickTextStyle","tmActor","ticks"]),t.forceUpdate=!1,t.lastRedrawTime={},jt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],zu(e,t)}),"vtkCubeAxesActorHelper");function Hu(e,t){t.classHierarchy.push("vtkCubeAxesActor"),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=Wi.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Vu[s]=t.dataBounds[a]-.1*r*Ou[a][s],Vu[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Vu[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),Vn(Bu,Vu,e),Vu[s]=t.dataBounds[a],Vn(Nu,Vu,e),Pn(Bu,Nu,Bu),Mn(Bu,Bu),i=Bu[2]>o,t.camera.getParallelProjection()||(Mn(Nu,Nu),i=En(Nu,Bu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Du[t][0]].length+2*r[Du[t][1]].length,a+=r[Du[t][0]].length+r[Du[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=Mu[e][0],l[3*u+2]=Mu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Du[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][0]]=o[r],s[3*c+Du[n][1]]=t.dataBounds[2*Du[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][0]]=o[r],s[3*c+Du[n][1]]=t.dataBounds[2*Du[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Du[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][1]]=o[r],s[3*c+Du[n][0]]=t.dataBounds[2*Du[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][1]]=o[r],s[3*c+Du[n][0]]=t.dataBounds[2*Du[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Eu[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=Ru[a][e];if(1===n[d]){const e=Eu[d],n=3*Mu[d][0],p=3*Mu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Du[a][0]]=.5*(t.dataBounds[2*Du[a][0]]+t.dataBounds[2*Du[a][0]+1]),s[3*l+Du[a][1]]=.5*(t.dataBounds[2*Du[a][1]]+t.dataBounds[2*Du[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[Ru[e][t]]++;const a=t.generateTicks(t.dataBounds);e.updatePolyData(r,n,a.ticks),e.updateTextData(r,n,a.ticks,a.tickStrings),(o||t.forceUpdate)&&e.updateTextureAtlas(a.tickStrings)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Gu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Gu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=_o(n),r=_o(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Gu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),Wi.setBounds(t.bounds,t.gridActor.getBounds()),Wi.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=jt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}function ju(e,t,n){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...Wi.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,tickLabelPixelOffset:12,generateTicks:Uu,...n,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif",...n?.axisTextStyle},tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif",...n?.tickTextStyle}}}function Ku(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};bs.extend(e,t,ju(0,0,n)),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=["X-Axis","Y-Axis","Z-Axis"],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.tmTexture=Pu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=uc.newInstance(),t.polyData=Cu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=bs.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=Cu.newInstance(),jt.setGet(e,t,["axisTitlePixelOffset","boundsScaleFactor","faceVisibilityAngle","gridLines","tickLabelPixelOffset","generateTicks"]),jt.setGetArray(e,t,["dataBounds"],6),jt.setGetArray(e,t,["axisLabels"],3),jt.get(e,t,["axisTextStyle","tickTextStyle","camera","tmTexture","textValues","textPolyData","tickCounts","gridActor"]),Hu(e,t)}var $u={newInstance:jt.newInstance(Ku,"vtkCubeAxesActor"),extend:Ku,newCubeAxesActorHelper:Wu,defaultGenerateTicks:Uu};function qu(e,t){t.classHierarchy.push("vtkOpenGLCubeAxesActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Xu={};const Yu=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xu,n),Zt.extend(e,t,n),t.CubeAxesActorHelper=$u.newCubeAxesActorHelper(),qu(e,t)}),"vtkOpenGLCubeAxesActor");rn("vtkCubeAxesActor",Yu);const Zu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var Qu={ObjectType:Zu};const{ObjectType:Ju}=Qu;function ed(e,t){function n(e){switch(e){case Ju.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case Ju.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in t.context)return t.context.TEXTURE_BUFFER;case Ju.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push("vtkOpenGLBufferObject");let r=null,o=null,a=!0,i="";e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i="Trying to upload array buffer to incompatible buffer.",!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}const td={objectType:Ju.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function nd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,td,n),jt.obj(e,t),jt.get(e,t,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),ed(e,t)}var rd={newInstance:jt.newInstance(nd),extend:nd,...Qu};const{vtkErrorMacro:od}=jt;function ad(e,t){t.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),e.setType(Zu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=rd.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,y=0,T=0;const b={anythingToPoints(e,t,n,r){for(let o=0;o<e;++o)f(t[n+o],r)},linesToWireframe(e,t,n,r){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r)},polysToWireframe(e,t,n,r){if(e>2)for(let o=0;o<e;++o)f(t[n+o],r),f(t[n+(o+1)%e],r)},stripsToWireframe(e,t,n,r){if(e>2){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r);for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+2],r)}},polysToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+0],r),f(t[n+o+1],r),f(t[n+o+2],r)},stripsToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+1+o%2],r),f(t[n+o+1+(o+1)%2],r)}},x={anythingToPoints:(e,t)=>e,linesToWireframe:(e,t)=>e>1?2*(e-1):0,polysToWireframe:(e,t)=>e>2?2*e:0,stripsToWireframe:(e,t)=>e>2?4*e-6:0,polysToSurface:(e,t)=>e>2?3*(e-2):0,stripsToSurface:(e,t,n)=>e>2?3*(e-2):0};let C=null,S=null;o===ss.POINTS||"verts"===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===ss.WIREFRAME||"lines"===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let P=null;const O=new Float32Array(w*t.blockSize);u&&(P=new Uint8Array(4*w));let R=0,M=0,E=0,D=0;for(let e=0;e<3;++e){const t=a.points.getRange(e),n=t[1]-t[0];E+=n*n;const r=.5*(t[1]+t[0]);D+=r*r}const V=E>0&&(Math.abs(D)/E>1e6||Math.abs(Math.log10(E))>3||0===E&&D>1e6);if(V){const t=new Float64Array(3),n=new Float64Array(3);for(let e=0;e<3;++e){const r=a.points.getRange(e),o=r[1]-r[0];t[e]=.5*(r[1]+r[0]),n[e]=o>0?1/o:1}e.setCoordShiftAndScale(t,n)}else!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null);if(i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e,n){if(i&&(i.points[L]=e,i.cells[L]=T+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(O[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],O[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],O[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(O[R++]=s[g++],O[R++]=s[g++],O[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(T+a.cellOffset):3*e,O[R++]=l[m++],O[R++]=l[m++],O[R++]=l[m++]),t.customData.forEach((t=>{y=e*t.components;for(let e=0;e<t.components;++e)O[R++]=t.data[y++]})),null!==c){h=a.useTCoordsPerCell?n*p:e*p;for(let e=0;e<p;++e)O[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(T+a.cellOffset)*d:e*d,P[M++]=u[v++],P[M++]=u[v++],P[M++]=u[v++],P[M++]=4===d?u[v++]:255)};for(let e=0;e<I;e+=A[e]+1,T++)C(A[e],A,e+1,T+a.cellOffset);return t.elementCount=w,e.upload(O,Zu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(P,Zu.ARRAY_BUFFER)),T},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Nn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Nn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Bn(e,[0,0,0])&&Bn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Rn(n,t);const r=new Float64Array(16);return _(r,ji(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):od("Wrong type for coordScale, expected vec3 or null"):od("Wrong type for coordShift, expected vec3 or null")}}const id={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function sd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,id,n),rd.extend(e,t,n),jt.setGet(e,t,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),jt.get(e,t,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),ad(e,t)}var ld={newInstance:jt.newInstance(sd),extend:sd};const{vtkErrorMacro:cd}=jt;function ud(e,t){t.classHierarchy.push("vtkShader"),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||"Unknown"===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e="Fragment"===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return cd(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}const dd={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function pd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dd,n),jt.obj(e,t),jt.setGet(e,t,["shaderType","source","error","handle","context"]),ud(e,t)}var fd={newInstance:jt.newInstance(pd,"vtkShader"),extend:pd};const{vtkErrorMacro:gd}=jt;function md(e,t){t.classHierarchy.push("vtkShaderProgram"),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(gd(`Links failed: ${t.error}`),0):(gd(t.error),0):(gd(t.fragmentShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),gd(t.fragmentShader.getError()),0):(gd(t.vertexShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),gd(t.vertexShader.getError()),0),e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error="Program has not been initialized, and/or does not have shaders.",!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return gd(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(gd("attempt to find uniform when the shader program is not linked"),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return gd("attempt to find uniform when the shader program is not linked"),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error="Shader object was not initialized, cannot attach it.",!1;if("Unknown"===n.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error="Could not create shader program.",!1;t.handle=e,t.linked=!1}return"Vertex"===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),"Fragment"===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error="shader object was not initialized, cannot attach it.",!1;if("Unknown"===e.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;switch(0===t.handle&&(t.error="This shader program has not been initialized yet."),e.getShaderType()){case"Vertex":return t.vertexShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case"Fragment":return t.fragmentShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}const hd={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function vd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hd,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=fd.newInstance(),t.vertexShader.setShaderType("Vertex"),t.fragmentShader=fd.newInstance(),t.fragmentShader.setShaderType("Fragment"),t.geometryShader=fd.newInstance(),t.geometryShader.setShaderType("Geometry"),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),md(e,t)}var yd={newInstance:jt.newInstance(vd,"vtkShaderProgram"),extend:vd,substitute:function(e,t,n,r){const o="string"==typeof n?n:n.join("\n"),a=!1===r?t:new RegExp(t,"g"),i=e.replace(a,o);return{replace:i!==o,result:i}}};function Td(e,t){t.classHierarchy.push("vtkOpenGLVertexArrayObject"),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension("ANGLE_instanced_arrays")),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension("OES_vertex_array_object"),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==Zu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const bd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function xd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bd,n),t.buffers=[],jt.obj(e,t),jt.get(e,t,["supported"]),jt.setGet(e,t,["forceEmulation"]),Td(e,t)}var Cd={newInstance:jt.newInstance(xd,"vtkOpenGLVertexArrayObject"),extend:xd};const Sd={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function Ad(e,t){t.classHierarchy.push("vtkOpenGLHelper"),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===ss.POINTS||n===Sd.Points?t.context.POINTS:e===ss.WIREFRAME||n===Sd.Lines||n===Sd.TrisEdges||n===Sd.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f("viewportSize",o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf("lineWidthStepSize",t/Math.ceil(t)),e.getProgram().setUniformf("halfLineWidth",n)}t.primitiveType===Sd.Points||r.getProperty().getRepresentation()===ss.POINTS?e.getProgram().setUniformf("pointSize",r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf("pointSize",e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=yd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=yd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===Sd.Points?2:t.primitiveType===Sd.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}const Id={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function wd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Id,n),jt.obj(e,t),t.shaderSourceTime={},jt.obj(t.shaderSourceTime),t.attributeUpdateTime={},jt.obj(t.attributeUpdateTime),jt.setGet(e,t,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),t.program=yd.newInstance(),t.VAO=Cd.newInstance(),t.CABO=ld.newInstance(),Ad(e,t)}var Pd={newInstance:jt.newInstance(wd),extend:wd,primTypes:Sd};const Od={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},Rd={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var Md={Wrap:Od,Filter:Rd};const Ed=new Float32Array(1),Dd=new Int32Array(Ed.buffer);var Vd={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Ed[0]=e;const t=Dd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};let Ld;const{Wrap:Bd,Filter:Nd}=Md,{VtkDataTypes:_d}=Ns,{vtkDebugMacro:Fd,vtkErrorMacro:kd,vtkWarningMacro:Gd}=Kt,{toHalf:Ud}=Vd;function zd(e,t){t.classHierarchy.push("vtkOpenGLTexture"),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(Nd.LINEAR),e.setMagnificationFilter(Nd.LINEAR)):(e.setMinificationFilter(Nd.NEAREST),e.setMagnificationFilter(Nd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Bd.REPEAT),e.setWrapS(Bd.REPEAT),e.setWrapT(Bd.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw(n.width,n.height,4,_d.UNSIGNED_CHAR,n,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw(n.width,n.height,4,_d.UNSIGNED_CHAR,n.data,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),a):e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()};const n=()=>{if(t.minificationFilter!==Nd.LINEAR&&t.magnificationFilter!==Nd.LINEAR||(void 0===Ld&&(Ld=function(){try{const e=4,t=2,n=1,r=new Int16Array([0,32767]),o=[1,1],a=document.createElement("canvas");a.width=e,a.height=e;const i=a.getContext("webgl2");if(!i)return!1;const s=i.getExtension("EXT_texture_norm16");if(!s)return!1;const l=`#version 300 es\n    void main() {\n      gl_PointSize = ${e.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `,c="#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    ",u=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(u,l),i.compileShader(u),!i.getShaderParameter(u,i.COMPILE_STATUS))return!1;const d=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(d,c),i.compileShader(d),!i.getShaderParameter(d,i.COMPILE_STATUS))return!1;const p=i.createProgram();if(i.attachShader(p,u),i.attachShader(p,d),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return!1;const f=i.createTexture();i.bindTexture(i.TEXTURE_2D,f),i.texImage2D(i.TEXTURE_2D,0,s.R16_SNORM_EXT,t,n,0,i.RED,i.SHORT,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.useProgram(p),i.drawArrays(i.POINTS,0,1);const g=new Uint8Array(4);i.readPixels(o[0],o[1],1,1,i.RGBA,i.UNSIGNED_BYTE,g);const[m,h,v]=g,y=i.getExtension("WEBGL_lose_context");return y&&y.loseContext(),m===h&&h===v&&0!==m}catch(e){return!1}}()),Ld))return t.oglNorm16Ext};function r(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Fo(r)||!Fo(o))){const i=t.context.getExtension("OES_texture_half_float"),s=_o(r),l=_o(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Vd.toHalf(Vd.fromHalf(e[u][l+s+t])*h*(1-v)+Vd.fromHalf(e[u][l+p+t])*h*v+Vd.fromHalf(e[u][c+s+t])*m*(1-v)+Vd.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function o(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&n())||e!==_d.UNSIGNED_SHORT&&e!==_d.SHORT)))}function a(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);const i=function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a;let s=!1;if(t._openGLRenderWindow.getWebgl2())s=t.openGLDataType===t.context.FLOAT&&null===t.context.getExtension("OES_texture_float_linear")&&i||t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");s=e&&t.openGLDataType===e.HALF_FLOAT_OES}t.canUseHalfFloat=s&&i}(a,c.offset,c.scale,r),e.useHalfFloat()||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Gd("impossible case"),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Fd(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension("OES_texture_float_linear")&&Gd("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),t.internalFormat),e.getDefaultInternalFormat=(r,o)=>{let a=0;return a=t._openGLRenderWindow.getDefaultTextureInternalFormat(r,o,n(),e.useHalfFloat()),a||(a||(Fd("Unsupported internal texture type!"),Fd(`Unable to find suitable internal format for T=${r} NC= ${o}`)),a)},e.useHalfFloat=()=>t.enableUseHalfFloat&&t.canUseHalfFloat,e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=r=>{const o=e.useHalfFloat();if(t._openGLRenderWindow.getWebgl2())switch(r){case _d.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case n()&&!o&&_d.SHORT:return t.context.SHORT;case n()&&!o&&_d.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case o&&_d.SHORT:case o&&_d.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case _d.FLOAT:case _d.VOID:default:return t.context.FLOAT}switch(r){case _d.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case _d.FLOAT:case _d.VOID:default:if(t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))return t.context.FLOAT;{const e=t.context.getExtension("OES_texture_half_float");if(e&&t.context.getExtension("OES_texture_half_float_linear"))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case Nd.NEAREST:return t.context.NEAREST;case Nd.LINEAR:return t.context.LINEAR;case Nd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case Nd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case Nd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case Nd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Bd.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Bd.REPEAT:return t.context.REPEAT;case Bd.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.updateArrayDataTypeForGL=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=[];let a=t.width*t.height*t.components;if(r&&(a*=t.depth),e!==_d.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Float32Array(t))}else o.push(null);if(e!==_d.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Uint8Array(t))}else o.push(null);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");i=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(i)for(let e=0;e<n.length;e++)if(n[e]){const t=new Uint16Array(a),r=n[e];for(let e=0;e<a;e++)t[e]=Ud(r[e]);o.push(t)}else o.push(null);if(0===o.length)for(let e=0;e<n.length;e++)o.push(n[e]);return o},e.create2DFromRaw=function(a,i,s,l,c){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e.getOpenGLDataType(l,!0),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=e.updateArrayDataTypeForGL(l,d),f=r(p);return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=f[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,f[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,f[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,n(),e.useHalfFloat()),e.deactivate(),!0},e.createCubeFromRaw=(a,i,s,l,c)=>{if(e.getOpenGLDataType(l),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=r(e.updateArrayDataTypeForGL(l,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(l,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,a=t.height;for(;r>=1&&a>=1;){let i=null;n<=t.maxLevel&&(i=d[6*n+e]),o(l)?null!=i&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,a,t.format,t.openGLDataType,i):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,a,0,t.format,t.openGLDataType,i),n++,r/=2,a/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,n(),e.useHalfFloat()),e.deactivate(),!0},e.createDepthFromRaw=(r,a,i,s)=>(e.getOpenGLDataType(i),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?i===_d.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=r,t.height=a,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(i)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=s&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,s)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,s),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(i,n(),e.useHalfFloat()),e.deactivate(),!0):(kd("Failed to determine texture parameters."),!1)),e.create2DFromImage=r=>{if(e.getOpenGLDataType(_d.UNSIGNED_CHAR),e.getInternalFormat(_d.UNSIGNED_CHAR,4),e.getFormat(_d.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1);const a=!(t._openGLRenderWindow.getWebgl2()||Fo(r.width)&&Fo(r.height)),i=document.createElement("canvas");i.width=a?_o(r.width):r.width,i.height=a?_o(r.height):r.height,t.width=i.width,t.height=i.height;const s=i.getContext("2d");s.translate(0,i.height),s.scale(1,-1),s.drawImage(r,0,0,r.width,r.height,0,0,i.width,i.height);const l=i;return o(_d.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=l&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,l)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,l),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(_d.UNSIGNED_CHAR,n(),e.useHalfFloat()),e.deactivate(),!0},e.create2DFilterableFromRaw=function(t,n,r,o,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return e.create2DFilterableFromDataArray(t,n,Ns.newInstance({numberOfComponents:r,dataType:o,values:a}),i)},e.create2DFilterableFromDataArray=function(t,n,r){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{numComps:i,dataType:s,data:l}=a(r,o);e.create2DFromRaw(t,n,i,s,l)},e.updateVolumeInfoForGL=(r,o)=>{let a=!1;const i=e.useHalfFloat();t.volumeInfo?.scale&&t.volumeInfo?.offset||(t.volumeInfo={scale:new Array(o),offset:new Array(o)});for(let e=0;e<o;++e)t.volumeInfo.scale[e]=1,t.volumeInfo.offset[e]=0;if(n()&&!i&&r===_d.SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=32767;a=!0}if(n()&&!i&&r===_d.UNSIGNED_SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=65535;a=!0}if(r===_d.UNSIGNED_CHAR){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=255;a=!0}return(r===_d.FLOAT||i&&(r===_d.SHORT||r===_d.UNSIGNED_SHORT))&&(a=!0),a},e.create3DFromRaw=(a,i,s,l,c,u)=>{let d=c,p=u;if(!e.updateVolumeInfoForGL(d,l)&&p){const e=a*i*s,n=structuredClone(t.volumeInfo),r=new Float32Array(e*l);t.volumeInfo.offset=n.offset,t.volumeInfo.scale=n.scale;let o=0;const c=n.scale.map((e=>1/e));for(let t=0;t<e;t++)for(let e=0;e<l;e++)r[o]=(p[o]-n.offset[e])*c[e],o++;d=_d.FLOAT,p=r}if(e.getOpenGLDataType(d),e.getInternalFormat(d,l),e.getFormat(d,l),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_3D,t.components=l,t.width=a,t.height=i,t.depth=s,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const f=[p],g=r(e.updateArrayDataTypeForGL(d,f,!0));return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(d)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=g[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,g[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,g[0]),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(d,n(),e.useHalfFloat()),e.deactivate(),!0},e.create3DFilterableFromRaw=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return e.create3DFilterableFromDataArray(t,n,r,Ns.newInstance({numberOfComponents:o,dataType:a,values:i}),s)},e.create3DFilterableFromDataArray=function(n,r,i,s){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{numComps:c,dataType:u,data:d,scaleOffsets:p}=a(s,l),f=[],g=[];for(let e=0;e<c;++e)f[e]=0,g[e]=1;if(t.volumeInfo={scale:g,offset:f,dataComputedScale:p.scale,dataComputedOffset:p.offset,width:n,height:r,depth:i},t._openGLRenderWindow.getWebgl2())return e.create3DFromRaw(n,r,i,c,u,d);const m=n*r*i,h=structuredClone(p);let v=(e,t,n,r,o)=>{e[t]=n},y=_d.UNSIGNED_CHAR;if(u===_d.UNSIGNED_CHAR)for(let e=0;e<c;++e)h.offset[e]=0,h.scale[e]=255;else t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear")?(y=_d.FLOAT,v=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=_d.UNSIGNED_CHAR,v=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,c),e.getFormat(y,c),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=c,t.depth=1,t.numberOfDimensions=2;let T=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);T>4096&&(y===_d.FLOAT||c>=3)&&(T=4096);let b=1,x=1;m>T*T&&(b=Math.ceil(Math.sqrt(m/(T*T))),x=b);let C=Math.sqrt(m)/b;C=_o(C);const S=Math.floor(C*b/n),A=Math.ceil(i/S),I=_o(r*A/x);let w;t.width=C,t.height=I,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=S,t.volumeInfo.yreps=A,t.volumeInfo.xstride=b,t.volumeInfo.ystride=x,t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;const P=C*I*c;w=y===_d.FLOAT?new Float32Array(P):new Uint8Array(P);let O=0;const R=Math.floor(n/b),M=Math.floor(r/x);for(let e=0;e<A;e++){const o=Math.min(S,i-e*S),a=c*(t.width-o*Math.floor(n/b));for(let t=0;t<M;t++){for(let a=0;a<o;a++){const o=c*((e*S+a)*n*r+x*t*n);for(let e=0;e<R;e++)for(let t=0;t<c;t++)v(w,O,d[o+b*e*c+t],h.offset[t],h.scale[t]),O++}O+=a}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=w&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,w)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,w),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1,e.enableUseHalfFloat=e=>{t.enableUseHalfFloat=e}}const Wd={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Bd.CLAMP_TO_EDGE,wrapT:Bd.CLAMP_TO_EDGE,wrapR:Bd.CLAMP_TO_EDGE,minificationFilter:Nd.NEAREST,magnificationFilter:Nd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function Hd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wd,n),Zt.extend(e,t,n),t.sendParametersTime={},yt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},yt(t.textureBuildTime,{mtime:0}),St(e,t,["format","openGLDataType"]),At(e,t,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),bt(e,t,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),Ot(0,t,["openGLRenderWindow"]),zd(e,t)}const jd=Dt(Hd,"vtkOpenGLTexture");var Kd={newInstance:jd,extend:Hd,...Md};rn("vtkTexture",jd);var $d="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n",qd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",Xd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=yd.substitute(e,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,t.context.getExtension("EXT_frag_depth")&&(0!==a.factor?(e=yd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=yd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),n.Fragment=e}}},Yd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=yd.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&""!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&""!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Zd}=ll,{primTypes:Qd}=Pd,{Representation:Jd,Shading:ep}=ms,{ScalarMode:tp}=uc,{Filter:np,Wrap:rp}=Kd,{vtkErrorMacro:op}=Kt,ap={type:"StartEvent"},ip={type:"EndEvent"},{CoordinateSystem:sp}=ts;function lp(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push("vtkOpenGLPolyDataMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType("vtkOpenGLActor"),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=Qd.Start;e<Qd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName("lastLightComplexity");let l=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];s&&(l=l.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let c=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];s&&(c=c.concat(["  vec3 specularColor;","  float specularPower;"])),c=c.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),s&&(c=c.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat(["varying vec4 vertexColorVSOutput;"]),o=yd.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=yd.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=yd.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=yd.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?(t.renderable.getAreScalarsMappedFromCells()||t.renderable.getInterpolateScalarsBeforeMapping())&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=yd.substitute(i,"//VTK::Color::Impl",c.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),s?(l=l.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat(["uniform samplerBuffer texture1;"])),i=yd.substitute(i,"//VTK::Color::Impl",c).result):i=yd.substitute(i,"//VTK::Color::Impl",c.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result,i=yd.substitute(i,"//VTK::Color::Dec",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity"),i=t.lastBoundBO.getReferenceByName("lastLightCount");let s=[];switch(a){case 0:o=yd.substitute(o,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:o=yd.substitute(o,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=yd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=yd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=yd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let e=0;e<i;++e)s=s.concat(["  attenuation = 1.0;",`  if (lightPositional${e} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${e};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${e} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${e})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df) * lightColor${e});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${e},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=yd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;default:op("bad light complexity")}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=yd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,o=yd.substitute(o,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,o=yd.substitute(o,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,a=yd.substitute(a,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.haveCellNormals?(a=yd.substitute(a,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=yd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(a=yd.substitute(a,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,a=yd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(o=yd.substitute(o,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,o=yd.substitute(o,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,o=yd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(o=yd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,o=yd.substitute(o,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=yd.substitute(n,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=yd.substitute(n,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=yd.substitute(o,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,a&&a.length>=1)switch(i){case 1:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(n=yd.substitute(n,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=yd.substitute(o,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,i){case 1:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=yd.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,a=yd.substitute(a,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset||o.getEdgeVisibility()&&o.getRepresentation()===Jd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===Qd.Points||o.getRepresentation()===Jd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===Qd.Lines||o.getRepresentation()===Jd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==Qd.Tris&&e!==Qd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==Qd.TrisEdges&&e!==Qd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=yd.substitute(o,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==$l.ID_LOW24&&t.lastSelectionState!==$l.ID_HIGH24||(a=yd.substitute(a,"//VTK::Picking::Dec",["flat out int vertexIDVSOutput;\n","uniform int VertexIDOffset;\n"]).result,a=yd.substitute(a,"//VTK::Picking::Impl","  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result,o=yd.substitute(o,"//VTK::Picking::Dec","flat in int vertexIDVSOutput;\n").result,o=yd.substitute(o,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),t.lastSelectionState){case $l.ID_LOW24:o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case $l.ID_HIGH24:o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;break;default:o=yd.substitute(o,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=yd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=yd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===ep.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName("lastLightComplexity"),h=t.lastBoundBO.getReferenceByName("lastLightCount");return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||op("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||op("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||op(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||op("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||op("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),T(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",r)}t.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],qo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],qo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);Vn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===sp.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,T(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix("MCPCMatrix",t.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf("opacityUniform",i),o.setUniform3fArray("ambientColorUniform",s),o.setUniform3fArray("diffuseColorUniform",l),o.setUniformf("ambient",c),o.setUniformf("diffuse",u);const f=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray("specularColorUniform",g),o.setUniformf("specularPowerUniform",p),o.setUniformf("specular",d),o.isUniformUsed("ambientIntensityBF")){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf("ambientIntensityBF",c),o.setUniformf("diffuseIntensityBF",u),o.setUniformf("opacityUniformBF",i),o.setUniform3fArray("ambientColorUniformBF",s),o.setUniform3fArray("diffuseColorUniformBF",l),f<1)return;o.setUniformf("specularIntensityBF",d),o.setUniform3fArray("specularColorUniformBF",g),o.setUniformf("specularPowerUniformBF",p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():$l.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Jd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===$l.ID_LOW24||t.lastSelectionState===$l.ID_HIGH24);for(let i=Qd.Start;i<Qd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===Qd.TrisEdges||i===Qd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(ap),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(ip),!t.currentInput)return void op("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n),e.updateMaximumPointCellIds()},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==tp.USE_CELL_DATA&&a!==tp.USE_CELL_FIELD_DATA&&a!==tp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===tp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));let i=n.getProperty().getInterpolation()!==ep.FLAT?r.getPointData().getNormals():null;null===i&&r.getCellData().getNormals()&&(t.haveCellNormals=!0,i=r.getCellData().getNormals());const s=n.getProperty().getRepresentation();let l=r.getPointData().getTCoords();t.openGLActor.getActiveTextures()||(l=null);let c=!1;if(t.renderable.getColorCoordinates()){l=t.renderable.getColorCoordinates(),c=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=Kd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(np.NEAREST),e.setMagnificationFilter(np.NEAREST),e.setWrapS(rp.CLAMP_TO_EDGE),e.setWrapT(rp.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),e.deactivate()}const u=`${r.getMTime()}A${s}B${r.getMTime()}C${i?i.getMTime():1}D${o?o.getMTime():1}E${n.getProperty().getEdgeVisibility()}F${l?l.getMTime():1}`;if(t.VBOBuildString!==u){const e={points:r.getPoints(),normals:i,tcoords:l,colors:o,cellOffset:0,vertexOffset:0,useTCoordsPerCell:c,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const a=[{inRep:"verts",cells:r.getVerts()},{inRep:"lines",cells:r.getLines()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()}],d=n.getProperty().getEdgeVisibility()&&s===Jd.SURFACE;for(let n=Qd.Start;n<Qd.End;n++)n!==Qd.TrisEdges&&n!==Qd.TriStripsEdges?(e.cellOffset+=t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,s,e,t.selectionWebGLIdsToVTKIds),e.vertexOffset+=t.primitives[n].getCABO().getElementCount()):d?t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,Jd.WIREFRAME,{...e,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[n].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),t.VBOBuildString=u}t.VBOBuildTime.modified()},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const cp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:$l.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cp,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.primitives=[],t.primTypes=Qd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=Qd.Start;e<Qd.End;e++)t.primitives[e]=Pd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},yt(t.selectionStateChanged,{mtime:0}),lp(e,t)}const dp=Dt(up,"vtkOpenGLPolyDataMapper");var pp={newInstance:dp,extend:up};rn("vtkMapper",dp);const{ColorMode:fp,ScalarMode:gp,GetArray:mp}=bl;function hp(e,t){t.classHierarchy.push("vtkMapper2D"),e.createDefaultLookupTable=()=>{t.lookupTable=Nl.newInstance()},e.getColorModeAsString=()=>jt.enumToString(fp,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(gp,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===gp.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===gp.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===gp.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===gp.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===gp.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===gp.USE_FIELD_DATA){const t=e.getFieldData();i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}const vp={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function yp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vp,n),ks(e,t,n),jt.get(e,t,["colorMapColors"]),jt.setGet(e,t,["arrayAccessMode","colorByArrayName","colorMode","lookupTable","renderTime","scalarMode","scalarVisibility","static","transformCoordinate","useLookupTableScalarRange","viewSpecificProperties","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),hp(e,t)}var Tp={newInstance:jt.newInstance(yp,"vtkMapper2D"),extend:yp};const bp=1,{primTypes:xp}=Pd,{ScalarMode:Cp}=Tp,{vtkErrorMacro:Sp}=Kt,Ap={type:"StartEvent"},Ip={type:"EndEvent"};function wp(e,t){t.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType("vtkOpenGLActor2D"),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n",e.Geometry=""},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=xp.Start;e<xp.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(Ap),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Ip),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Sp("No input!")},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==Cp.USE_CELL_DATA&&a!==Cp.USE_CELL_FIELD_DATA&&a!==Cp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===Cp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=Sc.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[xp.Points].getCABO().createVBO(r.getVerts(),"verts",i,a),a.cellOffset+=t.primitives[xp.Lines].getCABO().createVBO(r.getLines(),"lines",i,a),a.cellOffset+=t.primitives[xp.Tris].getCABO().createVBO(r.getPolys(),"polys",i,a),a.cellOffset+=t.primitives[xp.TriStrips].getCABO().createVBO(r.getStrips(),"strips",i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=xp.Start;a<xp.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=yd.substitute(i,"//VTK::Color::Dec",["uniform samplerBuffer texture1;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);"]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=yd.substitute(o,"//VTK::Color::Dec",["in vec4 diffuseColor;","out vec4 fcolorVSOutput;"]).result,o=yd.substitute(o,"//VTK::Color::Impl",["fcolorVSOutput = diffuseColor;"]).result,a=yd.substitute(a,"//VTK::Color::Dec",["in vec4 fcolorVSOutput[];\n","out vec4 fcolorGSOutput;"]).result,a=yd.substitute(a,"//VTK::Color::Impl",["fcolorGSOutput = fcolorVSOutput[i];"]).result,i=yd.substitute(i,"//VTK::Color::Dec",["in vec4 fcolorVSOutput;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = fcolorVSOutput;"]).result):(i=yd.substitute(i,"//VTK::Color::Dec",["uniform vec4 diffuseColor;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = diffuseColor;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=yd.substitute(n,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput[];\n","out float tcoordVCGSOutput;"]).result,r=yd.substitute(r,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=yd.substitute(o,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):2===a&&(n=yd.substitute(n,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];\n","out vec2 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=yd.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),t.haveCellScalars&&(r=yd.substitute(r,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=yd.substitute(r,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,r=yd.substitute(r,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed("PrimitiveIDOffset")&&e.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),e.getProgram().isAttributeUsed("vertexWC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"vertexWC",e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||Sp("Error setting vertexWC in shader VAO.")),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||Sp(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed("tcoordMC")&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"tcoordMC",e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||Sp("Error setting tcoordMC in shader VAO."):e.getVAO().removeAttributeArray("tcoordMC"),t.internalColorTexture&&e.getProgram().isUniformUsed("texture1")&&e.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray("mapperIndex",a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi("picking",a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f("diffuseColor",i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=Mo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=Mo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=Mo(c[0]-(d[0]-l[0])*p[0]),h=Mo(c[1]-(d[1]-l[1])*p[1]),v=-f;let y=-f+s[0];const T=-h;let b=-h+s[1];v===y&&(y=v+1),T===b&&(b=T+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(y-v),x[5]=2/(b-T),x[3]=-1*(y+v)/(y-v),x[7]=-1*(b+T)/(b-T),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===bp?-1:1,x[15]=1,m(x,x),a.setUniformMatrix("WCVCMatrix",(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const Pp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const Op=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pp,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.primitives=[],t.primTypes=xp,t.tmpMat4=g(new Float64Array(16));for(let e=xp.Start;e<xp.End;e++)t.primitives[e]=Pd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),wp(e,t)}),"vtkOpenGLPolyDataMapper2D");rn("vtkMapper2D",Op);const{VectorMode:Rp}=El;function Mp(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Ep(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Dp(e,t){return e=>{const t=e.getLastTickBounds(),n=go().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}function Vp(e,t){t.classHierarchy.push("vtkScalarBarActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left";const n={},r=new Map;let o=0,a=1;Mp(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,Mp(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),"NaN","Below","Above"];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=_o(o),a=_o(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{Mp(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s("NaN",[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s("Below",[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s("ticks",t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s("Above",[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p="vertical"===a?[1,0]:[0,1];"vertical"===a?(d[0]=l.width,d[1]=-l.height,"middle"===o[0]?n[1]-=l.width/2:"right"===o[0]&&(n[1]-=l.width),"middle"===o[1]?n[0]+=l.height/2:"top"===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,"middle"===o[0]?n[0]-=l.width/2:"right"===o[0]&&(n[0]-=l.width),"middle"===o[1]?n[1]-=l.height/2:"top"===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?["right","middle"]:["middle","bottom"];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","top"],"vertical",[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];"ticks"===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,"horizontal",g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),y=e.getTicks(),T=e.getTickStrings();for(let n=0;n<y.length;n++){const o=(y[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(T[n],r,p,"horizontal",g,c)}const b=Ns.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(b),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Rp.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Ns.newInstance({numberOfComponents:i,values:c,name:"Scalars"});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}const Lp=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),jt.setGet(e,t,["axisTitlePixelOffset","tickLabelPixelOffset","renderable","topTitle","ticks","tickStrings"]),jt.get(e,t,["lastSize","lastAspectRatio","lastTickBounds","axisTextStyle","tickTextStyle","barActor","tmActor"]),jt.getArray(e,t,["boxPosition","boxSize"]),jt.setArray(e,t,["boxPosition","boxSize"],2),t.forceUpdate=!1,t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.barMapper=uc.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=Cu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=bs.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=Cu.newInstance(),t.tmMapper=uc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Pu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=bs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],Vp(e,t)}),"vtkScalarBarActorHelper");function Bp(e,t){t.classHierarchy.push("vtkScalarBarActor"),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(Ep(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Dp())}}function Np(e){return{automated:!0,autoLayout:null,axisLabel:"Scalar Value",barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif"},tickLabelPixelOffset:14,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif"},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}function _p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Np(n)),t.autoLayout||(t.autoLayout=Ep(0,t)),t.generateTicks||(t.generateTicks=Dp()),bs.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),jt.setGet(e,t,["automated","autoLayout","axisTitlePixelOffset","axisLabel","scalarsToColors","tickLabelPixelOffset","generateTicks","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch"]),jt.get(e,t,["axisTextStyle","tickTextStyle"]),jt.getArray(e,t,["barPosition","barSize","boxPosition","boxSize"]),jt.setArray(e,t,["barPosition","barSize","boxPosition","boxSize"],2),Bp(e,t)}var Fp={newInstance:jt.newInstance(_p,"vtkScalarBarActor"),extend:_p,newScalarBarActorHelper:Lp};function kp(e,t){t.classHierarchy.push("vtkOpenGLScalarBarActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Gp={};const Up=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gp,n),Zt.extend(e,t,n),t.scalarBarActorHelper=Fp.newScalarBarActorHelper(),kp(e,t)}),"vtkOpenGLScalarBarActor");rn("vtkScalarBarActor",Up);const{vtkErrorMacro:zp}=Kt;function Wp(e,t){t.classHierarchy.push("vtkOpenGLSkybox"),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi("sbtexture",n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix("IMCPCMatrix",a),"box"===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f("camPos",e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Ns.newInstance({numberOfComponents:3,values:e});n.setName("points");const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Ns.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,"polys",ss.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),"box"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }","")),"background"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }","")),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),"vertexMC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||zp("Error setting vertexMC in shader VAO."));const e=t.renderable.getTextures();e.length||zp("vtkSkybox requires a texture map"),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}const Hp={context:null};const jp=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hp,n),Zt.extend(e,t,n),t.openGLTexture=Kd.newInstance(),t.tris=Pd.newInstance(),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),Wp(e,t)}));rn("vtkSkybox",jp);const{FieldAssociations:Kp}=ll;function $p(e,t){t.classHierarchy.push("vtkHardwareSelector"),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}const qp={fieldAssociation:Kp.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function Xp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qp,n),jt.obj(e,t),jt.setGet(e,t,["fieldAssociation","captureZValues"]),$p(e,t)}var Yp={newInstance:jt.newInstance(Xp,"vtkHardwareSelector"),extend:Xp};function Zp(e,t){t.classHierarchy.push("vtkFramebuffer"),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling saveCurrentBindings");const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling restorePreviousBindings");const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=n;null===r&&(r=t.context.FRAMEBUFFER),t.context.bindFramebuffer(r,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et("you must set the OpenGLRenderWindow before calling create")},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et("you must set the OpenGLRenderWindow before calling setColorBuffer");let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et("you must set the OpenGLRenderWindow before calling removeColorBuffer");let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et("Attaching depth buffer textures to fbo requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling setDepthBuffer")},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et("Attaching depth buffer textures to framebuffers requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling removeDepthBuffer")},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>null==t.glFramebuffer?null:[t.glFramebuffer.width,t.glFramebuffer.height],e.populateFramebuffer=()=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling populateFrameBuffer");e.bind();const n=t.context,r=Kd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(Rd.LINEAR),r.setMagnificationFilter(Rd.LINEAR),r.create2DFromRaw(t.glFramebuffer.width,t.glFramebuffer.height,4,Cs.UNSIGNED_CHAR,null),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}const Qp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Jp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qp,n),yt(e,t),t.colorBuffers&&et("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),t.colorBuffers=[],It(e,t,["colorBuffers"]),Zp(e,t)}var ef={newInstance:Dt(Jp,"vtkFramebuffer"),extend:Jp};function tf(e,t){t.classHierarchy.push("vtkSelectionNode"),e.getBounds=()=>t.points.getBounds()}const nf={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function rf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nf,n),jt.obj(e,t),t.properties={},jt.setGet(e,t,["contentType","fieldType","properties","selectionList"]),tf(e,t)}var of={newInstance:jt.newInstance(rf,"vtkSelectionNode"),extend:rf,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:af}=ql,{SelectionContent:sf,SelectionField:lf}=of,{FieldAssociations:cf}=ll,{vtkErrorMacro:uf}=jt;function df(e){return`${e.propID} ${e.compositeID}`}function pf(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function ff(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function gf(e,t){let n=t;return n<<=24,n|=e,n}function mf(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=ff(n[0],n[1],e.pixBuffer[af.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=ff(n[0],n[1],e.pixBuffer[af.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[af.ID_LOW24]&&0===pf(n[0],n[1],e.pixBuffer[af.ID_LOW24],e.area))return a;const s=ff(n[0],n[1],e.pixBuffer[af.ID_LOW24],e.area),l=ff(n[0],n[1],e.pixBuffer[af.ID_HIGH24],e.area);return a.attributeID=gf(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=mf(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=mf(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=mf(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=mf(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=mf(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function hf(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=of.newInstance();switch(l.setContentType(sf.INDICES),e){case cf.FIELD_ASSOCIATION_CELLS:l.setFieldType(lf.CELL);break;case cf.FIELD_ASSOCIATION_POINTS:l.setFieldType(lf.POINT);break;default:uf("Unknown field association")}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}function vf(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=mf(e,[n,t],0,u);if(r&&r.valid){const t=df(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return hf(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}function yf(e,t){t.classHierarchy.push("vtkOpenGLHardwareSelector"),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e&&e[0]===n[0]&&e[1]===n[1]?t.framebuffer.bind():(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer())}else t.framebuffer=ef.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===cf.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return vf(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return uf("Renderer and view must be set before calling Select."),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:"StartEvent"}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();e.beginSelection();const r=[];for(t.currentPass=af.MIN_KNOWN_PASS;t.currentPass<=af.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===af.ACTOR_PASS&&"function"==typeof n[0].requestDepth&&"function"==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),r.push(t.currentPass));return r.forEach((n=>{t.currentPass=n,e.processPixelBuffers()})),t.currentPass=af.MAX_KNOWN_PASS,e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:"EndEvent"}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===af.ID_HIGH24){if(t.fieldAssociation===cf.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===cf.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===af.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if("function"==typeof e[0].requestDepth&&"function"==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=ff(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===af.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===af.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>jt.enumToString(af,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=ff(e[0],e[1],t.pixBuffer[af.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=ff(e[0],e[1],t.pixBuffer[af.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[af.ID_LOW24]&&0===pf(e[0],e[1],t.pixBuffer[af.ID_LOW24],t.area))return a;const s=ff(e[0],e[1],t.pixBuffer[af.ID_LOW24],t.area),l=ff(e[0],e[1],t.pixBuffer[af.ID_HIGH24],t.area);return a.attributeID=gf(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=df(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return hf(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}const Tf={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),Yp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),jt.setGetArray(e,t,["area"],4),jt.setGet(e,t,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),jt.setGetArray(e,t,["propColorValue"],3),jt.moveToProtected(e,t,["renderer","openGLRenderWindow"]),jt.event(e,t,"event"),yf(e,t)}var xf={newInstance:jt.newInstance(bf,"vtkOpenGLHardwareSelector"),extend:bf,...ql};const{vtkErrorMacro:Cf}=Kt,{Representation:Sf}=ms,{ObjectType:Af}=rd,{PassTypes:If}=xf,wf={type:"StartEvent"},Pf={type:"EndEvent"};function Of(e,t){t.classHierarchy.push("vtkOpenGLGlyph3DMapper");const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(wf),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(Pf),!t.currentInput)return void Cf("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension("ANGLE_instanced_arrays"),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],y=t[14],T=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*y,e[3]=b*s+x*d+C*m+S*T,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*y,e[7]=b*s+x*d+C*m+S*T,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*y,e[11]=b*s+x*d+C*m+S*T,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*y,e[15]=b*s+x*d+C*m+S*T},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=yd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];a&&(i=i.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let s=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];a&&(s=s.concat(["  vec3 specularColor;","  float specularPower;"])),s=s.concat(["  opacity = opacityUniform;"]),a&&(s=s.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),t.drawingEdges||(i=i.concat(["varying vec4 vertexColorVSOutput;"]),n=yd.substitute(n,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,n=yd.substitute(n,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,r=yd.substitute(r,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,r=yd.substitute(r,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,s=s.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),o=yd.substitute(o,"//VTK::Color::Impl",s).result,o=yd.substitute(o,"//VTK::Color::Dec",i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(n=yd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,n=yd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(n=yd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,n=yd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=yd.substitute(n,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,n=yd.substitute(n,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,e.Vertex=n,t=yd.substitute(t,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,t=yd.substitute(t,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],y=n[r+1],T=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+y*d+T*g,o[1]=v*i+y*p+T*m,o[2]=v*c+y*f+T*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3("normalMatrix",t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix("MCPCMatrix",t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix("MCVCMatrix",t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray("ambientColorUniform",t.tmpColor),u.setUniform3fArray("diffuseColorUniform",t.tmpColor)}c&&u.setUniform3fArray("mapperIndex",c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===Sf.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),T(t.mcpcMatrix,s.wcpc,l.mcwc),T(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===If.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed("normalMatrix"),v=g.isUniformUsed("MCVCMatrix");if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed("gMatrix")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,"gMatrix",0,64,t.context.FLOAT,4,!1,1)||Cf("Error setting gMatrix in shader VAO."):e.getVAO().removeAttributeArray("gMatrix"),e.getProgram().isAttributeUsed("gNormal")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,"gNormal",0,36,t.context.FLOAT,3,!1,1)||Cf("Error setting gNormal in shader VAO."):e.getVAO().removeAttributeArray("gNormal"),e.getProgram().isAttributeUsed("gColor")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,"gColor",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Cf("Error setting gColor in shader VAO."):e.getVAO().removeAttributeArray("gColor"),e.getProgram().isAttributeUsed("mapperIndexVS")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,"mapperIndexVS",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Cf("Error setting mapperIndexVS in shader VAO."):e.getVAO().removeAttributeArray("mapperIndexVS"),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=rd.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=rd.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=rd.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=rd.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,Af.ARRAY_BUFFER),t.normalBuffer.upload(n,Af.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),Af.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,Af.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}const Rf={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const Mf=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),pp.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},yt(t.glyphBOBuildTime,{mtime:0}),Of(e,t)}),"vtkOpenGLGlyph3DMapper");rn("vtkGlyph3DMapper",Mf);const{vtkErrorMacro:Ef}=jt;class Df{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}function Vf(e,t){t.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),e.requestData=(e,t)=>{const n=e[0];if(!n)return void Ef("Invalid or missing input");const r=Cu.newInstance();r.shallowCopy(n);const o=new Df,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(vc.newInstance({values:c,name:"faces"})),t[0]=r}}const Lf={};function Bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lf,n),jt.obj(e,t),jt.algo(e,t,1,1),Vf(e,t)}var Nf={newInstance:jt.newInstance(Bf,"vtkClosedPolyLineToSurfaceFilter"),extend:Bf};const{vtkErrorMacro:_f}=Kt;function Ff(e,t){t.classHierarchy.push("vtkCutter");const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void _f("Invalid or missing input");if(!t.cutFunction)return void _f("Missing cut function");const o=Cu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error("Iterator is done");r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const kf={cutFunction:null,cutScalars:null,cutValue:0};function Gf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kf,n),yt(e,t),Rt(e,t,1,1),At(e,t,["cutFunction","cutValue"]),Ff(e,t)}var Uf={newInstance:Dt(Gf,"vtkCutter"),extend:Gf};const zf=e=>e,Wf=1e-6;class Hf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:zf}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);In(n,e[0],e[1],e[2]),In(r,t[0],t[1],t[2]),Mn(n,n),Mn(r,r);const a=En(n,r);return a>=1||(Dn(this.tmp,n,r),Sn(this.tmp)<Wf&&(Dn(this.tmp,[1,0,0],e),Sn(this.tmp)<Wf&&Dn(this.tmp,[0,1,0],e)),O(o,Math.acos(a),this.tmp),T(this.matrix,this.matrix,o)),this}rotate(e,t){return In(this.tmp,...t),Mn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return In(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return In(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return T(this.matrix,this.matrix,e),this}multiply3x3(e){return T(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(aa(vo,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)In(this.tmp,e[n],e[n+1],e[n+2]),Vn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var jf=function(){return new Hf(!0)},Kf=function(){return new Hf(!1)};const $f=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],qf=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function Xf(e,t){t.classHierarchy.push("vtkCubeSource"),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=Cu.newInstance();n[0]=r;const o=jt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=jt.newTypedArray(t.pointType,72),i=Ns.newInstance({name:"Normals",values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=jt.newTypedArray(t.pointType,24*s),c=Ns.newInstance({name:"TextureCoordinates",values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&jf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Kf().translate(...t.center).apply(o),t.matrix){Kf().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Kf().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}const Yf={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yf,n),jt.obj(e,t),jt.setGet(e,t,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),jt.setGetArray(e,t,["center","rotations"],3),jt.setGetArray(e,t,["matrix"],16),t._polys=vc.newInstance({values:Uint16Array.from(qf)}),t._lineCells=vc.newInstance({values:Uint16Array.from($f)}),jt.moveToProtected(e,t,["polys","lineCells"]),jt.algo(e,t,0,1),Xf(e,t)}var Qf={newInstance:jt.newInstance(Zf,"vtkCubeSource"),extend:Zf};const{vtkErrorMacro:Jf}=jt;function eg(e,t){t.classHierarchy.push("vtkImageDataOutlineFilter");const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA("vtkImageData"))return void Jf("Invalid or missing input");const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Jf("Unable to fetch spatial extents of input image.")},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}const tg={};function ng(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tg,n),jt.obj(e,t),jt.algo(e,t,1,1),t._cubeSource=Qf.newInstance(),jt.moveToProtected(e,t,["cubeSource","tmpOut"]),eg(e,t)}var rg={newInstance:jt.newInstance(ng,"vtkImageDataOutlineFilter"),extend:ng};let og;function ag(e,t){t.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),e.transformPoint=(e,n)=>(Vn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],Vn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?T(n,t.matrix,e):T(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>T(o,t.matrix,r):()=>T(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>og({matrix:za.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}const ig={preMultiplyFlag:!1,matrix:[...vo]};function sg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ig,n),jt.obj(e,t),jt.setGet(e,t,["preMultiplyFlag"]),jt.setGetArray(e,t,["matrix"],16),ag(e,t)}og=jt.newInstance(sg,"vtkTransform");var lg={newInstance:og,extend:sg};function cg(e,t,n){return e?`${e.getMTime()}-${t}-${n}`:"0"}function ug(e,t){return`${e.getMTime()}A${t.getMTime()}`}const dg={NEAREST:0,LINEAR:1};var pg={InterpolationType:dg};const{vtkErrorMacro:fg}=Kt;function gg(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}function mg(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageResliceMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(r.getActiveCamera());const o=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),o&&!o.isDeleted()&&o!==t._openGLRenderWindow&&n(o),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),t.currentInput?(e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:"EndEvent"})):fg("No input!")},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===dg.NEAREST?(t.openGLTexture.setMinificationFilter(Rd.NEAREST),t.openGLTexture.setMagnificationFilter(Rd.NEAREST),t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST),t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.openGLTexture.setMinificationFilter(Rd.LINEAR),t.openGLTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()?.getScalars();if(!a)return;const i=a.getNumberOfComponents();let s=ug(o,a);const l=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(l?.oglObject?.getHandle()&&l?.hash===s)t.openGLTexture=l.oglObject;else{t.openGLTexture=Kd.newInstance(),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],a),t._openGLRenderWindow.setGraphicsResourceForObject(a,t.openGLTexture,s),a!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(a,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=a}const c=r.getProperty(),u=c.getIndependentComponents(),d=u?i:1,p=u?2*d:1,f=c.getRGBTransferFunction();s=cg(f,u,d);const g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g?.hash===s)t.colorTexture=g.oglObject;else{const n=1024,r=new Uint8ClampedArray(n*p*3);if(t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),f){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=c.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,p,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,s),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}const m=c.getPiecewiseFunction();s=cg(m,u,d);const h=t._openGLRenderWindow.getGraphicsResourceForObject(m);if(h?.oglObject?.getHandle()&&h?.hash===s)t.pwfTexture=h.oglObject;else{const n=1024,r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),m){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=c.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,p,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);m&&(t._openGLRenderWindow.setGraphicsResourceForObject(m,t.pwfTexture,s),m!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(m,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=m)}const v=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==v){const e=Ns.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName("points");const n=Ns.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:fg("Slab mode requested without normals")}t.tris.getCABO().createVBO(n,"polys",ss.SURFACE,r)}t.VBOBuildString=v,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){a.isUniformUsed("texture1")&&a.setUniformi("texture1",t.openGLTexture.getTextureUnit()),a.isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||fg("Error setting vertexWC in shader VAO.")),a.isAttributeUsed("normalWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"normalWC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||fg("Error setting normalWC in shader VAO.")),a.isUniformUsed("slabThickness")&&a.setUniformf("slabThickness",t.renderable.getSlabThickness()),a.isUniformUsed("spacing")&&a.setUniform3fv("spacing",t.currentInput.getSpacing()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabTrapezoid")&&a.setUniformi("slabTrapezoid",t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed("WCTCMatrix")){const n=t.currentInput,r=n.getDimensions();d(t.tmpMat4,n.getIndexToWorld()),b(t.tmpMat4,t.tmpMat4,[-.5,-.5,-.5]),x(t.tmpMat4,t.tmpMat4,r),h(t.tmpMat4,t.tmpMat4),e&&T(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix("WCTCMatrix",t.tmpMat4)}a.isUniformUsed("vboScaling")&&a.setUniform3fv("vboScaling",n.getCABO().getCoordScale()??[1,1,1]),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed("MCPCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCPCMatrix",gg([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed("MCVCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCVCMatrix",gg([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.openGLTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.openGLTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d),o.setUniform4fv("backgroundColor",t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=t.renderable.getSlabThickness(),s=t.renderable.getSlabType(),l=t.renderable.getSlabTrapezoidIntegration();let c=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(c=!0),!(!c&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a&&t.lastSlabThickness===i&&t.lastSlabType===s&&t.lastSlabTrapezoidIntegration===l||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,t.lastSlabThickness=i,t.lastSlabType=s,t.lastSlabTrapezoidIntegration=l,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=yd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=yd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=yd.substitute(o,"//VTK::TCoord::Dec",["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"]).result;const l=t.openGLTexture.getComponents(),c=r.getProperty().getIndependentComponents();let u=["in vec3 fragTexCoord;","uniform highp sampler3D texture1;","uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:u=u.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:fg("Unsupported number of independent coordinates.")}}s>0&&(u=u.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),u=u.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),i=yd.substitute(i,"//VTK::TCoord::Dec",u).result;let d=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = texture(texture1, fragTexCoord);"];if(s>0&&(d=d.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),c){const e=["r","g","b","a"];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:d=d.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:fg("Unsupported number of independent coordinates.")}}else switch(l){case 1:d=d.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:d=d.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=yd.substitute(i,"//VTK::TCoord::Impl",d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=["attribute vec4 vertexWC;"];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),a=yd.substitute(a,"//VTK::PositionVC::Dec",c).result;let u=["gl_Position = MCPCMatrix * vertexWC;"];l>0&&(u=u.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),a=yd.substitute(a,"//VTK::PositionVC::Impl",u).result,a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let d=[];l>0&&(d=d.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),s=yd.substitute(s,"//VTK::PositionVC::Dec",d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e="";const n=t.currentInput,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`);const t=ie();n&&(e=e.concat(`Image${n.getMTime()}`),de(t,...n.getDirection()),ge(t,t));const r=[...s.getNormal()];Ln(r,r,t),[o,a]=function(e){za.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=za.dot(e,t);if(o<-.999999||o>.999999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ii.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=Cu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getSpatialExtent();let l=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[l+a]=r[a],e[l+o[0]]=i[2*o[0]+n],e[l+o[1]]=i[2*o[1]+t],l+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const c=new Uint16Array(8);c[0]=3,c[1]=0,c[2]=1,c[3]=3,c[4]=3,c[5]=0,c[6]=3,c[7]=2;const u=s.getNormal();za.normalize(u);const d=new Float32Array(12);for(let e=0;e<4;++e)d[3*e]=u[0],d[3*e+1]=u[1],d[3*e+2]=u[2];t.resliceGeom||(t.resliceGeom=Cu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(c,1);const p=Ns.newInstance({numberOfComponents:3,values:d,name:"Normals"});t.resliceGeom.getPointData().setNormals(p)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=Cu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();za.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Ns.newInstance({numberOfComponents:3,values:a,name:"Normals"});t.resliceGeom.getPointData().setNormals(i)}else fg("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setOpenGLTexture=e=>{e&&(t.openGLTexture=e,t._externalOpenGLTexture=!0)},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const hg={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1};const vg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hg,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.tris=Pd.newInstance(),t.openGLTexture=null,t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},yt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=rg.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=Cu.newInstance(),t.cutter=Uf.newInstance(),t.lineToSurfaceFilter=Nf.newInstance(),t.transform=lg.newInstance(),bt(e,t,["openGLTexture"]),mg(e,t)}),"vtkOpenGLImageResliceMapper");rn("vtkImageResliceMapper",vg);var yg={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:Tg}=Kt,{SlicingMode:bg}=yg;function xg(e){const t=e.split("\n"),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}function Cg(e,t){function n(n){t.openGLTexture.releaseGraphicsResources(n),[t._colorTransferFunc,t._pwFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),t.renderable.isA("vtkImageMapper")&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(o.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,a=yd.substitute(a,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,a=yd.substitute(a,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform sampler2D labelOutlineTexture1;","uniform float opacity;","uniform float outlineOpacity;"];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:c=c.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Tg("Unsupported number of independent coordinates.")}}if(i=yd.substitute(i,"//VTK::TCoord::Dec",c).result,!0===o.getProperty().getUseLabelOutline()&&(i=yd.substitute(i,"//VTK::LabelOutline::Dec",["uniform int outlineThickness;","uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;","uniform int sliceAxis;"]).result,i=yd.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,i=yd.substitute(i,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","vec2 getSliceCoords(vec3 coord, int axis) {","  if (axis == 0) return coord.yz;","  if (axis == 1) return coord.xz;","  if (axis == 2) return coord.xy;","}","#endif"]).result),l){const e=["r","g","b","a"];let t=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:t=t.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Tg("Unsupported number of independent coordinates.")}i=yd.substitute(i,"//VTK::TCoord::Impl",t).result}else switch(s){case 1:i=yd.substitute(i,"//VTK::TCoord::Impl",[...xg("\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);\n                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (segmentIndex == 0){\n                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);\n                    return;\n                  }\n\n                  for (int i = -actualThickness; i <= actualThickness; i++) {\n                    for (int j = -actualThickness; j <= actualThickness; j++) {\n                      if (i == 0 || j == 0) {\n                        continue;\n                      }\n                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                        gl_FragCoord.y + float(j),\n                        gl_FragCoord.z, gl_FragCoord.w);\n                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;\n                      if (value != centerValue) {\n                        pixelOnBorder = true;\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      break;\n                    }\n                  }\n                  if (pixelOnBorder == true) {\n                    gl_FragData[0] = vec4(tColor, outlineOpacity);\n                  }\n                  else {\n                    gl_FragData[0] = vec4(tColor, opacityToUse);\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                ")]).result;break;case 2:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6),o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=yd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=yd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Tg("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||Tg("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi("pwfTexture1",u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi("labelOutlineTexture1",p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf("outlineOpacity",e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();T(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(T(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix("MCPCMatrix",t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();let i=t.renderable.getClosestIJKAxis().ijkMode;i===bg.NONE&&(i=bg.K),a.setUniform3i("imageDimensions",o[0],o[1],o[2]),a.setUniformi("sliceAxis",i),a.setUniformMatrix("vWCtoIDX",n);const l=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,l.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const c=e.getRenderTargetSize();a.setUniformf("vpWidth",c[0]),a.setUniformf("vpHeight",c[1]);const u=e.getRenderTargetOffset();a.setUniformf("vpOffsetX",u[0]/c[0]),a.setUniformf("vpOffsetY",u[1]/c[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf("opacity",o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Tg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=l.getRGBTransferFunction(),g=cg(f,u,d),m=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(m?.oglObject?.getHandle()&&m?.hash===g)t.colorTexture=m.oglObject;else{t.colorTexture=Kd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,r=new Uint8ClampedArray(n*p*3);if(c===dg.NEAREST?(t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST)):(t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR)),f){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,p,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,g),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}const h=l.getPiecewiseFunction(),v=cg(h,u,d),y=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(y?.oglObject?.getHandle()&&y?.hash===v)t.pwfTexture=y.oglObject;else{const n=1024,r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),c===dg.NEAREST?(t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR)),h){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=l.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,p,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);h&&(t._openGLRenderWindow.setGraphicsResourceForObject(h,t.pwfTexture,v),h!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(h,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=h)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:T}=t.renderable.getClosestIJKAxis();let b=t.renderable.getSlice();T!==t.renderable.getSlicingMode()&&(b=t.renderable.getSliceAtPosition(b));const x=t.renderable.isA("vtkImageArrayMapper")?t.renderable.getSubSlice():Math.round(b),C=o.getExtent();let S;T===bg.I&&(S=x-C[0]),T===bg.J&&(S=x-C[2]),T!==bg.K&&T!==bg.NONE||(S=x-C[4]);const A=`${b}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==A){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Kd.newInstance({resizable:!0})),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),c===dg.NEAREST?(new Set([1,3,4]).has(s)&&i===Cs.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Rd.NEAREST)):t.openGLTexture.setMinificationFilter(Rd.NEAREST),t.openGLTexture.setMagnificationFilter(Rd.NEAREST)):(4!==s||i!==Cs.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(Rd.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Rd.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(Rd.LINEAR)),t.openGLTexture.setWrapS(Od.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Od.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[bg.X,bg.Y,bg.Z].includes(t.renderable.getSlicingMode())?b:x,p=o.getSpatialExtent(),f=a.getData();let g=null;if(T===bg.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(S+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(T===bg.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+S*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else T===bg.K||T===bg.NONE?(g=f.subarray(S*n,(S+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):Tg("Reformat slicing not yet supported.");t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw(e[0],e[1],s,a.getDataType(),g,t.renderable.getPreferSizeOverAccuracy?.()),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const m=Ns.newInstance({numberOfComponents:3,values:r});m.setName("points");const h=Ns.newInstance({numberOfComponents:2,values:l});h.setName("tcoords");const v=new Uint16Array(8);v[0]=3,v[1]=0,v[2]=1,v[3]=3,v[4]=3,v[5]=0,v[6]=3,v[7]=2;const y=Ns.newInstance({numberOfComponents:1,values:v});t.tris.getCABO().createVBO(y,"polys",ss.SURFACE,{points:m,tcoords:h,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=A}},e.updatelabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThicknessByReference(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{const n=1024,o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture=Kd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(n,o,1,Cs.UNSIGNED_CHAR,i),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const Sg={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};const Ag=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sg,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.tris=Pd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),At(e,t,[]),t.VBOBuildTime={},yt(t.VBOBuildTime),Cg(e,t)}),"vtkOpenGLImageMapper");rn("vtkAbstractImageMapper",Ag);const Ig=0,wg=1,Pg=2,{vtkErrorMacro:Og}=jt;function Rg(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageCPRMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()===_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),e.invokeEvent({type:"EndEvent"}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(n,r)=>{e.getNeedToRebuildBufferObjects(n,r)&&e.buildBufferObjects(n,r),r.getProperty().getInterpolationType()===dg.NEAREST?(t.volumeTexture.setMinificationFilter(Rd.NEAREST),t.volumeTexture.setMagnificationFilter(Rd.NEAREST),t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST),t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.volumeTexture.setMinificationFilter(Rd.LINEAR),t.volumeTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR))},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()||!t.volumeTexture?.getHandle()},e.buildBufferObjects=(n,r)=>{const o=t.currentImageDataInput,a=t.currentCenterlineInput,i=o?.getPointData()?.getScalars();if(!i)return;const s=t._openGLRenderWindow.getGraphicsResourceForObject(i),l=ug(o,i);if(s?.oglObject?.getHandle()&&s?.hash===l)t.volumeTexture=s.oglObject;else{t.volumeTexture=Kd.newInstance(),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.volumeTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],i,t.renderable.getPreferSizeOverAccuracy()),t._openGLRenderWindow.setGraphicsResourceForObject(i,t.volumeTexture,l),i!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(i,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=i}const c=i.getNumberOfComponents(),u=r.getProperty(),d=u.getIndependentComponents(),p=d?c:1,f=d?2*p:1,g=u.getRGBTransferFunction(),m=cg(g,d,p),h=t._openGLRenderWindow.getGraphicsResourceForObject(g);if(h?.oglObject?.getHandle()&&h?.hash===m)t.colorTexture=h.oglObject;else{const n=1024,r=new Uint8ClampedArray(n*f*3);if(t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),g){const e=new Float32Array(3*n);for(let t=0;t<p;t++){const o=u.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),d)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,f,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}g&&(t._openGLRenderWindow.setGraphicsResourceForObject(g,t.colorTexture,m),g!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(g,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=g)}const v=u.getPiecewiseFunction(),y=cg(v,d,p),T=t._openGLRenderWindow.getGraphicsResourceForObject(v);if(T?.oglObject?.getHandle()&&T?.hash===y)t.pwfTexture=T.oglObject;else{const n=1024,r=n*f,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),v){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<p;++t){const r=u.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),d)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,f,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);v&&(t._openGLRenderWindow.setGraphicsResourceForObject(v,t.pwfTexture,y),v!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(v,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=v)}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<a.getMTime()){const e=a.getNumberOfPoints(),n=e<=1?0:e-1,r=a.getDistancesToFirstPoint(),o=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,o-r[e],0],t),t+=3,s.set([l,o-r[e],0],t),t+=3,s.set([l,o-r[e+1],0],t),t+=3,s.set([0,o-r[e+1],0],t),t+=3;const c=Ns.newInstance({numberOfComponents:3,values:s});c.setName("points");const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Ns.newInstance({numberOfComponents:1,values:u}),p=a.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Ns.newInstance({numberOfComponents:3,values:f,name:"centerlinePosition"}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const y=[h,Ns.newInstance({numberOfComponents:1,values:v,name:"quadIndex"})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getOrientedCenterline().getOrientations()??[],r=new Float32Array(4*i),o=new Float32Array(4*i);for(let t=0;t<n;++t){const n=e[t],a=e[t+1];for(let e=0;e<4;++e){const i=4*(e+4*t);r.set(n,i),o.set(a,i)}}const a=Ns.newInstance({numberOfComponents:4,values:r,name:"centerlineTopOrientation"}),s=Ns.newInstance({numberOfComponents:4,values:o,name:"centerlineBotOrientation"});y.push(a,s)}t.tris.getCABO().createVBO(d,"polys",ss.SURFACE,{points:c,customAttributes:y}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation(),l=t.renderable.isProjectionEnabled()&&t.renderable.getProjectionMode();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastProjectionMode!==l||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastProjectionMode=l,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;const s=["vec3 applyQuaternionToVec(vec4 q, vec3 v) {","  float uvx = q.y * v.z - q.z * v.y;","  float uvy = q.z * v.x - q.x * v.z;","  float uvz = q.x * v.y - q.y * v.x;","  float uuvx = q.y * uvz - q.z * uvy;","  float uuvy = q.z * uvx - q.x * uvz;","  float uuvz = q.x * uvy - q.y * uvx;","  float w2 = q.w * 2.0;","  uvx *= w2;","  uvy *= w2;","  uvz *= w2;","  uuvx *= 2.0;","  uuvy *= 2.0;","  uuvz *= 2.0;","  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);","}"];a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const l=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],c=t.renderable.isProjectionEnabled(),u=t.renderable.getUseUniformOrientation();u?(l.push("out vec3 samplingDirVSOutput;","uniform vec4 centerlineOrientation;","uniform vec3 tangentDirection;",...s),c&&l.push("out vec3 projectionDirVSOutput;","uniform vec3 bitangentDirection;")):l.push("out vec4 centerlineTopOrientationVSOutput;","out vec4 centerlineBotOrientationVSOutput;","attribute vec4 centerlineTopOrientation;","attribute vec4 centerlineBotOrientation;"),a=yd.substitute(a,"//VTK::Color::Dec",l).result;const d=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];u?(d.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"),c&&d.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")):d.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;","centerlineBotOrientationVSOutput = centerlineBotOrientation;"),a=yd.substitute(a,"//VTK::Color::Impl",d).result;const p=t.volumeTexture.getComponents(),f=o.getProperty().getIndependentComponents();let g=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];c&&g.push("uniform vec3 volumeSizeMC;","uniform int projectionSlabNumberOfSamples;","uniform float projectionConstantOffset;","uniform float projectionStepLength;"),u?(g.push("in vec3 samplingDirVSOutput;"),c&&g.push("in vec3 projectionDirVSOutput;")):(g.push("uniform vec3 tangentDirection;","in vec4 centerlineTopOrientationVSOutput;","in vec4 centerlineBotOrientationVSOutput;",...s),c&&g.push("uniform vec3 bitangentDirection;"));const m=t.renderable.getCenterPoint();if(m&&g.push("uniform vec3 globalCenterPoint;"),f){for(let e=1;e<p;e++)g=g.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(p){case 1:g=g.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:g=g.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Og("Unsupported number of independent coordinates.")}}i=yd.substitute(i,"//VTK::TCoord::Dec",g).result;let h=[];if(u?(h.push("vec3 samplingDirection = samplingDirVSOutput;"),c&&h.push("vec3 projectionDirection = projectionDirVSOutput;")):(h.push("vec4 q0 = centerlineBotOrientationVSOutput;","vec4 q1 = centerlineTopOrientationVSOutput;","float qCosAngle = dot(q0, q1);","vec4 interpolatedOrientation;","if (qCosAngle > 0.999 || qCosAngle < -0.999) {","  // Use LERP instead of SLERP when the two quaternions are close or opposite","  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));","} else {","  float omega = acos(qCosAngle);","  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);","}","vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"),c&&h.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")),m?h.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):h.push("float horizontalOffset = quadOffsetVSOutput.x;"),h.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}"),c){const e=t.renderable.getProjectionMode();switch(e===wg?h.push("const vec4 initialProjectionTextureValue = vec4(1.0);"):h.push("const vec4 initialProjectionTextureValue = vec4(0.0);"),h.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;","vec3 projectionStep = projectionStepLength * projectionScaledDirection;","vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;","vec4 tvalue = initialProjectionTextureValue;","for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {","  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;","  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"),e){case Ig:h.push("  tvalue = max(tvalue, sampledTextureValue);");break;case wg:h.push("  tvalue = min(tvalue, sampledTextureValue);");break;default:h.push("  tvalue = tvalue + sampledTextureValue;")}h.push("}"),e===Pg&&h.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);")}else h.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");if(f){const e=["r","g","b","a"];for(let t=0;t<p;++t)h=h.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(p){case 1:h=h.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:h=h.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Og("Unsupported number of independent coordinates.")}}else switch(p){case 1:h=h.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:h=h.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=yd.substitute(i,"//VTK::TCoord::Impl",h).result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6),o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=yd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=yd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=n.getCABO();i.getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(a,i,"vertexMC",i.getVertexOffset(),i.getStride(),t.context.FLOAT,3,t.context.FALSE)||Og("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach((e=>{e&&a.isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(a,i,e.name,e.offset,i.getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&Og(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const s=t.volumeTexture.getTextureUnit();if(a.setUniformi("volumeTexture",s),a.setUniformf("width",t.renderable.getWidth()),n.getProgram().setUniform4fv("backgroundColor",t.renderable.getBackgroundColor()),a.isUniformUsed("tangentDirection")){const e=t.renderable.getTangentDirection();n.getProgram().setUniform3fArray("tangentDirection",e)}if(a.isUniformUsed("bitangentDirection")){const e=t.renderable.getBitangentDirection();n.getProgram().setUniform3fArray("bitangentDirection",e)}if(a.isUniformUsed("centerlineOrientation")){const e=t.renderable.getUniformOrientation();n.getProgram().setUniform4fv("centerlineOrientation",e)}if(a.isUniformUsed("globalCenterPoint")){const e=t.renderable.getCenterPoint();a.setUniform3fArray("globalCenterPoint",e)}if(t.renderable.isProjectionEnabled()){const e=t.currentImageDataInput,n=e.getSpacing(),r=e.getDimensions(),o=t.renderable.getProjectionSlabThickness(),i=t.renderable.getProjectionSlabNumberOfSamples(),s=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}([],n,r);a.setUniform3fArray("volumeSizeMC",s),a.setUniformi("projectionSlabNumberOfSamples",i);const l=-.5*o;a.setUniformf("projectionConstantOffset",l);const c=o/(i-1);a.setUniformf("projectionStepLength",c)}const l=t.currentImageDataInput,c=l.getWorldToIndex(),u=P(new Float32Array(16),Rn([],l.getDimensions())),p=oe(u,u,c);if(a.setUniformMatrix("MCTCMatrix",p),t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6);const n=i.getCoordShiftAndScaleEnabled()?i.getInverseShiftAndScaleMatrix():null,r=n?d(t.imagematinv,o.getMatrix()):o.getMatrix();n&&(m(r,r),T(r,r,n),m(r,r)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),T(t.imagematinv,r,t.imagemat);const s=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)s.push(e[t])}a.setUniformi("numClipPlanes",e),a.setUniform4fv("clipPlanes",s)}if(a.isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);a.setUniformf("coffset",t.offset),a.isUniformUsed("cfactor")&&a.setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(T(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix("MCPCMatrix",t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.delete=jt.chain((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const Mg={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const Eg=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mg,n),Zt.extend(e,t,n),Xd(e,t,n),jt.algo(e,t,2,0),t.tris=Pd.newInstance(),t.volumeTexture=null,t.colorTexture=null,t.pwfTexture=null,t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),Rg(e,t)}),"vtkOpenGLImageCPRMapper");function Dg(e,t){t.classHierarchy.push("vtkOpenGLImageSlice"),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkImageCPRMapper",Eg);const Vg={context:null,keyMatrixTime:null,keyMatrices:null};const Lg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vg,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},At(e,t,["context"]),Dg(e,t)}),"vtkOpenGLImageSlice");function Bg(e,t){t.classHierarchy.push("vtkOpenGLVolume"),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}rn("vtkImageSlice",Lg);const Ng={};const _g=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ng,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),At(e,t,["context"]),Bg(e,t)}),"vtkOpenGLVolume");rn("vtkVolume",_g);const Fg={NEAREST:0,LINEAR:1,FAST_LINEAR:2},kg={FRACTIONAL:0,PROPORTIONAL:1},Gg={CUSTOM:0,ADDITIVE:1,COLORIZE:2};var Ug={InterpolationType:Fg,OpacityMode:kg,ColorMixPreset:Gg};const zg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6};var Wg={BlendMode:zg,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const{vtkWarningMacro:Hg,vtkErrorMacro:jg}=Kt;function Kg(e,t){function n(n){[t._scalars,t._scalarOpacityFunc,t._colorTransferFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLVolumeMapper"),e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(r,o)=>{if(r){const r=t._openGLRenderWindow;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType("vtkOpenGLVolume");const o=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const a=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(a.getActiveCamera()),e.renderPiece(a,o)}},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\n// the output of this shader\n//VTK::Output::Dec\n\nvarying vec3 vertexVCVSOutput;\n\n// first declare the settings from the mapper\n// that impact the code paths in here\n\n// always set vtkNumComponents 1,2,3,4\n//VTK::NumComponents\n\n// possibly define vtkTrilinearOn\n//VTK::TrilinearOn\n\n// possibly define UseIndependentComponents\n//VTK::IndependentComponentsOn\n\n// possibly define vtkCustomComponentsColorMix\n//VTK::CustomComponentsColorMixOn\n\n// possibly define any \"proportional\" components\n//VTK::vtkProportionalComponents\n\n// possibly define any components that are forced to nearest interpolation\n//VTK::vtkForceNearestComponents\n\n// Define the blend mode to use\n#define vtkBlendMode //VTK::BlendMode\n\n// Possibly define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Possibly define vtkLabelEdgeProjectionOn\n//VTK::LabelEdgeProjectionOn\n\n\n#ifdef vtkImageLabelOutlineOn\n  uniform float outlineOpacity;\n  uniform float vpWidth;\n  uniform float vpHeight;\n  uniform float vpOffsetX;\n  uniform float vpOffsetY;\n  uniform mat4 PCWCMatrix;\n  uniform mat4 vWCtoIDX;\n\n  const int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n  // bool seenSegmentsByOriginalPos[MAX_SEGMENT_INDEX];\n  #define MAX_SEGMENTS 256\n  #define UINT_SIZE 32\n  #define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\n\n  uint bitmask[BITMASK_SIZE];\n\n  // Set the corresponding bit in the bitmask\n  void setBit(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    bitmask[index] |= 1u << bitIndex;\n  }\n\n  // Check if a bit is set in the bitmask\n  bool isBitSet(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    return ((bitmask[index] & (1u << bitIndex)) != 0u);\n  }\n#endif\n\n// define vtkLightComplexity\n//VTK::LightComplexity\n#if vtkLightComplexity > 0\nuniform float vSpecularPower;\nuniform float vAmbient;\nuniform float vDiffuse;\nuniform float vSpecular;\n//VTK::Light::Dec\n#endif\n\n//VTK::VolumeShadowOn\n//VTK::SurfaceShadowOn\n//VTK::localAmbientOcclusionOn\n//VTK::LAO::Dec\n//VTK::VolumeShadow::Dec\n\n// define vtkComputeNormalFromOpacity\n//VTK::vtkComputeNormalFromOpacity\n\n// possibly define vtkGradientOpacityOn\n//VTK::GradientOpacityOn\n#ifdef vtkGradientOpacityOn\nuniform float goscale0;\nuniform float goshift0;\nuniform float gomin0;\nuniform float gomax0;\n#ifdef UseIndependentComponents\n#if vtkNumComponents > 1\nuniform float goscale1;\nuniform float goshift1;\nuniform float gomin1;\nuniform float gomax1;\n#if vtkNumComponents > 2\nuniform float goscale2;\nuniform float goshift2;\nuniform float gomin2;\nuniform float gomax2;\n#if vtkNumComponents > 3\nuniform float goscale3;\nuniform float goshift3;\nuniform float gomin3;\nuniform float gomax3;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n// values describing the volume geometry\nuniform vec3 vOriginVC;\nuniform vec3 vSpacing;\nuniform ivec3 volumeDimensions; // 3d texture dimensions\nuniform vec3 vPlaneNormal0;\nuniform float vPlaneDistance0;\nuniform vec3 vPlaneNormal1;\nuniform float vPlaneDistance1;\nuniform vec3 vPlaneNormal2;\nuniform float vPlaneDistance2;\nuniform vec3 vPlaneNormal3;\nuniform float vPlaneDistance3;\nuniform vec3 vPlaneNormal4;\nuniform float vPlaneDistance4;\nuniform vec3 vPlaneNormal5;\nuniform float vPlaneDistance5;\n\n//VTK::ClipPlane::Dec\n\n// opacity and color textures\nuniform sampler2D otexture;\nuniform float oshift0;\nuniform float oscale0;\nuniform sampler2D ctexture;\nuniform float cshift0;\nuniform float cscale0;\n\n#if vtkNumComponents >= 2\nuniform float oshift1;\nuniform float oscale1;\nuniform float cshift1;\nuniform float cscale1;\n#endif\n#if vtkNumComponents >= 3\nuniform float oshift2;\nuniform float oscale2;\nuniform float cshift2;\nuniform float cscale2;\n#endif\n#if vtkNumComponents >= 4\nuniform float oshift3;\nuniform float oscale3;\nuniform float cshift3;\nuniform float cscale3;\n#endif\n\n// jitter texture\nuniform sampler2D jtexture;\nuniform sampler2D ttexture;\n\n\n// some 3D texture values\nuniform float sampleDistance;\nuniform vec3 vVCToIJK;\nuniform vec3 volumeSpacings; // spacing in the world coorindates\n\n\n// the heights defined below are the locations\n// for the up to four components of the tfuns\n// the tfuns have a height of 2XnumComps pixels so the\n// values are computed to hit the middle of the two rows\n// for that component\n#ifdef UseIndependentComponents\n#if vtkNumComponents == 1\nuniform float mix0;\n#define height0 0.5\n#endif\n#if vtkNumComponents == 2\nuniform float mix0;\nuniform float mix1;\n#define height0 0.25\n#define height1 0.75\n#endif\n#if vtkNumComponents == 3\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\n#define height0 0.17\n#define height1 0.5\n#define height2 0.83\n#endif\n#if vtkNumComponents == 4\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\nuniform float mix3;\n#define height0 0.125\n#define height1 0.375\n#define height2 0.625\n#define height3 0.875\n#endif\n#endif\n\nuniform vec4 ipScalarRangeMin;\nuniform vec4 ipScalarRangeMax;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\nvec3 rayDirVC;\nfloat sampleDistanceISVS;\nfloat sampleDistanceIS;\n\n#define SQRT3    1.7321\n#define INV4PI   0.0796\n#define EPSILON  0.001\n#define PI       3.1415\n#define PI2      9.8696\n\n//=======================================================================\n// Webgl2 specific version of functions\n#if __VERSION__ == 300\n\nuniform highp sampler3D texture1;\n\nvec4 getTextureValue(vec3 pos)\n{\n  vec4 tmp = texture(texture1, pos);\n\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volumeDimensions)) + 0.5) / vec3(volumeDimensions);\n    vec4 nearestValue = texture(texture1, nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  #ifndef UseIndependentComponents\n    #if vtkNumComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n//=======================================================================\n// WebGL1 specific version of functions\n#else\n\nuniform sampler2D texture1;\n\nuniform float texWidth;\nuniform float texHeight;\nuniform int xreps;\nuniform int xstride;\nuniform int ystride;\n\n// if computing trilinear values from multiple z slices\n#ifdef vtkTrilinearOn\nvec4 getTextureValue(vec3 ijk)\n{\n  float zoff = 1.0/float(volumeDimensions.z);\n  vec4 val1 = getOneTextureValue(ijk);\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\n\n  float indexZ = float(volumeDimensions)*ijk.z;\n  float zmix =  indexZ - floor(indexZ);\n\n  return mix(val1, val2, zmix);\n}\n\nvec4 getOneTextureValue(vec3 ijk)\n#else // nearest or fast linear\nvec4 getTextureValue(vec3 ijk)\n#endif\n{\n  vec3 tdims = vec3(volumeDimensions);\n\n#ifdef debugtile\n  vec2 tpos = vec2(ijk.x, ijk.y);\n  vec4 tmp = texture2D(texture1, tpos);\n  tmp.a = 1.0;\n\n#else\n  int z = int(ijk.z * tdims.z);\n  int yz = z / xreps;\n  int xz = z - yz*xreps;\n\n  int tileWidth = volumeDimensions.x/xstride;\n  int tileHeight = volumeDimensions.y/ystride;\n\n  xz *= tileWidth;\n  yz *= tileHeight;\n\n  float ni = float(xz) + (ijk.x*float(tileWidth));\n  float nj = float(yz) + (ijk.y*float(tileHeight));\n\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\n\n  vec4 tmp = texture2D(texture1, tpos);\n\n#if vtkNumComponents == 1\n  tmp.a = tmp.r;\n#endif\n#if vtkNumComponents == 2\n  tmp.g = tmp.a;\n#endif\n#if vtkNumComponents == 3\n  tmp.a = length(tmp.rgb);\n#endif\n#endif\n\n  return tmp;\n}\n\n// End of Webgl1 specific code\n//=======================================================================\n#endif\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\nvec3 IStoVC(vec3 posIS){\n  vec3 posVC = posIS / vVCToIJK;\n  return posVC.x * vPlaneNormal0 +\n         posVC.y * vPlaneNormal2 +\n         posVC.z * vPlaneNormal4 +\n         vOriginVC;\n}\n\n// convert vector position from vc to idx\nvec3 VCtoIS(vec3 posVC){\n  posVC = posVC - vOriginVC;\n  posVC = vec3(\n    dot(posVC, vPlaneNormal0),\n    dot(posVC, vPlaneNormal2),\n    dot(posVC, vPlaneNormal4));\n  return posVC * vVCToIJK;\n}\n#endif\n\n//Rotate vector to view coordinate\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\nvoid rotateToViewCoord(inout vec3 dirIS){\n  dirIS.xyz =\n    dirIS.x * vPlaneNormal0 +\n    dirIS.y * vPlaneNormal2 +\n    dirIS.z * vPlaneNormal4;\n}\n\n//Rotate vector to idx coordinate\nvec3 rotateToIDX(vec3 dirVC){\n  vec3 dirIS;\n  dirIS.xyz = vec3(\n    dot(dirVC, vPlaneNormal0),\n    dot(dirVC, vPlaneNormal2),\n    dot(dirVC, vPlaneNormal4));\n  return dirIS;\n}\n#endif\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\n{\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward difference\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\n  #ifdef vtkClippingPlanesOn\n    void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\n    {\n      vec3 g1VC[3];\n      for (int i = 0; i < 3; ++i)\n      {\n        g1VC[i] = IStoVC(texPos[i]);\n      }\n      vec3 posVC = IStoVC(pos);\n      for (int i = 0; i < clip_numPlanes; ++i)\n      {\n        for (int j = 0; j < 3; ++j)\n        {\n          if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\n          {\n            g1[j] = 0.0;\n          }\n        }\n      }\n    }\n  #endif\n\n  #ifdef vtkComputeNormalFromOpacity\n    vec4 computeDensityNormal(vec3 opacityUCoords[2], float opactityTextureHeight, float gradientOpacity) {\n      vec3 opacityG1, opacityG2;\n      opacityG1.x = texture2D(otexture, vec2(opacityUCoords[0].x, opactityTextureHeight)).r;\n      opacityG1.y = texture2D(otexture, vec2(opacityUCoords[0].y, opactityTextureHeight)).r;\n      opacityG1.z = texture2D(otexture, vec2(opacityUCoords[0].z, opactityTextureHeight)).r;\n      opacityG2.x = texture2D(otexture, vec2(opacityUCoords[1].x, opactityTextureHeight)).r;\n      opacityG2.y = texture2D(otexture, vec2(opacityUCoords[1].y, opactityTextureHeight)).r;\n      opacityG2.z = texture2D(otexture, vec2(opacityUCoords[1].z, opactityTextureHeight)).r;\n      opacityG1.xyz *= gradientOpacity;\n      opacityG2.xyz *= gradientOpacity;\n\n      vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\n      // divide by spacing\n      opacityG.xyz /= vSpacing;\n      opacityG.w = length(opacityG.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(opacityG.xyz);\n      if (!all(equal(opacityG.xyz, vec3(0.0)))) {\n        return vec4(normalize(opacityG.xyz),opacityG.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n\n    vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2], const int opacityComponent)\n    {\n      vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n      vec3 yvec = vec3(0.0, tstep.y, 0.0);\n      vec3 zvec = vec3(0.0, 0.0, tstep.z);\n      vec3 texPosPVec[3];\n      texPosPVec[0] = pos + xvec;\n      texPosPVec[1] = pos + yvec;\n      texPosPVec[2] = pos + zvec;\n      vec3 texPosNVec[3];\n      texPosNVec[0] = pos - xvec;\n      texPosNVec[1] = pos - yvec;\n      texPosNVec[2] = pos - zvec;\n      vec3 g1, g2;\n\n      scalarInterp[0].x = getTextureValue(texPosPVec[0])[opacityComponent];\n      scalarInterp[0].y = getTextureValue(texPosPVec[1])[opacityComponent];\n      scalarInterp[0].z = getTextureValue(texPosPVec[2])[opacityComponent];\n      scalarInterp[1].x = getTextureValue(texPosNVec[0])[opacityComponent];\n      scalarInterp[1].y = getTextureValue(texPosNVec[1])[opacityComponent];\n      scalarInterp[1].z = getTextureValue(texPosNVec[2])[opacityComponent];\n\n      #ifdef vtkClippingPlanesOn\n        adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\n        adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\n      #endif\n      vec4 result;\n      result.x = scalarInterp[0].x - scalarInterp[1].x;\n      result.y = scalarInterp[0].y - scalarInterp[1].y;\n      result.z = scalarInterp[0].z - scalarInterp[1].z;\n      // divide by spacing\n      result.xyz /= vSpacing;\n      result.w = length(result.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      if (length(result.xyz) > 0.0) {\n        return vec4(normalize(result.xyz),result.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n  #endif\n\n  // only works with dependent components\n  vec4 computeNormal(vec3 pos, vec3 tstep)\n  {\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\n    vec3 texPosPVec[3];\n    texPosPVec[0] = pos + xvec;\n    texPosPVec[1] = pos + yvec;\n    texPosPVec[2] = pos + zvec;\n    vec3 texPosNVec[3];\n    texPosNVec[0] = pos - xvec;\n    texPosNVec[1] = pos - yvec;\n    texPosNVec[2] = pos - zvec;\n    vec3 g1, g2;\n    g1.x = getTextureValue(texPosPVec[0]).a;\n    g1.y = getTextureValue(texPosPVec[1]).a;\n    g1.z = getTextureValue(texPosPVec[2]).a;\n    g2.x = getTextureValue(texPosNVec[0]).a;\n    g2.y = getTextureValue(texPosNVec[1]).a;\n    g2.z = getTextureValue(texPosNVec[2]).a;\n    #ifdef vtkClippingPlanesOn\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\n    #endif\n    vec4 result;\n    result = vec4(g1 - g2, -1.0);\n    // divide by spacing\n    result.xyz /= vSpacing;\n    result.w = length(result.xyz);\n    if (result.w > 0.0){\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      return vec4(normalize(result.xyz),result.w);\n    } else {\n      return vec4(0.0);\n    }\n  }\n#endif\n\n\n#ifdef vtkImageLabelOutlineOn\n  vec4 fragCoordToPCPos(vec4 fragCoord) {\n    return vec4(\n      (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n      (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n      (fragCoord.z - 0.5) * 2.0,\n      1.0);\n  }\n\n  vec4 pcPosToWorldCoord(vec4 pcPos) {\n    return PCWCMatrix * pcPos;\n  }\n\n  vec3 fragCoordToIndexSpace(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    vec4 vertex = (worldCoord / worldCoord.w);\n\n    vec3 index = (vWCtoIDX * vertex).xyz;\n\n    // half voxel fix for labelmapOutline\n    return (index + vec3(0.5)) / vec3(volumeDimensions);\n  }\n\n  vec3 fragCoordToWorld(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    return worldCoord.xyz;\n  }\n#endif\n\n//=======================================================================\n// compute the normals and gradient magnitudes for a position\n// for independent components\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\n{\n  mat4 result;\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\n\n  // divide by spacing\n  distX /= vSpacing.x;\n  distY /= vSpacing.y;\n  distZ /= vSpacing.z;\n\n  mat3 rot;\n  rot[0] = vPlaneNormal0;\n  rot[1] = vPlaneNormal2;\n  rot[2] = vPlaneNormal4;\n\n#if !defined(vtkComponent0Proportional)\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\n  result[0].a = length(result[0].xyz);\n  result[0].xyz *= rot;\n  if (result[0].w > 0.0)\n  {\n    result[0].xyz /= result[0].w;\n  }\n#endif\n\n// optionally compute the 2nd component\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\n  result[1].a = length(result[1].xyz);\n  result[1].xyz *= rot;\n  if (result[1].w > 0.0)\n  {\n    result[1].xyz /= result[1].w;\n  }\n#endif\n\n// optionally compute the 3rd component\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\n  result[2].a = length(result[2].xyz);\n  result[2].xyz *= rot;\n  if (result[2].w > 0.0)\n  {\n    result[2].xyz /= result[2].w;\n  }\n#endif\n\n// optionally compute the 4th component\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\n  result[3].a = length(result[3].xyz);\n  result[3].xyz *= rot;\n  if (result[3].w > 0.0)\n  {\n    result[3].xyz /= result[3].w;\n  }\n#endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\nfloat random()\n{\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\n  uint pcg_state = floatBitsToUint(jitter);\n  uint state = pcg_state;\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\n}\n#endif\n\n#ifdef VolumeShadowOn\n// henyey greenstein phase function\nfloat phase_function(float cos_angle)\n{\n  // divide by 2.0 instead of 4pi to increase intensity\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\n}\n\n// Computes the intersection between a ray and a box\nstruct Hit\n{\n  float tmin;\n  float tmax;\n};\n\nstruct Ray\n{\n  vec3 origin;\n  vec3 dir;\n  vec3 invDir;\n};\n\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\n{\n  vec3 tbot = r.invDir * (boundMin - r.origin);\n  vec3 ttop = r.invDir * (boundMax - r.origin);\n  vec3 tmin = min(ttop, tbot);\n  vec3 tmax = max(ttop, tbot);\n  vec2 t = max(tmin.xx, tmin.yz);\n  float t0 = max(t.x, t.y);\n  t = min(tmax.xx, tmax.yz);\n  float t1 = min(t.x, t.y);\n  hit.tmin = t0;\n  hit.tmax = t1;\n  return t1 > max(t0,0.0);\n}\n\n// As BBoxIntersect requires the inverse of the ray coords,\n// this function is used to avoid numerical issues\nvoid safe_0_vector(inout Ray ray)\n{\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\n}\n\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\n{\n  float shadow = 1.0;\n  float opacity = 0.0;\n\n  // modify sample distance with a random number between 1.5 and 3.0\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\n\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\n\n  // compute the start and end points for the ray\n  Ray ray;\n  Hit hit;\n  ray.origin = posIS;\n  ray.dir = lightDirNormIS;\n  safe_0_vector(ray);\n  ray.invDir = 1.0/ray.dir;\n\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\n  {\n    return 1.0;\n  }\n  float maxdist = hit.tmax;\n\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\n  maxdist = min(maxdist,maxgi);\n  if(maxdist < EPSILON) {\n    return 1.0;\n  }\n\n  float current_dist = 0.0;\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\n  float clamped_step = 0.0;\n\n  vec4 scalar = vec4(0.0);\n  while(current_dist < maxdist)\n  {\n#ifdef vtkClippingPlanesOn\n    vec3 posVC = IStoVC(posIS);\n    for (int i = 0; i < clip_numPlanes; ++i)\n    {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\n      {\n        current_dist = maxdist;\n      }\n    }\n#endif\n    scalar = getTextureValue(posIS);\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\n    #if defined(vtkGradientOpacityOn) && !defined(UseIndependentComponents)\n      vec4 normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n    #endif\n    shadow *= 1.0 - opacity;\n\n    // optimization: early termination\n    if (shadow < EPSILON){\n      return 0.0;\n    }\n\n    clamped_step = min(maxdist - current_dist, current_step);\n    posIS += clamped_step * lightDirNormIS;\n    current_dist += current_step;\n  }\n\n  return shadow;\n}\n\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\n{\n  vec3 vertLight = vec3(0.0);\n  vec3 secondary_contrib = vec3(0.0);\n  // here we assume only positional light, no effect of cones\n  for (int i = 0; i < lightNum; i++)\n  {\n    #if(vtkLightComplexity==3)\n      if (lightPositional[i] == 1){\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\n      }else{\n        vertLight = - lightDirectionVC[i];\n      }\n    #else\n      vertLight = - lightDirectionVC[i];\n    #endif\n    // here we assume achromatic light, only intensity\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    float phase_attenuation = 0.5;\n    if (abs(anisotropy) > EPSILON){\n      phase_attenuation = phase_function(dDotL);\n    }\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\n    secondary_contrib += tColor * vAmbient;\n  }\n  return secondary_contrib;\n}\n#endif\n\n//=======================================================================\n// local ambient occlusion\n#ifdef localAmbientOcclusionOn\nvec3 sample_direction_uniform(int i)\n{\n  float rand = random() * 0.5;\n  float theta = PI2 * (kernelSample[i][0] + rand);\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\n}\n\n// return a matrix that transform startDir into z axis; startDir should be normalized\nmat3 zBaseRotationalMatrix(vec3 startDir){\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\n  float cosA = startDir.z;\n  float k = 1.0 / (1.0 + cosA);\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\n  return matrix;\n}\n\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\n  // apply LAO only at selected locations, otherwise return full brightness\n  if (normal.w > 0.0 && op > 0.05){\n    float total_transmittance = 0.0;\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\n    vec3 currPos, randomDirStep;\n    float weight, transmittance, opacity;\n    for (int i = 0; i < kernelSize; i++)\n    {\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\n      currPos = posIS;\n      transmittance = 1.0;\n      for (int j = 0; j < kernelRadius ; j++){\n        currPos += randomDirStep;\n        // check if it's at clipping plane, if so return full brightness\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\n          #ifdef vtkGradientOpacityOn\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n          #endif\n          transmittance *= 1.0 - opacity;\n        }\n        else{\n          break;\n        }\n      }\n      total_transmittance += transmittance / float(kernelRadius) * weight;\n\n      // early termination if fully translucent\n      if (total_transmittance > 1.0 - EPSILON){\n        return 1.0;\n      }\n    }\n    // average transmittance and reduce variance\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\n  } else {\n    return 1.0;\n  }\n}\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkLightComplexity > 0\n  void applyLighting(inout vec3 tColor, vec4 normal)\n  {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    float df, sf = 0.0;\n    for (int i = 0; i < lightNum; i++){\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\n        diffuse += df * lightColor[i];\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\n        specular += sf * lightColor[i];\n    }\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\n  }\n  #ifdef SurfaceShadowOn\n  #if vtkLightComplexity < 3\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float ndotL,vdotR;\n        vertLightDirection = lightDirectionVC[i];\n        ndotL = dot(normal.xyz, vertLightDirection);\n        if (ndotL < 0.0 && twoSidedLighting)\n        {\n          ndotL = -ndotL;\n        }\n        if (ndotL > 0.0)\n        {\n          diffuse += ndotL * lightColor[i];\n          //specular\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n          if (vdotR > 0.0)\n          {\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\n          }\n        }\n        #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n        #endif\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #else\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float distance,attenuation,ndotL,vdotR;\n        vec3 lightDir;\n        if (lightPositional[i] == 1){\n          lightDir = lightDirectionVC[i];\n          vertLightDirection = posVC - lightPositionVC[i];\n          distance = length(vertLightDirection);\n          vertLightDirection = normalize(vertLightDirection);\n          attenuation = 1.0 / (lightAttenuation[i].x\n                              + lightAttenuation[i].y * distance\n                              + lightAttenuation[i].z * distance * distance);\n          // per OpenGL standard cone angle is 90 or less for a spot light\n          if (lightConeAngle[i] <= 90.0){\n            float coneDot = dot(vertLightDirection, lightDir);\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\n            }\n            else {\n              attenuation = 0.0;\n            }\n          }\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * attenuation * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        } else {\n          vertLightDirection = lightDirectionVC[i];\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        }\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #endif\n  #endif\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posIS, vec4 normalLight) {\n  #if vtkLightComplexity > 0\n    // surface shadows if needed\n    #ifdef SurfaceShadowOn\n      #if vtkLightComplexity < 3\n        vec3 tColorS = applyLightingDirectional(posIS, vec4(tColor, alpha), normalLight);\n      #else\n        vec3 tColorS = applyLightingPositional(posIS, vec4(tColor, alpha), normalLight, IStoVC(posIS));\n      #endif\n    #endif\n\n    // volume shadows if needed\n    #ifdef VolumeShadowOn\n      vec3 tColorVS = applyShadowRay(tColor, posIS, rayDirVC);\n    #endif\n\n    // merge\n    #ifdef VolumeShadowOn\n      #ifdef SurfaceShadowOn\n        // surface shadows + volumetric shadows\n        float vol_coef = volumetricScatteringBlending * (1.0 - alpha / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\n        tColor = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\n      #else\n        // volumetric shadows only\n        tColor = tColorVS;\n      #endif\n    #else\n      #ifdef SurfaceShadowOn\n        // surface shadows only\n        tColor = tColorS;\n      #else\n        // no shadows\n        applyLighting(tColor, normal3);\n      #endif\n    #endif\n  #endif\n  return tColor;\n}\n\n  \nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\n{\n\n// If labeloutline and not the edge labelmap, since in the edge labelmap blend\n// we need the underlying data to sample through\n#if defined(vtkImageLabelOutlineOn) && !defined(vtkLabelEdgeProjectionOn)\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\n\n  // Get alpha of segment from opacity function.\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\n\n  int segmentIndex = int(centerValue.r * 255.0);\n  \n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n  int actualThickness = int(textureValue * 255.0);\n\n\n  // If it is the background (segment index 0), we should quickly bail out. \n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0){\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\n  // Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n        gl_FragCoord.y + float(j),\n        gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = outlineOpacity;\n  }\n\n  return tColor;\n\n#else\n  // compute the normal and gradient magnitude if needed\n  // We compute it as a vec4 if possible otherwise a mat4\n\n  #ifdef UseIndependentComponents\n\n    // sample textures\n    vec3 tColor0 = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\n\n    #if vtkNumComponents > 1\n      vec3 tColor1 = texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\n      float pwfValue1 = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\n\n      #if vtkNumComponents > 2\n        vec3 tColor2 = texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\n        float pwfValue2 = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\n\n        #if vtkNumComponents > 3\n          vec3 tColor3 = texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\n          float pwfValue3 = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\n        #endif\n      #endif\n    #endif\n\n    #if !defined(vtkCustomComponentsColorMix)\n      // default path for component color mix\n\n      // compute the normal vectors as needed\n      #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n      #endif\n\n      // compute gradient opacity factors as needed\n      vec4 goFactor = vec4(1.0, 1.0 ,1.0 ,1.0);\n      #if defined(vtkGradientOpacityOn)\n        #if !defined(vtkComponent0Proportional)\n          goFactor.x =\n            computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n        #endif\n        #if vtkNumComponents > 1\n          #if !defined(vtkComponent1Proportional)\n            goFactor.y =\n              computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          #endif\n          #if vtkNumComponents > 2\n            #if !defined(vtkComponent2Proportional)\n              goFactor.z =\n                computeGradientOpacityFactor(normalMat[2].a, goscale2, goshift2, gomin2, gomax2);\n            #endif\n            #if vtkNumComponents > 3\n              #if !defined(vtkComponent3Proportional)\n                goFactor.w =\n                  computeGradientOpacityFactor(normalMat[3].a, goscale3, goshift3, gomin3, gomax3);\n              #endif\n            #endif\n          #endif\n        #endif\n      #endif\n\n      // process color and opacity for each component\n      #if !defined(vtkComponent0Proportional)\n        float alpha = goFactor.x*mix0*pwfValue0;\n        #if vtkLightComplexity > 0\n          applyLighting(tColor0, normalMat[0]);\n        #endif\n      #else\n        tColor0 *= pwfValue0;\n        float alpha = mix(pwfValue0, 1.0, (1.0 - mix0));\n      #endif\n\n      #if vtkNumComponents > 1\n        #if !defined(vtkComponent1Proportional)\n          alpha += goFactor.y*mix1*pwfValue1;\n          #if vtkLightComplexity > 0\n            applyLighting(tColor1, normalMat[1]);\n          #endif\n        #else\n          tColor1 *= pwfValue1;\n          alpha *= mix(pwfValue1, 1.0, (1.0 - mix1));\n        #endif\n\n        #if vtkNumComponents > 2\n          #if !defined(vtkComponent2Proportional)\n            alpha += goFactor.z*mix2*pwfValue2;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor2, normalMat[2]);\n            #endif\n          #else\n            tColor2 *= pwfValue2;\n            alpha *= mix(pwfValue2, 1.0, (1.0 - mix2));\n          #endif\n        #endif\n\n        #if vtkNumComponents > 3\n          #if !defined(vtkComponent3Proportional)\n            alpha += goFactor.w*mix3*pwfValue3;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor3, normalMat[3]);\n            #endif\n          #else\n            tColor3 *= pwfValue3;\n            alpha *= mix(pwfValue3, 1.0, (1.0 - mix3));\n          #endif\n        #endif\n      #endif\n\n      // perform final independent blend\n      vec3 tColor = mix0 * tColor0;\n      #if vtkNumComponents > 1\n        tColor += mix1 * tColor1;\n        #if vtkNumComponents > 2\n          tColor += mix2 * tColor2;\n          #if vtkNumComponents > 3\n            tColor += mix3 * tColor3;\n          #endif\n        #endif\n      #endif\n\n      return vec4(tColor, alpha);\n    #else\n      /*\n       * Mix the color information from all the independent components to get a single rgba output\n       * Gradient opactity factors and normals are not computed\n       *\n       * You can compute these using:\n       * - computeMat4Normal: always available, compute normal only for non proportional components, used by default independent component mix\n       * - computeDensityNormal & computeNormalForDensity: available if ((LightComplexity > 0) || GradientOpacityOn) && ComputeNormalFromOpacity),\n       *                                                   used by dependent component color mix, see code for Additive preset in OpenGl/VolumeMapper\n       * - computeGradientOpacityFactor: always available, used in a lot of places\n       *\n       * Using applyAllLightning() is advised for shading but some features don't work well with it (volume shadows, LAO)\n       * mix0, mix1, ... are defined for each component that is used and correspond to the componentWeight\n       */\n      //VTK::CustomComponentsColorMix::Impl\n    #endif\n  #else\n    // dependent components\n\n    // compute normal if needed\n    #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n      // use component 3 of the opacity texture as getTextureValue() sets alpha to the opacity value\n      #ifdef vtkComputeNormalFromOpacity\n        vec3 scalarInterp[2];\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp, 3);\n      #else\n        vec4 normal0 = computeNormal(posIS, tstep);\n      #endif\n    #endif\n\n    // compute gradient opacity factor enabled\n    #if defined(vtkGradientOpacityOn)\n      float gradientOpacity = computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\n    #else\n      const float gradientOpacity = 1.0;\n    #endif\n\n    // get color and opacity\n    #if vtkNumComponents == 1\n      vec3 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5)).rgb;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      if (alpha < EPSILON){\n        return vec4(0.0);\n      }\n    #endif\n    #if vtkNumComponents == 2\n      vec3 tColor = vec3(tValue.r * cscale0 + cshift0);\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 3\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 4\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\n    #endif\n\n    // lighting\n    #if (vtkLightComplexity > 0)\n      #ifdef vtkComputeNormalFromOpacity\n        vec4 normalLight;\n        if (!all(equal(normal0, vec4(0.0)))) {\n          scalarInterp[0] = scalarInterp[0] * oscale0 + oshift0;\n          scalarInterp[1] = scalarInterp[1] * oscale0 + oshift0;\n          normalLight = computeDensityNormal(scalarInterp, 0.5, gradientOpacity);\n          if (all(equal(normalLight, vec4(0.0)))) {\n            normalLight = normal0;\n          }\n        }\n      #else\n        vec4 normalLight = normal0;\n      #endif\n      tColor = applyAllLightning(tColor, alpha, posIS, normalLight);\n    #endif\n\n    return vec4(tColor, alpha);\n  #endif // dependent\n#endif\n}\n\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\n  bool withinRange = false;\n  #if vtkNumComponents == 1\n    if (val.r >= min.r && val.r <= max.r) {\n      withinRange = true;\n    }\n  #else\n    #ifdef UseIndependentComponents\n      #if vtkNumComponents == 2\n        if (val.r >= min.r && val.r <= max.r &&\n            val.g >= min.g && val.g <= max.g) {\n          withinRange = true;\n        }\n      #else\n        if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\n            all(lessThanEqual(val, ipScalarRangeMax))) {\n          withinRange = true;\n        }\n      #endif\n    #endif\n  #endif\n  return withinRange;\n}\n\n#if vtkBlendMode == 6 \nbool checkOnEdgeForNeighbor(int i, int j, int s, vec3 stepIS) {\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j), gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    bool justSawIt = false;\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n\n    float stepsTraveled = 0.0;\n\n\n    // float neighborValue;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS += stepIS;\n    }\n\n    if (justSawIt){\n      return false;\n    }\n\n   \n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS -= stepIS;\n    }\n\n\n    if (!justSawIt) {\n        // onedge\n        vec3 tColorSegment = texture2D(ctexture, vec2(float(s) * cscale1 + cshift1, height1)).rgb;\n        float pwfValueSegment = texture2D(otexture, vec2(float(s) * oscale1 + oshift1, height1)).r;\n        gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n        return true;\n    }\n\n    // not on edge\n    return false;\n}\n\n#endif\n\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\n{\n  vec3 tstep = 1.0/tdims;\n\n  // start slightly inside and apply some jitter\n  vec3 delta = endIS - posIS;\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\n  float raySteps = length(delta)/sampleDistanceIS;\n\n  // Initialize arrays to false\n  // avoid 0.0 jitter\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\n  float stepsTraveled = jitter;\n\n  // local vars for the loop\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 tValue;\n  vec4 tColor;\n\n  // if we have less than one step then pick the middle point\n  // as our value\n  // if (raySteps <= 1.0)\n  // {\n  //   posIS = (posIS + endIS)*0.5;\n  // }\n\n  // Perform initial step at the volume boundary\n  // compute the scalar\n  tValue = getTextureValue(posIS);\n  \n  #if vtkBlendMode == 6 \n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    uint bitmask = 0u;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading \n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the segment index\n      // and later check if the bit is set via bit operations\n      setBit(segmentIndex);\n    }\n    \n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value =  tValue; // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue; // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }  \n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      gl_FragData[0] = getColorForValue(value, maxPosIS, tstep);\n      return;\n    }\n\n    // probably we can make this configurable but for now we will use the same\n    // sample distance as the original sample distance\n    float neighborSampleDistanceIS = sampleDistanceIS;\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    float minVoxelSpacing = min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base = vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not \n      // been seen by the center segment\n      if (!isBitSet(s)) {\n       continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have \n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out \n      // faster if we find the edge\n      bool onEdge =\n          checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s, stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than \n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety \n      // of the all the fragments inside. i.e., this happens when we zoom out, \n      if (minVoxelSpacing > (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n      \n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n            for (int j = -actualThickness; j <= actualThickness; j++) {\n                if (i == 0 && j == 0) continue; // Skip the center\n                if (abs(i) == actualThickness && abs(j) == actualThickness) continue; // Skip corners\n                if (checkOnEdgeForNeighbor(i, j, s, stepIS )) {\n                    return;\n                }\n          }\n      }\n    }\n\n    vec3 tColor0 = texture2D(ctexture, vec2(value.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(value.r * oscale0 + oshift0, height0)).r;\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\n    // now map through opacity and color\n    tColor = getColorForValue(tValue, posIS, tstep);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\n      gl_FragData[0] = tColor;\n      return;\n    }\n\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n\n      float mix = (1.0 - color.a);\n\n      // this line should not be needed but nvidia seems to not handle\n      // the break correctly on windows/chrome 58 angle\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\n\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n      stepsTraveled++;\n      posIS += stepIS;\n      if (color.a > 0.99) { color.a = 1.0; break; }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\n    {\n      posIS = endIS;\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\n  #endif\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == 1\n    #define OP max\n    #else\n    #define OP min\n    #endif\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // Update the maximum value if necessary\n      value = OP(tValue, value);\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n    value = OP(tValue, value);\n\n    // Now map through opacity and color\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\n    vec4 sum = vec4(0.);\n\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n    }\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\n      // Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n        // Sum the values across each step in the path\n        sum += tValue;\n      }\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n\n    // compute the scalar\n    tValue = getTextureValue(posIS);\n\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n\n      stepsTraveled++;\n    }\n\n    #if vtkBlendMode == 3 // Average\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 5 // RADON\n    float normalizedRayIntensity = 1.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tValue = getTextureValue(posIS);\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar value\n      tValue = getTextureValue(posIS);\n\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n\n      posIS += stepIS;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\n\n  #endif\n}\n\n//=======================================================================\n// Compute a new start and end point for a given ray based\n// on the provided bounded clipping plane (aka a rectangle)\nvoid getRayPointIntersectionBounds(\n  vec3 rayPos, vec3 rayDir,\n  vec3 planeDir, float planeDist,\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\n  float vSize1, float vSize2)\n{\n  float result = dot(rayDir, planeDir);\n  if (abs(result) < 1e-6)\n  {\n    return;\n  }\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\n  vec3 xposVC = rayPos + rayDir*result;\n  vec3 vxpos = xposVC - vOriginVC;\n  vec2 vpos = vec2(\n    dot(vxpos, vPlaneX),\n    dot(vxpos, vPlaneY));\n\n  // on some apple nvidia systems this does not work\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\n  //     vpos.y < 0.0 || vpos.y > vSize2)\n  // even just\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\n  // fails\n  // so instead we compute a value that represents in and out\n  //and then compute the return using this value\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\n\n  tbounds = mix(\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\n   tbounds, // out value\n   check);  // 0 in 1 out\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\n{\n  vec2 dists = vec2(100.0*camFar, -1.0);\n\n  vec3 vSize = vSpacing*tdims;\n\n  // all this is in View Coordinates\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0,dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick/rayDir.z;\n  dists.y = min(farDist,dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\n//=======================================================================\n// Compute the index space starting position (pos) and end\n// position\n//\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\n{\n  // compute starting and ending values in volume space\n  pos = vertexVCVSOutput + dists.x*rayDir;\n  pos = pos - vOriginVC;\n  // convert to volume basis and origin\n  pos = vec3(\n    dot(pos, vPlaneNormal0),\n    dot(pos, vPlaneNormal2),\n    dot(pos, vPlaneNormal4));\n\n  endPos = vertexVCVSOutput + dists.y*rayDir;\n  endPos = endPos - vOriginVC;\n  endPos = vec3(\n    dot(endPos, vPlaneNormal0),\n    dot(endPos, vPlaneNormal2),\n    dot(endPos, vPlaneNormal4));\n\n  float delta = length(endPos - pos);\n\n  pos *= vVCToIJK;\n  endPos *= vVCToIJK;\n\n  float delta2 = length(endPos - pos);\n  sampleDistanceIS = sampleDistance*delta2/delta;\n  #ifdef VolumeShadowOn\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\n  #endif\n}\n\nvoid main()\n{\n\n  if (cameraParallel == 1)\n  {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 tdims = vec3(volumeDimensions);\n\n  // compute the start and end points for the ray\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\n\n  // do we need to composite? aka does the ray have any length\n  // If not, bail out early\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\n  {\n    discard;\n  }\n\n  // IS = Index Space\n  vec3 posIS;\n  vec3 endIS;\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\n\n  // Perform the blending operation along the ray\n  applyBlend(posIS, endIS, tdims);\n}\n",e.Geometry=""},e.useIndependentComponents=e=>{const n=e.getIndependentComponents(),r=t.currentInput?.getPointData()?.getScalars()?.getNumberOfComponents(),o=e.getColorMixPreset();return n&&r>=2||!!o},e.replaceShaderValues=(n,r,o)=>{const a=o.getProperty();let i=n.Fragment;a.getInterpolationType()===Fg.LINEAR&&(i=yd.substitute(i,"//VTK::TrilinearOn","#define vtkTrilinearOn").result),!0===e.isLabelmapOutlineRequired(o)&&(i=yd.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result),t.renderable.getBlendMode()===zg.LABELMAP_EDGE_PROJECTION_BLEND&&(i=yd.substitute(i,"//VTK::LabelEdgeProjectionOn","#define vtkLabelEdgeProjectionOn").result);const s=t.scalarTexture.getComponents();i=yd.substitute(i,"//VTK::NumComponents",`#define vtkNumComponents ${s}`).result;const l=e.useIndependentComponents(a);l&&(i=yd.substitute(i,"//VTK::IndependentComponentsOn","#define UseIndependentComponents").result);const c=[],u=[];for(let e=0;e<s;e++)a.getOpacityMode(e)===kg.PROPORTIONAL&&c.push(`#define vtkComponent${e}Proportional`),a.getForceNearestInterpolation(e)&&u.push(`#define vtkComponent${e}ForceNearest`);i=yd.substitute(i,"//VTK::vtkProportionalComponents",c.join("\n")).result,i=yd.substitute(i,"//VTK::vtkForceNearestComponents",u.join("\n")).result;const d=function(e){switch(e){case Gg.CUSTOM:return"//VTK::CustomColorMix";case Gg.ADDITIVE:return"\n        // compute normals\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)\n          vec3 scalarInterp0[2];\n          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);\n          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;\n          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;\n          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);\n\n          vec3 scalarInterp1[2];\n          vec4 normalLight1 = computeNormalForDensity(posIS, tstep, scalarInterp1, 1);\n          scalarInterp1[0] = scalarInterp1[0] * oscale1 + oshift1;\n          scalarInterp1[1] = scalarInterp1[1] * oscale1 + oshift1;\n          normalLight1 = computeDensityNormal(scalarInterp1, height1, 1.0);\n        #else\n          vec4 normalLight0 = normalMat[0];\n          vec4 normalLight1 = normalMat[1];\n        #endif\n\n        // compute opacities\n        float opacity0 = pwfValue0;\n        float opacity1 = pwfValue1;\n        #ifdef vtkGradientOpacityOn\n          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n          opacity0 *= gof0;\n          float gof1 = computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          opacity1 *= gof1;\n        #endif\n        float opacitySum = opacity0 + opacity1;\n        if (opacitySum <= 0.0) {\n          return vec4(0.0);\n        }\n\n        // mix the colors and opacities\n        tColor0 = applyAllLightning(tColor0, opacity0, posIS, normalLight0);\n        tColor1 = applyAllLightning(tColor1, opacity1, posIS, normalLight1);\n        vec3 mixedColor = (opacity0 * tColor0 + opacity1 * tColor1) / opacitySum;\n        return vec4(mixedColor, min(1.0, opacitySum));\n";case Gg.COLORIZE:return"\n        // compute normals\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)\n          vec3 scalarInterp0[2];\n          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);\n          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;\n          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;\n          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);\n        #else\n          vec4 normalLight0 = normalMat[0];\n        #endif\n\n        // compute opacities\n        float opacity0 = pwfValue0;\n        #ifdef vtkGradientOpacityOn\n          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n          opacity0 *= gof0;\n        #endif\n\n        // mix the colors and opacities\n        vec3 color = tColor0 * mix(vec3(1.0), tColor1, pwfValue1);\n        color = applyAllLightning(color, opacity0, posIS, normalLight0);\n        return vec4(color, opacity0);\n";default:return null}}(a.getColorMixPreset());d&&(i=yd.substitute(i,"//VTK::CustomComponentsColorMixOn","#define vtkCustomComponentsColorMix").result,i=yd.substitute(i,"//VTK::CustomComponentsColorMix::Impl",d).result);const p=t.currentInput.getSpatialExtent(),f=t.currentInput.getSpacing(),g=new Float64Array(3);In(g,(p[1]-p[0])*f[0],(p[3]-p[2])*f[1],(p[5]-p[4])*f[2]);const m=Sn(g)/e.getCurrentSampleDistance(r);i=yd.substitute(i,"//VTK::MaximumSamplesValue",`${Math.ceil(m)}`).result,i=yd.substitute(i,"//VTK::LightComplexity",`#define vtkLightComplexity ${t.lightComplexity}`).result,t.lightComplexity>0&&(t.renderable.getVolumetricScatteringBlending()>0&&(i=yd.substitute(i,"//VTK::VolumeShadowOn","#define VolumeShadowOn").result),t.renderable.getVolumetricScatteringBlending()<1&&(i=yd.substitute(i,"//VTK::SurfaceShadowOn","#define SurfaceShadowOn").result),t.renderable.getLocalAmbientOcclusion()&&a.getAmbient()>0&&(i=yd.substitute(i,"//VTK::localAmbientOcclusionOn","#define localAmbientOcclusionOn").result));const h=l?s:1;t.gopacity=!1;for(let e=0;!t.gopacity&&e<h;++e)t.gopacity||=a.getUseGradientOpacity(e);t.gopacity&&(i=yd.substitute(i,"//VTK::GradientOpacityOn","#define vtkGradientOpacityOn").result),t.renderable.getComputeNormalFromOpacity()&&(i=yd.substitute(i,"//VTK::vtkComputeNormalFromOpacity","#define vtkComputeNormalFromOpacity").result),null!==t.zBufferTexture&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {","zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n","zdepth = -zdepth/rayDir.z;","dists.y = min(zdepth,dists.y);"]).result),i=yd.substitute(i,"//VTK::BlendMode",`${t.renderable.getBlendMode()}`).result,n.Fragment=i,e.replaceShaderLight(n,r,o),e.replaceShaderClippingPlane(n,r,o)},e.replaceShaderLight=(e,n,r)=>{if(0===t.lightComplexity)return;let o=e.Fragment,a=0;n.getLights().forEach((e=>{e.getSwitch()&&(a+=1)})),o=yd.substitute(o,"//VTK::Light::Dec",["uniform int lightNum;","uniform bool twoSidedLighting;",`uniform vec3 lightColor[${a}];`,`uniform vec3 lightDirectionVC[${a}]; // normalized`,`uniform vec3 lightHalfAngleVC[${a}];`,"//VTK::Light::Dec"],!1).result,3===t.lightComplexity&&(o=yd.substitute(o,"//VTK::Light::Dec",[`uniform vec3 lightPositionVC[${a}];`,`uniform vec3 lightAttenuation[${a}];`,`uniform float lightConeAngle[${a}];`,`uniform float lightExponent[${a}];`,`uniform int lightPositional[${a}];`],!1).result),t.renderable.getVolumetricScatteringBlending()>0&&(o=yd.substitute(o,"//VTK::VolumeShadow::Dec",["uniform float volumetricScatteringBlending;","uniform float giReach;","uniform float volumeShadowSamplingDistFactor;","uniform float anisotropy;","uniform float anisotropy2;"],!1).result),t.renderable.getLocalAmbientOcclusion()&&r.getProperty().getAmbient()>0&&(o=yd.substitute(o,"//VTK::LAO::Dec",["uniform int kernelRadius;",`uniform vec2 kernelSample[${t.renderable.getLAOKernelRadius()}];`,"uniform int kernelSize;"],!1).result),e.Fragment=o},e.replaceShaderClippingPlane=(e,n,r)=>{let o=e.Fragment;if(t.renderable.getClippingPlanes().length>0){const e=t.renderable.getClippingPlanes().length;o=yd.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=yd.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${e}; i++) {`,"  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result}e.Fragment=o},e.getNeedToRebuildShaders=(n,r,o)=>{const a=o.getProperty();((n,r)=>{let o=0;n.getProperty().getShade()&&t.renderable.getBlendMode()===zg.COMPOSITE_BLEND&&(o=0,t.numberOfLights=0,r.forEach((e=>{e.getSwitch()>0&&(t.numberOfLights++,0===o&&(o=1)),1===o&&(t.numberOfLights>1||1!==e.getIntensity()||!e.lightTypeIsHeadLight())&&(o=2),o<3&&e.getPositional()&&(o=3)}))),o!==t.lightComplexity&&(t.lightComplexity=o,e.modified())})(o,r.getLights());const i=t.scalarTexture.getComponents(),s=[],l=[];for(let e=0;e<i;e++)s.push(a.getOpacityMode(e)),l.push(a.getForceNearestInterpolation(e));const c=t.currentInput.getSpatialExtent(),u=t.currentInput.getSpacing(),d=new Float64Array(3);In(d,(c[1]-c[0])*u[0],(c[3]-c[2])*u[1],(c[5]-c[4])*u[2]);const p=Sn(d)/e.getCurrentSampleDistance(r),f=!!t.zBufferTexture,g={iComps:a.getIndependentComponents(),colorMixPreset:a.getColorMixPreset(),interpolationType:a.getInterpolationType(),useLabelOutline:e.isLabelmapOutlineRequired(o),numComp:i,maxSamples:p,useGradientOpacity:a.getUseGradientOpacity(0),blendMode:t.renderable.getBlendMode(),hasZBufferTexture:f,opacityModes:s,forceNearestInterps:l};return(0===n.getProgram()?.getHandle()||n.getShaderSourceTime().getMTime()<e.getMTime()||n.getShaderSourceTime().getMTime()<t.renderable.getMTime()||!t.previousState||!ke()(t.previousState,g))&&(t.previousState=g,!0)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexDC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexDC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||jg("Error setting vertexDC in shader VAO.")),n.getAttributeUpdateTime().modified()),a.setUniformi("texture1",t.scalarTexture.getTextureUnit()),a.setUniformf("sampleDistance",e.getCurrentSampleDistance(r));const i=t.scalarTexture.getVolumeInfo(),s=t.renderable.getIpScalarRange();if(i?.dataComputedScale?.length){const e=[],t=[];for(let n=0;n<4;n++)e[n]=s[0]*i.dataComputedScale[n]+i.dataComputedOffset[n],t[n]=s[1]*i.dataComputedScale[n]+i.dataComputedOffset[n],e[n]=(e[n]-i.offset[n])/i.scale[n],t[n]=(t[n]-i.offset[n])/i.scale[n];a.setUniform4f("ipScalarRangeMin",e[0],e[1],e[2],e[3]),a.setUniform4f("ipScalarRangeMax",t[0],t[1],t[2],t[3])}if(null!==t.zBufferTexture){a.setUniformi("zBufferTexture",t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf("vpZWidth",e[0]),a.setUniformf("vpZHeight",e[1])}},e.setCameraShaderParameters=(n,r,o)=>{const a=t.openGLCamera.getKeyMatrices(r),i=t.openGLVolume.getKeyMatrices();T(t.modelToView,a.wcvc,i.mcwc);const s=n.getProgram(),l=t.openGLCamera.getRenderable(),c=l.getClippingRange();s.setUniformf("camThick",c[1]-c[0]),s.setUniformf("camNear",c[0]),s.setUniformf("camFar",c[1]);const u=t.currentInput.getBounds(),d=t.currentInput.getDimensions(),p=new Float64Array(3),f=new Float64Array(3);let g=1,m=-1,v=1,y=-1;for(let e=0;e<8;++e)In(p,u[e%2],u[2+Math.floor(e/2)%2],u[4+Math.floor(e/4)]),Vn(p,p,t.modelToView),l.getParallelProjection()||(Mn(f,p),On(p,f,-c[0]/p[2])),Vn(p,p,a.vcpc),g=Math.min(p[0],g),m=Math.max(p[0],m),v=Math.min(p[1],v),y=Math.max(p[1],y);s.setUniformf("dcxmin",g),s.setUniformf("dcxmax",m),s.setUniformf("dcymin",v),s.setUniformf("dcymax",y),s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",l.getParallelProjection());const b=t.currentInput.getSpatialExtent(),x=t.currentInput.getSpacing(),C=new Float64Array(3);In(C,(b[1]-b[0])*x[0],(b[3]-b[2])*x[1],(b[5]-b[4])*x[2]),s.setUniform3f("vSpacing",x[0],x[1],x[2]),In(p,b[0],b[2],b[4]),t.currentInput.indexToWorldVec3(p,p),Vn(p,p,t.modelToView),s.setUniform3f("vOriginVC",p[0],p[1],p[2]);const S=t.currentInput.getIndexToWorld();T(t.idxToView,t.modelToView,S),ve(t.idxNormalMatrix,a.normalMatrix,i.normalMatrix),ve(t.idxNormalMatrix,t.idxNormalMatrix,t.currentInput.getDirectionByReference());const A=Sn(C)/e.getCurrentSampleDistance(r);A>t.renderable.getMaximumSamplesPerRay()&&Hg(`The number of steps required ${Math.ceil(A)} is larger than the\n        specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples.`);const I=new Float64Array(3);if(In(I,1,1,1),function(e,t,n){e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2]}(I,I,C),s.setUniform3f("vVCToIJK",I[0],I[1],I[2]),s.setUniform3i("volumeDimensions",d[0],d[1],d[2]),s.setUniform3f("volumeSpacings",x[0],x[1],x[2]),!t._openGLRenderWindow.getWebgl2()){const e=t.scalarTexture.getVolumeInfo();s.setUniformf("texWidth",t.scalarTexture.getWidth()),s.setUniformf("texHeight",t.scalarTexture.getHeight()),s.setUniformi("xreps",e.xreps),s.setUniformi("xstride",e.xstride),s.setUniformi("ystride",e.ystride)}const w=new Float64Array(3),P=new Float64Array(3);for(let e=0;e<6;++e){switch(e){case 1:In(w,-1,0,0),In(P,b[0],b[2],b[4]);break;case 2:In(w,0,1,0),In(P,b[1],b[3],b[5]);break;case 3:In(w,0,-1,0),In(P,b[0],b[2],b[4]);break;case 4:In(w,0,0,1),In(P,b[1],b[3],b[5]);break;case 5:In(w,0,0,-1),In(P,b[0],b[2],b[4]);break;default:In(w,1,0,0),In(P,b[1],b[3],b[5])}Ln(w,w,t.idxNormalMatrix),Vn(P,P,t.idxToView);const n=-1*En(P,w);s.setUniform3f(`vPlaneNormal${e}`,w[0],w[1],w[2]),s.setUniformf(`vPlaneDistance${e}`,n)}if(e.isLabelmapOutlineRequired(o)){const n=t.currentInput.getWorldToIndex();s.setUniformMatrix("vWCtoIDX",n);const o=r.getActiveCamera(),[a,i]=o.getClippingRange(),l=o.getDistance();o.setClippingRange(l,l+.1);const c=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,c.wcpc),o.setClippingRange(a,i),t.openGLCamera.getKeyMatrices(r),s.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const u=e.getRenderTargetSize();s.setUniformf("vpWidth",u[0]),s.setUniformf("vpHeight",u[1]);const d=e.getRenderTargetOffset();s.setUniformf("vpOffsetX",d[0]/u[0]),s.setUniformf("vpOffsetY",d[1]/u[1])}if(h(t.projectionToView,a.vcpc),s.setUniformMatrix("PCVCMatrix",t.projectionToView),0===t.lightComplexity)return;let O=0;const R=[],M=[],E=[];if(r.getLights().forEach((e=>{if(e.getSwitch()>0){const t=e.getColor(),n=e.getIntensity();R[0+3*O]=t[0]*n,R[1+3*O]=t[1]*n,R[2+3*O]=t[2]*n;const r=e.getDirection();In(w,r[0],r[1],r[2]),Ln(w,w,a.normalMatrix),Mn(w,w),M[0+3*O]=w[0],M[1+3*O]=w[1],M[2+3*O]=w[2],E[0+3*O]=-.5*w[0],E[1+3*O]=-.5*w[1],E[2+3*O]=-.5*(w[2]-1),O++}})),s.setUniformi("twoSidedLighting",r.getTwoSidedLighting()),s.setUniformi("lightNum",O),s.setUniform3fv("lightColor",R),s.setUniform3fv("lightDirectionVC",M),s.setUniform3fv("lightHalfAngleVC",E),3===t.lightComplexity){O=0;const e=[],n=[],o=[],a=[],i=[];r.getLights().forEach((r=>{if(r.getSwitch()>0){const s=r.getAttenuationValues();n[0+3*O]=s[0],n[1+3*O]=s[1],n[2+3*O]=s[2],a[O]=r.getExponent(),o[O]=r.getConeAngle(),i[O]=r.getPositional();const l=r.getTransformedPosition();Vn(l,l,t.modelToView),e[0+3*O]=l[0],e[1+3*O]=l[1],e[2+3*O]=l[2],O+=1}})),s.setUniform3fv("lightPositionVC",e),s.setUniform3fv("lightAttenuation",n),s.setUniformfv("lightConeAngle",o),s.setUniformfv("lightExponent",a),s.setUniformiv("lightPositional",i)}if(t.renderable.getVolumetricScatteringBlending()>0&&(s.setUniformf("giReach",t.renderable.getGlobalIlluminationReach()),s.setUniformf("volumetricScatteringBlending",t.renderable.getVolumetricScatteringBlending()),s.setUniformf("volumeShadowSamplingDistFactor",t.renderable.getVolumeShadowSamplingDistFactor()),s.setUniformf("anisotropy",t.renderable.getAnisotropy()),s.setUniformf("anisotropy2",t.renderable.getAnisotropy()**2)),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0){const e=t.renderable.getLAOKernelSize();s.setUniformi("kernelSize",e);const n=[];for(let t=0;t<e;t++)n[2*t]=.5*Math.random(),n[2*t+1]=.5*Math.random();s.setUniform2fv("kernelSample",n),s.setUniformi("kernelRadius",t.renderable.getLAOKernelRadius())}},e.setPropertyShaderParameters=(n,r,o)=>{const a=n.getProgram();a.setUniformi("ctexture",t.colorTexture.getTextureUnit()),a.setUniformi("otexture",t.opacityTexture.getTextureUnit()),a.setUniformi("jtexture",t.jitterTexture.getTextureUnit()),a.setUniformi("ttexture",t.labelOutlineThicknessTexture.getTextureUnit());const i=t.scalarTexture.getVolumeInfo(),s=o.getProperty(),l=t.scalarTexture.getComponents(),c=e.useIndependentComponents(s);if(c)for(let e=0;e<l;e++)a.setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));for(let e=0;e<l;e++){const t=c?e:0,n=i.scale[e],r=s.getScalarOpacity(t).getRange(),o=n/(r[1]-r[0]),l=(i.offset[e]-r[0])/(r[1]-r[0]);a.setUniformf(`oshift${e}`,l),a.setUniformf(`oscale${e}`,o);const u=s.getRGBTransferFunction(t).getRange(),d=(i.offset[e]-u[0])/(u[1]-u[0]),p=n/(u[1]-u[0]);a.setUniformf(`cshift${e}`,d),a.setUniformf(`cscale${e}`,p)}if(t.gopacity)if(c)for(let e=0;e<l;++e){const t=i.scale[e];if(s.getUseGradientOpacity(e)){const n=s.getGradientOpacityMinimumOpacity(e),r=s.getGradientOpacityMaximumOpacity(e);a.setUniformf(`gomin${e}`,n),a.setUniformf(`gomax${e}`,r);const o=[s.getGradientOpacityMinimumValue(e),s.getGradientOpacityMaximumValue(e)];a.setUniformf(`goscale${e}`,t*(r-n)/(o[1]-o[0])),a.setUniformf(`goshift${e}`,-o[0]*(r-n)/(o[1]-o[0])+n)}else a.setUniformf(`gomin${e}`,1),a.setUniformf(`gomax${e}`,1),a.setUniformf(`goscale${e}`,0),a.setUniformf(`goshift${e}`,1)}else{const e=i.scale[l-1],t=s.getGradientOpacityMinimumOpacity(0),n=s.getGradientOpacityMaximumOpacity(0);a.setUniformf("gomin0",t),a.setUniformf("gomax0",n);const r=[s.getGradientOpacityMinimumValue(0),s.getGradientOpacityMaximumValue(0)];a.setUniformf("goscale0",e*(n-t)/(r[1]-r[0])),a.setUniformf("goshift0",-r[0]*(n-t)/(r[1]-r[0])+t)}if(!0===e.isLabelmapOutlineRequired(o)){const e=o.getProperty().getLabelOutlineOpacity();a.setUniformf("outlineOpacity",e)}t.lightComplexity>0&&(a.setUniformf("vAmbient",s.getAmbient()),a.setUniformf("vDiffuse",s.getDiffuse()),a.setUniformf("vSpecular",s.getSpecular()),a.setUniformf("vSpecularPower",s.getSpecularPower()))},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();Ln(t,t,r.normalMatrix),Vn(n,n,r.wcvc);const l=-1*En(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv("vClipPlaneNormals",o),c.setUniformfv("vClipPlaneDistances",a),c.setUniform3fv("vClipPlaneOrigins",i),c.setUniformi("clip_numPlanes",l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),(()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n&&n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===Fg.NEAREST?(t.scalarTexture.setMinificationFilter(Rd.NEAREST),t.scalarTexture.setMagnificationFilter(Rd.NEAREST)):(t.scalarTexture.setMinificationFilter(Rd.LINEAR),t.scalarTexture.setMagnificationFilter(Rd.LINEAR)),null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context;t.scalarTexture.activate(),t.opacityTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.colorTexture.activate(),t.jitterTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.scalarTexture.deactivate(),t.colorTexture.deactivate(),t.opacityTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.jitterTexture.deactivate()},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"),"");const e=t.copyShader;t.copyVAO=Cd.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||jg("Error setting vertexDC in copy shader VAO.")}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi("texture",n.getTextureUnit()),t.copyShader.setUniform2f("tfactor",t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):jg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.Bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.scalarTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=r.getProperty();if(!t.jitterTexture.getHandle()){const e=new Uint8Array(1024);for(let t=0;t<1024;++t)e[t]=255*Math.random();t.jitterTexture.setMinificationFilter(Rd.LINEAR),t.jitterTexture.setMagnificationFilter(Rd.LINEAR),t.jitterTexture.create2DFromRaw(32,32,1,Cs.UNSIGNED_CHAR,e)}const s=a.getNumberOfComponents(),l=e.useIndependentComponents(i),c=l?s:1,u=i.getScalarOpacity(),d=t._openGLRenderWindow.getGraphicsResourceForObject(u);let p=cg(u,l,c);if(d?.oglObject&&d.hash===p)t.opacityTexture=d.oglObject;else{t.opacityTexture=Kd.newInstance(),t.opacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const r=1024,o=2*r*c,a=new Float32Array(o),s=new Float32Array(r);for(let t=0;t<c;++t){const o=i.getScalarOpacity(t),l=e.getCurrentSampleDistance(n)/i.getScalarOpacityUnitDistance(t),c=o.getRange();o.getTable(c[0],c[1],r,s,1);for(let e=0;e<r;++e)a[t*r*2+e]=1-(1-s[e])**l,a[t*r*2+e+r]=a[t*r*2+e]}if(t.opacityTexture.resetFormatAndType(),t.opacityTexture.setMinificationFilter(Rd.LINEAR),t.opacityTexture.setMagnificationFilter(Rd.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))t.opacityTexture.create2DFromRaw(r,2*c,1,Cs.FLOAT,a);else{const e=new Uint8ClampedArray(o);for(let t=0;t<o;++t)e[t]=255*a[t];t.opacityTexture.create2DFromRaw(r,2*c,1,Cs.UNSIGNED_CHAR,e)}u&&(t._openGLRenderWindow.setGraphicsResourceForObject(u,t.opacityTexture,p),u!==t._scalarOpacityFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(u,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalarOpacityFunc,e)),t._scalarOpacityFunc=u)}const f=i.getRGBTransferFunction();p=cg(f,l,c);const g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g?.hash===p)t.colorTexture=g.oglObject;else{t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,r=new Uint8ClampedArray(2*n*c*3),o=new Float32Array(3*n);for(let e=0;e<c;++e){const t=i.getRGBTransferFunction(e),a=t.getRange();t.getTable(a[0],a[1],n,o,1);for(let t=0;t<3*n;++t)r[e*n*6+t]=255*o[t],r[e*n*6+t+3*n]=255*o[t]}t.colorTexture.resetFormatAndType(),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.create2DFromRaw(n,2*c,3,Cs.UNSIGNED_CHAR,r),f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,p),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}e.updateLabelOutlineThicknessTexture(r);const m=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(p=ug(o,a),m?.oglObject?.getHandle()&&m?.hash===p)t.scalarTexture=m.oglObject;else{t.scalarTexture=Kd.newInstance(),t.scalarTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.scalarTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.scalarTexture.resetFormatAndType(),t.scalarTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],a,t.renderable.getPreferSizeOverAccuracy()),a&&(t._openGLRenderWindow.setGraphicsResourceForObject(a,t.scalarTexture,p),a!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(a,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=a)}if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Ns.newInstance({numberOfComponents:3,values:e});r.setName("points");const o=Ns.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,"polys",ss.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()},e.updateLabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThickness(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{t.labelOutlineThicknessTexture=Kd.newInstance(),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(n,o,1,Cs.UNSIGNED_CHAR,i),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.isLabelmapOutlineRequired=e=>{const n=e.getProperty(),r=t.renderable;return n.getUseLabelOutline()||r.getBlendMode()===zg.LABELMAP_EDGE_PROJECTION_BLEND}}const $g={context:null,VBOBuildTime:null,scalarTexture:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};const qg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$g,n),Zt.extend(e,t,n),Yd(e,t,n),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.tris=Pd.newInstance(),t.jitterTexture=Kd.newInstance(),t.jitterTexture.setWrapS(Od.REPEAT),t.jitterTexture.setWrapT(Od.REPEAT),t.framebuffer=ef.newInstance(),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),At(e,t,["context"]),Kg(e,t)}),"vtkOpenGLVolumeMapper");rn("vtkVolumeMapper",qg);const{vtkDebugMacro:Xg}=Kt;function Yg(e,t){t.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():Xg("No framebuffer to save/restore");const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}const Zg={};const Qg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zg,n),Zt.extend(e,t,n),Yg(e,t)}),"vtkOpenGLPixelSpaceCallbackMapper");rn("vtkPixelSpaceCallbackMapper",Qg);var Jg="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtktextureObjectVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\nattribute vec2 tcoordDC;\nvarying vec2 tcoordVC;\n\nvoid main()\n{\n  tcoordVC = tcoordDC;\n  gl_Position = vertexDC;\n}\n";const{Representation:em}=ms;function tm(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Kd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw(o,a,4,"Float32Array",null),s.activate(),s.sendParameters(),s.deactivate(),s}function nm(e,t){return tm(e,t,Kd.Filter.NEAREST,Kd.Wrap.CLAMP_TO_EDGE)}function rm(e,t){t.classHierarchy.push("vtkLICPingPongBufferManager"),t._openGLRenderWindow?(t.quad=function(e){const t=Pd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ns.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ns.newInstance({numberOfComponents:1,values:o}),s=Ns.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",em.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=nm(t._openGLRenderWindow,t.size),t.seedTexture0=nm(t._openGLRenderWindow,t.size),t.licTexture1=nm(t._openGLRenderWindow,t.size),t.seedTexture1=nm(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?tm(t._openGLRenderWindow,t.size,Kd.Filter.NEAREST,Kd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?function(e,t){return tm(e,t,Kd.Filter.LINEAR,Kd.Wrap.CLAMP_TO_EDGE)}(t._openGLRenderWindow,t.size):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=Cd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return 0===e?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error("Wrong LIC pass number")}},e.deactivateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error("Wrong LIC pass number")}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error("Pass renderwindow to ping pong manager")}const om={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function am(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,om,n),jt.obj(e,t),jt.get(e,t,["readIndex"]),jt.setGet(e,t,["doEEPass","doVTPass","_openGLRenderWindow","vectorTexture","maskVectorTexture","noiseTexture","framebuffer","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),rm(e,t)}var im={newInstance:jt.newInstance(am,"vtkLICPingPongBufferManager"),extend:am};const sm=0,lm=1,cm=2,um=3,dm=1;function pm(e,t){function n(e,t){e.setUniformi("texLIC",t.getLICTextureUnit()),e.setUniformi("texSeedPts",t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push("vtkLineIntegralConvolution2D"),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Jg,e,""),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=ef.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t="xyzw";return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n/**\nThis shader initializes the convolution for the LIC computation.\n*/\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texMaskVectors;\nuniform sampler2D texNoise;\nuniform sampler2D texLIC;\n\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the *whole* domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value. this\n// depends on the pass number.\nvec2 getNoiseTC(vec2 vectc)\n{\n  // in pass 1 : convert from vector tc to noise tc\n  // in pass 2 : use vector tc\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(vectc);\n    }\n  else\n    {\n    return vectc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the\n// need to convert to noise texture coordinates.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\nvoid main(void)\n{\n  vec2 vectc = tcoordVC.st;\n\n  // lic => (convolution, mask, 0, step count)\n  if (uStepNo == 0)\n    {\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\n    float maskFlag;\n    if (maskCriteria <= uMaskThreshold)\n      {\n      maskFlag = 1.0;\n      }\n    else\n      {\n      maskFlag = 0.0;\n      }\n    float noise = getNoise(vectc);\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\n    }\n  else\n    {\n    LICOutput = texture2D(texLIC, vectc);\n    }\n\n  // initial seed\n  SeedOutput = vec4(vectc, 0.0, 1.0);\n}\n");const n=yd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// move vector field to normalized image space\n// pre-processing for vtkLineIntegralConvolution2D\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Fragment shader used by the gaussian blur filter render pass.\n\nuniform sampler2D texVectors; // input texture\nuniform vec2      uTexSize;   // size of texture\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  //VTK::LICComponentSelection::Impl\n  V = V/uTexSize;\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\n}\n","//VTK::LICComponentSelection::Impl",`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=yd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D  texVectors;\nuniform sampler2D  texNoise;\nuniform sampler2D  texLIC;\nuniform sampler2D  texSeedPts;\n\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\nuniform float uStepSize;        // step size in parametric space\n\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n//VTK::LICVectorLookup::Impl\n\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\n// are very poorly supported in webgl\nvec2 clampToBorder(vec2 uv){\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n  {\n    return vec2(0.0, 0.0);\n  }\n  return getVector(uv);\n}\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the whole domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value.\n// in pass 1 repeatedly tile the noise texture across\n// the computational domain.\nvec2 getNoiseTC(vec2 tc)\n{\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(tc);\n    }\n  else\n    {\n    return tc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the need\n// to convert to either noise or lic texture coordinates in\n// pass 1 and 2 respectively.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\n// fourth-order Runge-Kutta streamline integration\n// no bounds checks are made, therefore it's essential\n// to have the entire texture initialized to 0\n// and set clamp to border and have border color 0\n// an integer is set if the step was taken, keeping\n// an accurate step count is necessary to prevent\n// boundary artifacts. Don't count the step if\n// all vector lookups are identically 0. This is\n// a proxy for \"stepped outside valid domain\"\nvec2 rk4(vec2 pt0, float dt, out bool count)\n{\n  count=true;\n  float dtHalf = dt * 0.5;\n  vec2 pt1;\n\n  vec2 v0 = clampToBorder(pt0);\n  pt1 = pt0 + v0 * dtHalf;\n\n  vec2 v1 = clampToBorder(pt1);\n  pt1 = pt0 + v1 * dtHalf;\n\n  vec2 v2 = clampToBorder(pt1);\n  pt1 = pt0 + v2 * dt;\n\n  vec2 v3 = clampToBorder(pt1);\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\n\n  if (vSum == vec2(0.0, 0.0))\n    {\n      count = false;\n    }\n\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\n\n return pt1;\n}\n\nvoid main(void)\n{\n  vec2 lictc = tcoordVC.st;\n  vec4 lic = texture2D(texLIC, lictc);\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\n\n  bool count;\n  vec2 pt1 = rk4(pt0, uStepSize, count);\n\n  if (count)\n    {\n    // accumulate lic step\n    // (lic, mask, 0, step count)\n    float noise = getNoise(pt1);\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\n    SeedOutput = vec4(pt1, 0.0, 1.0);\n    }\n  else\n    {\n    // keep existing values\n    LICOutput = lic;\n    SeedOutput = vec4(pt0, 0.0, 1.0);\n    }\n}\n","//VTK::LICVectorLookup::Impl",function(){const e="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      vec2 V = texture2D( texVectors, vectc ).xy;\n\n      // normalize if |V| not 0\n\n      float lenV = length( V );\n\n      if ( lenV > 1.0e-8 )\n\n        {\n\n        return V/lenV;\n\n        }\n\n      else\n\n        {\n\n        return vec2( 0.0, 0.0 );\n\n        }\n\n      }\n\n    ",t="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      return texture2D( texVectors, vectc ).xy;\n\n      }\n\n    ";return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?t:e}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(" //VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n/**\nThis shader finalizes the convolution for the LIC computation\napplying the normalization. eg. if box kernel is used the this\nis the number of steps taken.\n*/\n\nuniform sampler2D texLIC;\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\n  conv.r = conv.r/conv.a;\n  // lic => (convolution, mask, 0, 1)\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.CEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// gray scale contrast enhance stage implemented via histogram stretching\n// if the min and max are tweaked it can generate out-of-range values\n// these will be clamped in 0 to 1\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n\nuniform sampler2D texLIC;  // most recent lic pass\nuniform float uMin;        // min gray scale color value\nuniform float uMaxMinDiff; // max-min\n\nin vec2 tcoordVC;\n\nvoid main( void )\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g!=0.0)\n    {\n    LICOutput = lic;\n    }\n  else\n    {\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\n    LICOutput = vec4(CElic, lic.gb, 1.0);\n    }\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.EEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\n// noise for pass2.\n\n// the output of this shader\nlayout(location = 0) out vec4 EEOutput;\n\nuniform sampler2D texLIC; // most recent lic pass\nuniform float     uDx;    // fragment size\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n// kernel for simple laplace edge enhancement.\n// p=Laplace(p)+p\nfloat K[9] = float[9](\n  -1.0, -1.0, -1.0,\n  -1.0,  9.0, -1.0,\n  -1.0, -1.0, -1.0\n  );\n\n// determine if the fragment was masked\nbool Masked(float val) { return val != 0.0; }\n\nvoid main(void)\n{\n  // tex coord neighbor offsets\n  vec2 fragDx[9] = vec2[9](\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\n    );\n\n  vec2 lictc = tcoordVC.st;\n\n  // compute the convolution but don't use convovled values if\n  // any masked fragments on the stencil. Fragments outside\n  // the valid domain are masked during initialization, and\n  // texture wrap parameters are clamp to border with border\n  // color that contains masked flag\n  float conv = 0.0;\n  bool dontUse = false;\n  for (int i=0; i<9; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    vec4 lic = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic.g);\n    conv = conv + K[i] * lic.r;\n    }\n\n  if (dontUse)\n    {\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\n    }\n  else\n    {\n    conv = clamp(conv, 0.0, 1.0);\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\n    }\n\n}\n"),t.AAHProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// horizontal pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDx;    // fragment size\n\nin vec2 tcoordVC;\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.AAVProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// vertical pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\n\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDy[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n")},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;const g=f?.getSize();f&&g&&o[0]===g&&o[1]===g||(f=ef.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=im.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const m=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],h=1/o[0],v=1/o[1],y=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;y.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f("uTexSize",...o),e.setUniformi("texVectors",t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:T}=t;y.readyShaderProgram(T),T.setUniformi("uStepNo",0),T.setUniformi("uPassNo",0),T.setUniformf("uMaskThreshold",t.maskThreshold),T.setUniform2f("uNoiseBoundsPt1",...m),T.setUniformi("texMaskVectors",t.bufs.getMaskVectorTextureUnit()),T.setUniformi("texLIC",t.bufs.getLICTextureUnit()),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,T);const{LICIShaderProgram:b}=t;y.readyShaderProgram(b),b.setUniformi("uPassNo",0),b.setUniformf("uStepSize",-d),b.setUniform2f("uNoiseBoundsPt1",...m),b.setUniformi("texVectors",t.bufs.getImageVectorTextureUnit()),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);y.readyShaderProgram(T),T.setUniformi("uStepNo",1),n(T,t.bufs),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:x}=t;if(y.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),r(t.bufs,o,x),t.enhancedLIC){t.enhanceContrast!==lm&&t.enhanceContrast!==um||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;y.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDx",h),a.setUniformf("uDy",v),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),y.readyShaderProgram(T),T.setUniformi("uStepNo",0),T.setUniformi("uPassNo",1),n(T,t.bufs),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformi("uPassNo",1),b.setUniformf("uStepSize",-d),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);y.readyShaderProgram(T),T.setUniformi("uStepNo",1),n(T,t.bufs),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),y.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),x.setUniformi("texSeedPts",t.bufs.getSeedTextureUnit()),r(t.bufs,o,x)}if(t.antiAlias){const e=t.AAHProgram;y.readyShaderProgram(e),e.setUniformi("texLIC",t.bufs.getLICTextureUnit()),e.setUniformf("uDx",h);const a=t.AAVProgram;y.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDy",v);for(let i=0;i<t.antiAlias;++i)y.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),y.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==lm&&t.enhanceContrast!==um||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error("Invalid color range: ",i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi("texLIC",t.bufs.getLICTextureUnit()),c.setUniformf("uMin",i),c.setUniformf("uMaxMinDiff",l),r(t.bufs,o,c)}}const fm={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function gm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fm,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","nuberOfSteps","stepSize","normalizeVectors","maskThreshold","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","componentIds","isComposite"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),pm(e,t)}var mm={newInstance:jt.newInstance(gm,"vtkLineIntegralConvolution2D"),extend:gm};function hm(e,t){t.classHierarchy.push("vtkSurfaceLICInterface")}const vm={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:sm,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:dm,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function ym(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vm,n),jt.obj(e,t),jt.setGet(e,t,["enableLIC","numberOfSteps","stepSize","normalizeVectors","transformVectors","maskOnSurface","maskThreshold","maskColor","maskIntensity","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor","antiAlias","colorMode","LICIntensity","mapModeBias","noiseTextureSize","noiseTextureType","noiseGrainSize","minNoiseValue","maxNoiseValue","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","noiseGeneratorSeed","viewPortScale","rebuildNoiseTexture"]),hm(0,t)}var Tm={newInstance:jt.newInstance(ym,"vtkSurfaceLICInterface"),extend:ym};const{Representation:bm}=ms;function xm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICInterface"),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=Cd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),ho()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get("noiseTextureType","noiseGrainSize","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","minNoiseValue","maxNoiseValue");n=r===dm?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Kd.newInstance({wrapS:Kd.Wrap.REPEAT,wrapT:Kd.Wrap.REPEAT,minificationFilter:Kd.Filter.NEAREST,magnificationFilter:Kd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw(e,e,4,"Float32Array",d),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Jg,e,""),e.allocateTextures=()=>{const n=Kd.Filter.NEAREST,r=Kd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Kd.newInstance({wrapS:Kd.Wrap.CLAMP_TO_EDGE,wrapT:Kd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw(...t.size,4,"Float32Array",null),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Kd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw(...t.size,"Float32Array",null),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=ef.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader combines surface geometry, LIC, and  scalar colors.\n\n// the output of this shader\nlayout(location = 0) out vec4 RGBOutput;\nlayout(location = 1) out vec4 HSLOutput;\n\nuniform sampler2D texVectors;       // vectors, depth\nuniform sampler2D texGeomColors;    // scalar colors + lighting\nuniform sampler2D texLIC;           // image lic\nuniform int       uScalarColorMode; // select between blend, and map shader\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\nuniform float     uMaskIntensity;   // blending factor for mask color\nuniform vec3      uMaskColor;       // color for the masked out fragments\n\nin vec2 tcoordVC;\n\n/**\nConvert from RGB color space into HSL colorspace.\n*/\nvec3 RGBToHSL(vec3 RGB)\n{\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\n\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\n  float RGBMaxMinDiff = RGBMax - RGBMin;\n\n  HSL.z = (RGBMax + RGBMin) / 2.0;\n\n  if (RGBMaxMinDiff == 0.0)\n    {\n    // Gray scale\n    HSL.x = 0.0;\n    HSL.y = 0.0;\n    }\n  else\n    {\n    // Color\n    if (HSL.z < 0.5)\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\n    else\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\n\n    float dR\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dG\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dB\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n\n    if (RGB.r == RGBMax)\n      HSL.x = dB - dG;\n    else\n    if (RGB.g == RGBMax)\n      HSL.x = (1.0 / 3.0) + dR - dB;\n    else\n    if (RGB.b == RGBMax)\n      HSL.x = (2.0 / 3.0) + dG - dR;\n\n    if (HSL.x < 0.0)\n      HSL.x += 1.0;\n\n    if (HSL.x > 1.0)\n      HSL.x -= 1.0;\n    }\n\n  return HSL;\n}\n\n/**\nHelper for HSL to RGB conversion.\n*/\nfloat Util(float v1, float v2, float vH)\n{\n  if (vH < 0.0)\n    vH += 1.0;\n\n  if (vH > 1.0)\n     vH -= 1.0;\n\n  if ((6.0 * vH) < 1.0)\n    return (v1 + (v2 - v1) * 6.0 * vH);\n\n  if ((2.0 * vH) < 1.0)\n    return (v2);\n\n  if ((3.0 * vH) < 2.0)\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\n\n  return v1;\n}\n\n/**\nConvert from HSL space into RGB space.\n*/\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  if (HSL.y == 0.0)\n    {\n    // Gray\n    RGB.r = HSL.z;\n    RGB.g = HSL.z;\n    RGB.b = HSL.z;\n    }\n  else\n    {\n    // Chromatic\n    float v2;\n    if (HSL.z < 0.5)\n      v2 = HSL.z * (1.0 + HSL.y);\n    else\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\n\n    float v1 = 2.0 * HSL.z - v2;\n\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\n    RGB.g = Util(v1, v2, HSL.x);\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\n    }\n\n  return RGB.rgb;\n}\n\nvoid main()\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n\n  // depth is used to determine which fragment belong to us\n  // and we can change\n  float depth = texture2D(texVectors, tcoordVC.st).a;\n\n  vec3 fragColorRGB;\n  float valid;\n  if (depth > 1.0e-3)\n    {\n    // we own it\n    // shade LIC'ed geometry, or apply mask\n    if (lic.g!=0.0)\n      {\n      // it's masked\n      // apply fragment mask\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\n      valid = 0.0;\n      }\n    else\n      {\n      if (uScalarColorMode==0)\n        {\n        // blend with scalars\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\n        }\n      else\n        {\n        // multiply with scalars\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\n        }\n      if (lic.b != 0.0)\n        {\n        // didn't have the required guard pixels\n        // don't consider it in min max estimation\n        // for histpgram stretching\n        valid = 0.0;\n        }\n      else\n        {\n        // ok to use in min/max estimates for histogram\n        // stretching\n        valid = 1.0;\n        }\n      }\n    }\n  else\n    {\n    // we don't own it\n    // pass through scalars\n    fragColorRGB = geomColor.rgb;\n    valid = 0.0;\n    }\n\n  // if no further stages this texture is\n  // copied to the screen\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\n\n  // if further stages, move to hsl space for contrast\n  // enhancement. encoding validity saves moving a texture to the cpu\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\n  HSLOutput = vec4(fragColorHSL, valid);\n}\n"),t.licCopyPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader copies fragments and depths to the output buffer\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texDepth;     // z values from vertex shader\nuniform sampler2D texRGBColors; // final rgb LIC colors\n\nin vec2 tcoordVC;\n\nvoid main()\n{\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\n\n  // since we render a screen aligned quad\n  // we're going to be writing fragments\n  // not touched by the original geometry\n  // it's critical not to modify those\n  // fragments.\n  if (gl_FragDepth == 1.0)\n    {\n    discard;\n    }\n}\n"),t.enhanceContrastPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// color contrast enhance stage implemented via histogram stretching\n// on lightness channel. if the min and max are tweaked it can generate\n// out-of-range values these will be clamped in 0 to 1\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texGeomColors; // scalars + lighting\nuniform sampler2D texLIC;        // image lic, mask\nuniform sampler2D texHSLColors;  // hsla colors\n\nuniform float     uLMin;         // min lightness over all fragments\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\n\nin vec2 tcoordVC;\n\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  float v;\n  float h = HSL.x;\n  float sl = HSL.y;\n  float l = HSL.z;\n\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\n  if (v <= 0.0) {\n    RGB = vec3(0.0,0.0,0.0);\n  } else {\n    float m;\n    int sextant;\n    float fract, vsf, mid1, mid2;\n\n    m = l + l - v;\n    h *= 6.0;\n    sextant = int(h);\n    fract = h - float(sextant);\n\n    vsf = (v - m) * fract;\n    mid1 = m + vsf;\n    mid2 = v - vsf;\n    switch (sextant) {\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\n    }\n  }\n  return RGB;\n}\n\nvoid main()\n{\n  // lookup hsl color , mask\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\n\n  // don't modify masked fragments (masked => lic.g==1)\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g==0.0)\n    {\n    // normalize lightness channel\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\n    }\n\n  // back into rgb space\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\n\n  // add alpha\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n  fragColor.a = geomColor.a;\n\n  gl_FragData[0] = fragColor;\n}\n"),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=Pd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ns.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ns.newInstance({numberOfComponents:1,values:o}),s=Ns.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",bm.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=mm.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi("texDepth",t.depthTexture.getTextureUnit()),r.setUniformi("texRGBColors",t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi("texVectors",t.vectorImage.getTextureUnit()),o.setUniformi("texGeomColors",t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get("colorMode","LICIntensity","mapModeBias","maskIntensity","maskColor","enhanceContrast","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor");if(o.setUniformi("texLIC",t.LICImage.getTextureUnit()),o.setUniformi("uScalarColorMode",a),o.setUniformf("uLICIntensity",i),o.setUniformf("uMapBias",s),o.setUniformf("uMaskIntensity",l),o.setUniform3f("uMaskColor",...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===cm||u===um){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi("texGeomColors",t.geometryImage.getTextureUnit()),s.setUniformi("texHSLColors",t.HSLColorImage.getTextureUnit()),s.setUniformi("texLIC",t.LICImage.getTextureUnit()),s.setUniformf("uLMin",o),s.setUniformf("uLMaxMinDiff",i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get("stepSize","numberOfSteps","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","normalizeVectors","maskThreshold","transformVectors"),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error("Failed to compute image LIC"),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}const Cm={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function Sm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cm,n),Tm.extend(e,t,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","reallocateTextures","licInterface","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),xm(e,t)}var Am={newInstance:jt.newInstance(Sm,"vtkSurfaceLICInterface"),extend:Sm};const{vtkErrorMacro:Im}=Kt;function wm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICMapper");const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=yd.substitute(s,"//VTK::Output::Dec",["//VTK::Output::Dec","layout(location = 2) out vec4 vectorTexture;","layout(location = 3) out vec4 maskVectorTexture;"]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=yd.substitute(i,"//VTK::TCoord::Dec",[`attribute vec3 ${n};`,"out vec3 licOutput;","//VTK::TCoord::Dec"]).result,i=yd.substitute(i,"//VTK::TCoord::Impl",[`licOutput = ${n};`,"//VTK::TCoord::Impl"]).result,s=yd.substitute(s,"//VTK::TCoord::Dec",["uniform int uMaskOnSurface;","uniform mat3 normalMatrix;","in vec3 licOutput;","//VTK::TCoord::Dec"]).result,s=yd.substitute(s,"//VTK::TCoord::Impl",["// projected vectors","  vec3 tcoordLIC = normalMatrix * licOutput;","  vec3 normN = normalize(normalVCVSOutput);","  float k = dot(tcoordLIC, normN);","  vec3 projected = (tcoordLIC - k*normN);","  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","// vectors for fragment masking","  if (uMaskOnSurface == 0)","    {","    maskVectorTexture = vec4(licOutput, 1.0);","    }","  else","    {","    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","    }","//VTK::TCoord::Impl"],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi("uMaskOnSurface",t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(Im("SurfaceLICMapper Requires WebGL 2"),a=!1),t.context.getExtension("EXT_color_buffer_float")&&t.context.getExtension("OES_texture_float_linear")||(Im("SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions."),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(Im("No input"),a=!1);let i=t.renderable.getLicInterface();i||(i=Tm.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=Am.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(Im("No vector input array"),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}const Pm={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const Om=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pm,n),pp.extend(e,t,n),wm(e,t),At(e,t,["openGLLicInterface"])}),"vtkOpenGLSurfaceLICMapper");rn("vtkSurfaceLICMapper",Om);const{vtkErrorMacro:Rm}=Kt;function Mm(e,t){t.classHierarchy.push("vtkOpenGLSphereMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;\n"]).result,i=yd.substitute(i,"//VTK::Normal::Dec",["uniform float invertedDepth;\n","uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=yd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float b = 2.0*dot(EyePos,EyeDir);\n","  float c = dot(EyePos,EyePos) - 1.0;\n","  float d = b*b - 4.0*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t = (-b - invertedDepth*sqrt(d))*0.5;\n","    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n","    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=yd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"offsetMC",12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||Rm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isUniformUsed("invertedDepth")&&e.getProgram().setUniformf("invertedDepth",t.invert?-1:1),e.getProgram().isUniformUsed("scaleFactor")){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf("scaleFactor",t.renderable.getScaleFactor()):e.getProgram().setUniformf("scaleFactor",1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),o.isUniformUsed("MCVCMatrix"))if(r.getIsIdentity())o.setUniformMatrix("MCVCMatrix",i.wcvc);else{const e=t.openGLActor.getKeyMatrices(),n=new Float64Array(16);T(n,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",n)}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(rd.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(Oo(30));let h=0,v=0,y=0,T=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=-2*n*m,g[y++]=-n,d&&(v=e*p,f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=2*n*m,g[y++]=-n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=0,g[y++]=2*n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3])}a.setElementCount(y/5),a.upload(g,Zu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,Zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Em={};const Dm=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Em,n),pp.extend(e,t,n),Mm(e,t)}),"vtkOpenGLSphereMapper");rn("vtkSphereMapper",Dm);const{vtkErrorMacro:Vm}=Kt;function Lm(e,t){t.classHierarchy.push("vtkOpenGLStickMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec","varying vec4 vertexVCVSOutput;").result,i=yd.substitute(i,"//VTK::PositionVC::Impl","  vec4 vertexVC = vertexVCVSOutput;\n").result,i=yd.substitute(i,"//VTK::Normal::Dec",["uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 orientVCVSOutput;\n","varying float lengthVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=yd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  vec3 base1;\n","  if (abs(orientVCVSOutput.z) < 0.99) {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n","  else {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n","  vec3 base2 = cross(orientVCVSOutput,base1);\n","  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n","  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n","  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n","  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n","  float d = b*b - 4.0*a*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t =  (-b - sqrt(d))/(2.0*a);\n","    float tz = EyePos.z + t*EyeDir.z;\n","    vec3 iPoint = EyePos + t*EyeDir;\n","    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n","      float t2 = (-b + sqrt(d))/(2.0*a);\n","      float tz2 = EyePos.z + t2*EyeDir.z;\n","      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n","      else {\n","        normalVCVSOutput = orientVCVSOutput;\n","        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n","        iPoint = EyePos + t3*EyeDir;\n","        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","        }\n","      }\n","    else {\n","      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n","      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","      }\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=yd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed("orientMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"orientMC",12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||Vm("Error setting 'orientMC' in shader VAO.")),e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"offsetMC",0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||Vm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isAttributeUsed("radiusMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"radiusMC",24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||Vm("Error setting 'radiusMC' in shader VAO."))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),r.getIsIdentity())o.isUniformUsed("MCVCMatrix")&&o.setUniformMatrix("MCVCMatrix",i.wcvc),o.isUniformUsed("normalMatrix")&&o.setUniformMatrix3x3("normalMatrix",i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed("MCVCMatrix")){const t=new Float64Array(16);T(t,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",t)}if(o.isUniformUsed("normalMatrix")){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3("normalMatrix",t)}}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(rd.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():Vm(["Error setting orientationArray.\n","You have to specify the stick orientation"]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let y=0,T=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)y=3*e,f[b++]=c[y++],f[b++]=c[y++],f[b++]=c[y++],y=3*e,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,T=e*p,d&&(g[x++]=d[T],g[x++]=d[T+1],g[x++]=d[T+2],g[x++]=d[T+3])}a.setElementCount(b/7),a.upload(f,Zu.ARRAY_BUFFER),a.getColorBO().upload(g,Zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Bm={};const Nm=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bm,n),pp.extend(e,t,n),Lm(e,t)}),"vtkOpenGLStickMapper");rn("vtkStickMapper",Nm);const _m=[];_m["-".charCodeAt(0)]=62,_m["_".charCodeAt(0)]=63;const Fm="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let e=0;e<Fm.length;e++)_m[Fm.charCodeAt(e)]=e;function km(e){return void 0!==_m[e.charCodeAt(0)]}function Gm(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<18;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<12;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<6;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<10;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<4;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<2;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error("BASE64: remain 1 should not happen")}return u}function Um(e,t,n){const r=(e<<16)+(t<<8)+n;return Fm[r>>18]+Fm[r>>12&63]+Fm[r>>6&63]+Fm[63&r]}function zm(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=Um(t[n],t[n+1],t[n+2])}if(n>0){const e=Um(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join("")}var Wm=function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)km(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):"="===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Gm(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o};const Hm={};function jm(e,t){Hm[e]=t}var Km=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Hm[e](t)},$m=Uint8Array,qm=Uint16Array,Xm=Uint32Array,Ym=new $m([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Zm=new $m([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Qm=new $m([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Jm=function(e,t){for(var n=new qm(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new Xm(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},eh=Jm(Ym,2),th=eh[0],nh=eh[1];th[28]=258,nh[258]=28;for(var rh=Jm(Zm,0),oh=rh[0],ah=(rh[1],new qm(32768)),ih=0;ih<32768;++ih){var sh=(43690&ih)>>>1|(21845&ih)<<1;sh=(61680&(sh=(52428&sh)>>>2|(13107&sh)<<2))>>>4|(3855&sh)<<4,ah[ih]=((65280&sh)>>>8|(255&sh)<<8)>>>1}var lh=function(e,t,n){for(var r=e.length,o=0,a=new qm(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new qm(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new qm(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[ah[d]>>>l]=c}else for(i=new qm(r),o=0;o<r;++o)e[o]&&(i[o]=ah[s[e[o]-1]++]>>>15-e[o]);return i},ch=new $m(288);for(ih=0;ih<144;++ih)ch[ih]=8;for(ih=144;ih<256;++ih)ch[ih]=9;for(ih=256;ih<280;++ih)ch[ih]=7;for(ih=280;ih<288;++ih)ch[ih]=8;var uh=new $m(32);for(ih=0;ih<32;++ih)uh[ih]=5;var dh=lh(ch,9,1),ph=lh(uh,5,1),fh=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},gh=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},mh=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},hh=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?qm:4==e.BYTES_PER_ELEMENT?Xm:$m)(n-t);return r.set(e.subarray(t,n)),r},vh=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],yh=function(e,t,n){var r=new Error(t||vh[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,yh),!n)throw r;return r},Th=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new $m(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new $m(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new $m(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=gh(e,c,1);var h=gh(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(O=4+((i+7)/8|0))-4)]|e[O-3]<<8,y=O+v;if(y>r){a&&yh(0);break}o&&s(u+v),t.set(e.subarray(O,y),u),n.b=u+=v,n.p=c=8*y,n.f=l;continue}if(1==h)d=dh,p=ph,f=9,g=5;else if(2==h){var T=gh(e,c,31)+257,b=gh(e,c+10,15)+4,x=T+gh(e,c+5,31)+1;c+=14;for(var C=new $m(x),S=new $m(19),A=0;A<b;++A)S[Qm[A]]=gh(e,c+3*A,7);c+=3*b;var I=fh(S),w=(1<<I)-1,P=lh(S,I,1);for(A=0;A<x;){var O,R=P[gh(e,c,w)];if(c+=15&R,(O=R>>>4)<16)C[A++]=O;else{var M=0,E=0;for(16==O?(E=3+gh(e,c,3),c+=2,M=C[A-1]):17==O?(E=3+gh(e,c,7),c+=3):18==O&&(E=11+gh(e,c,127),c+=7);E--;)C[A++]=M}}var D=C.subarray(0,T),V=C.subarray(T);f=fh(D),g=fh(V),d=lh(D,f,1),p=lh(V,g,1)}else yh(1);if(c>m){a&&yh(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var _=(M=d[mh(e,c)&L])>>>4;if((c+=15&M)>m){a&&yh(0);break}if(M||yh(2),_<256)t[u++]=_;else{if(256==_){N=c,d=null;break}var F=_-254;if(_>264){var k=Ym[A=_-257];F=gh(e,c,(1<<k)-1)+th[A],c+=k}var G=p[mh(e,c)&B],U=G>>>4;if(G||yh(3),c+=15&G,V=oh[U],U>3&&(k=Zm[U],V+=mh(e,c)&(1<<k)-1,c+=k),c>m){a&&yh(0);break}o&&s(u+131072);for(var z=u+F;u<z;u+=4)t[u]=t[u-V],t[u+1]=t[u+1-V],t[u+2]=t[u+2-V],t[u+3]=t[u+3-V];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:hh(t,0,u)},bh=new $m(0),xh=function(e,t){return e[t]|e[t+1]<<8},Ch=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},Sh=function(e,t){return Ch(e,t)+4294967296*Ch(e,t+4)};function Ah(e,t){return Th(e,t)}function Ih(e,t){return Th(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||yh(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new $m((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function wh(e,t){return Th(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&yh(6,"invalid zlib data"),32&n[1]&&yh(6,"invalid zlib data: preset dictionaries not supported"),e.subarray(2,-4)),t);var n}function Ph(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?Ih(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?Ah(e,t):wh(e,t)}var Oh="undefined"!=typeof TextEncoder&&new TextEncoder,Rh="undefined"!=typeof TextDecoder&&new TextDecoder;try{Rh.decode(bh,{stream:!0})}catch(e){}function Mh(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(Rh)return Rh.decode(e);var o=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,hh(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&yh(8),a}var Eh=function(e,t){return t+30+xh(e,t+26)+xh(e,t+28)},Dh=function(e,t,n){var r=xh(e,t+28),o=Mh(e.subarray(t+46,t+46+r),!(2048&xh(e,t+8))),a=t+46+r,i=Ch(e,t+20),s=n&&4294967295==i?Vh(e,a):[i,Ch(e,t+24),Ch(e,t+42)],l=s[0],c=s[1],u=s[2];return[xh(e,t+10),l,c,o,a+xh(e,t+30)+xh(e,t+32),u]},Vh=function(e,t){for(;1!=xh(e,t);t+=4+xh(e,t+2));return[Sh(e,t+12),Sh(e,t+4),Sh(e,t+20)]};function Lh(e,t){for(var n={},r=e.length-22;101010256!=Ch(e,r);--r)(!r||e.length-r>65558)&&yh(13);var o=xh(e,r+8);if(!o)return{};var a=Ch(e,r+16),i=4294967295==a;i&&(r=Ch(e,r-12),101075792!=Ch(e,r)&&yh(13),o=Ch(e,r+32),a=Ch(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=Dh(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Eh(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=Ah(e.subarray(h,h+d),new $m(p)):yh(14,"unknown compression type "+u):n[f]=hh(e,h,h+d))}return n}function Bh(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?"LittleEndian":2712847316===n[0]?"BigEndian":null}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var Nh=Bh(),_h=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:Fh,vtkDebugMacro:kh}=jt;let Gh=0;function Uh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener("progress",n.progressCallback),r}const zh={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/");const s=Uh("GET",i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Mh(Ph(new Uint8Array(n.buffer))):n.buffer=Ph(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Nh!==n.ref.encode&&Nh&&(kh(`Swap bytes of ${n.name}`),_h(n.buffer,xs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&Fh(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||"string"!==n.dataType?"arraybuffer":"text",s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=Uh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(Mh(Ph(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&"gz"!==n.compression&&(Fh("Supported algorithms are: [gz]"),Fh(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=Uh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(Mh(Ph(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&"gz"!==t.compression&&(Fh("Supported algorithms are: [gz]"),Fh(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=Uh("GET",e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(Ph(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType="arraybuffer",o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};jm("http",(e=>zh));const{vtkDebugMacro:Wh}=jt;function Hh(e,t){t.classHierarchy.push("vtkCamera");const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function y(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,Wh("Distance is set to minimum."));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,Wh("Distance is set to minimum.");const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,y()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,Oo(n),s),Hi(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Go(t.position,a,t.position),Go(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Hi(o,[...t.position,1],n),Hi(a,[...t.focalPoint,1],n),Hi(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,Wh("Thickness is set to minimum.")),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,Wh("Thickness is set to minimum.")),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),P(i,[t.distance,t.distance,t.distance]),T(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=qi(e[0],e[1],e[2],e[3]),n=ji(),r=qi(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],$i(r,t,r),$i(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Ko(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),In(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),Vn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),Vn(l,r,a),Pn(l,l,s),Mn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),Vn(c,o,a),Pn(c,c,s),Mn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),T(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return In(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const n=Math.tan(Oo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return T(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,y()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Ko(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,Oo(n),t.physicalViewUp),C(s,s,Oo(r),i),C(s,s,Oo(o),t.physicalViewNorth),C(s,s,Oo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);Vn(l,l,s),Vn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=Oo(t),i=ji();Ki(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);Vn(i,[0,0,-1],a);const s=new Float64Array(3);Vn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}const jh={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Kh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jh,n),jt.obj(e,t),jt.get(e,t,["distance"]),jt.setGet(e,t,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),jt.getArray(e,t,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),jt.setGetArray(e,t,["clippingRange","windowCenter"],2),jt.setGetArray(e,t,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),Hh(e,t)}var $h={newInstance:jt.newInstance(Kh,"vtkCamera"),extend:Kh};function qh(e,t){t.classHierarchy.push("vtkLight");const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?Vn(n,t.position,t.transformMatrix):In(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?Vn(n,t.focalPoint,t.transformMatrix):In(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(_n(t.direction,t.focalPoint,t.position),qo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);_n(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=Oo(t),o=Oo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType("HeadLight")},e.setLightTypeToCameraLight=()=>{e.setLightType("CameraLight")},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType("SceneLight")},e.lightTypeIsHeadLight=()=>"HeadLight"===t.lightType,e.lightTypeIsSceneLight=()=>"SceneLight"===t.lightType,e.lightTypeIsCameraLight=()=>"CameraLight"===t.lightType}const Xh={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Yh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xh,n),jt.obj(e,t),jt.setGet(e,t,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),jt.setGetArray(e,t,["color","position","focalPoint","attenuationValues"],3),qh(e,t)}var Zh={newInstance:jt.newInstance(Yh,"vtkLight"),extend:Yh,LIGHT_TYPES:["HeadLight","CameraLight","SceneLight"]};const{vtkErrorMacro:Qh}=jt;function Jh(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push("vtkViewport"),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{const e=[];for(let r=0;r<t.props.length;r++)n(t.props[r],e);return e},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Qh("call displayToView on your view instead"),e.viewToDisplay=()=>Qh("callviewtodisplay on your view instead"),e.getSize=()=>Qh("call getSize on your View instead"),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=("PickPropFrom",()=>Qh("vtkViewport::PickPropFrom - NOT IMPLEMENTED"))}const ev={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function tv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ev,n),jt.obj(e,t),jt.event(e,t,"event"),jt.setGetArray(e,t,["viewport"],4),jt.setGetArray(e,t,["background","background2"],3),Jh(e,t)}var nv={newInstance:jt.newInstance(tv,"vtkViewport"),extend:tv};const{vtkDebugMacro:rv,vtkErrorMacro:ov,vtkWarningMacro:av}=Kt;function iv(e){return()=>ov(`vtkRenderer::${e} - NOT IMPLEMENTED`)}function sv(e,t){t.classHierarchy.push("vtkRenderer");const n={type:"ComputeVisiblePropBoundsEvent",renderer:e},r={type:"ResetCameraClippingRangeEvent",renderer:e},o={type:"ResetCameraEvent",renderer:e};e.updateCamera=()=>(t.activeCamera||(rv("No cameras are on, creating one."),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):ov("light has unknown light type",e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=iv("allocateTime"),e.updateGeometry=iv("updateGeometry"),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{rv(e.getClassName(),e,"setting Layer to ",n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:"ActiveCameraEvent",camera:n}),!0),e.makeCamera=()=>{const t=$h.newInstance();return e.invokeEvent({type:"CreateCameraEvent",camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=Zh.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return ov("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return ov("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return ov("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return ov("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=Wi.INIT_BOUNDS[0],t.allBounds[1]=Wi.INIT_BOUNDS[1],t.allBounds[2]=Wi.INIT_BOUNDS[2],t.allBounds[3]=Wi.INIT_BOUNDS[3],t.allBounds[4]=Wi.INIT_BOUNDS[4],t.allBounds[5]=Wi.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&Ra(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Oa(t.allBounds),rv("Can't compute bounds, no 3D props are visible")),t.allBounds},e.resetCamera=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const r=n||e.computeVisiblePropBounds(),a=[0,0,0];if(!Ra(r))return rv("Cannot reset camera!"),!1;let i=null;if(!e.getActiveCamera())return ov("Trying to reset non-existent camera"),!1;i=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),a[0]=(r[0]+r[1])/2,a[1]=(r[2]+r[3])/2,a[2]=(r[4]+r[5])/2;let s=r[1]-r[0],l=r[3]-r[2],c=r[5]-r[4];s*=s,l*=l,c*=c;let u=s+l+c;u=0===u?1:u,u=.5*Math.sqrt(u);const d=Oo(t.activeCamera.getViewAngle()),p=u,f=u/Math.sin(.5*d),g=t.activeCamera.getViewUp();return Math.abs(jo(g,i))>.999&&(av("Resetting view-up since view plane normal is parallel"),t.activeCamera.setViewUp(-g[2],g[0],g[1])),t.activeCamera.setFocalPoint(a[0],a[1],a[2]),t.activeCamera.setPosition(a[0]+f*i[0],a[1]+f*i[1],a[2]+f*i[2]),e.resetCameraClippingRange(r),t.activeCamera.setParallelScale(p),t.activeCamera.setPhysicalScale(u),t.activeCamera.setPhysicalTranslation(-a[0],-a[1],-a[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const o=n||e.computeVisiblePropBounds();if(!Ra(o))return rv("Cannot reset camera clipping range!"),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return ov("Trying to reset clipping range of non-existent camera"),!1;const a=t.activeCamera.computeClippingRange(o);let i=0;if(t.activeCamera.getParallelProjection())i=.2*t.activeCamera.getParallelScale();else{const e=Oo(t.activeCamera.getViewAngle());i=.2*Math.tan(e/2)*a[1]}return a[1]-a[0]<i&&(i=i-a[1]+a[0],a[1]+=i/2,a[0]-=i/2),a[0]<0&&(a[0]=0),a[0]=.99*a[0]-(a[1]-a[0])*t.clippingRangeExpansion,a[1]=1.01*a[1]+(a[1]-a[0])*t.clippingRangeExpansion,a[0]=a[0]>=a[1]?.01*a[1]:a[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),a[0]<t.nearClippingPlaneTolerance*a[1]&&(a[0]=t.nearClippingPlaneTolerance*a[1]),t.activeCamera.setClippingRange(a[0],a[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}const lv={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Fa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function cv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,lv,n),nv.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),bt(e,t,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),At(e,t,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),It(e,t,["actors","volumes","lights"]),Pt(e,t,["background"],4,1),Ot(0,t,["renderWindow"]),sv(e,t)}var uv={newInstance:Dt(cv,"vtkRenderer"),extend:cv};const dv=Object.create(null);function pv(e,t){dv[e]=t}function fv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return dv[e]&&dv[e](t)}function gv(e,t){t.classHierarchy.push("vtkRenderWindow"),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return fv(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join("\n"),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return jt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))},e.addRenderWindow=n=>!t.childRenderWindows.includes(n)&&(t.childRenderWindows.push(n),e.modified(),!0),e.removeRenderWindow=n=>{const r=t.childRenderWindows.findIndex((e=>e===n));return!(r<0||(t.childRenderWindows.splice(r,1),e.modified(),0))}}const mv={defaultViewAPI:"WebGL",renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function hv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mv,n),jt.obj(e,t),jt.setGet(e,t,["interactor","numberOfLayers","_views","defaultViewAPI"]),jt.get(e,t,["neverRendered"]),jt.getArray(e,t,["renderers","childRenderWindows"]),jt.moveToProtected(e,t,["views"]),jt.event(e,t,"completion"),gv(e,t)}var vv={newInstance:jt.newInstance(hv,"vtkRenderWindow"),extend:hv,registerViewConstructor:pv,listViewAPIs:function(){return Object.keys(dv)},newAPISpecificView:fv};const yv={Unknown:0,LeftController:1,RightController:2},Tv={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var bv={Device:yv,Input:Tv,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4}};const{Device:xv,Input:Cv}=bv,{vtkWarningMacro:Sv,vtkErrorMacro:Av,normalizeWheel:Iv,vtkOnceErrorMacro:wv}=jt,Pv={ctrlKey:!1,altKey:!1,shiftKey:!1},Ov={"xr-standard":[Cv.Trigger,Cv.Grip,Cv.TrackPad,Cv.Thumbstick,Cv.A,Cv.B]},Rv=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function Mv(e){e.cancelable&&e.preventDefault()}function Ev(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}function Dv(e,t){t.classHierarchy.push("vtkRenderWindowInteractor");const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{Av("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>Sv("empty event loop"),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||""}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener("contextmenu",Mv),n.addEventListener("wheel",e.handleWheel),n.addEventListener("DOMMouseScroll",e.handleWheel),n.addEventListener("pointerenter",e.handlePointerEnter),n.addEventListener("pointerleave",e.handlePointerLeave),n.addEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.addEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.addEventListener("pointerup",e.handlePointerUp),n.addEventListener("pointercancel",e.handlePointerCancel),document.addEventListener("keypress",e.handleKeyPress),document.addEventListener("keydown",e.handleKeyDown),document.addEventListener("keyup",e.handleKeyUp),document.addEventListener("pointerlockchange",e.handlePointerLockChange),n.style.touchAction="none",n.style.userSelect="none",n.style.webkitTapHighlightColor="rgba(0,0,0,0)"};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener("contextmenu",Mv),n.removeEventListener("wheel",e.handleWheel),n.removeEventListener("DOMMouseScroll",e.handleWheel),n.removeEventListener("pointerenter",e.handlePointerEnter),n.removeEventListener("pointerleave",e.handlePointerLeave),n.removeEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.removeEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.removeEventListener("pointerup",e.handlePointerUp),n.removeEventListener("pointercancel",e.handlePointerCancel)),document.removeEventListener("keypress",e.handleKeyPress),document.removeEventListener("keydown",e.handleKeyDown),document.removeEventListener("keyup",e.handleKeyUp),document.removeEventListener("pointerlockchange",e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),"mouse"===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),"mouse"===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&Mv(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&Sv("[RenderWindowInteractor] duplicate pointerId detected"),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case"pen":case"touch":e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&Mv(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case"pen":case"touch":e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case"pen":case"touch":e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case"pen":case"touch":e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:Av(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?Sv("requester is already registered for animating"):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):Av("undefined requester, can not start animating")},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;Sv(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=null==n.gripSpace?null:r.getPose(n.targetRaySpace,o),s=n.gamepad,l=n.handedness;if(s){s.index in t.lastGamepadValues||(t.lastGamepadValues[s.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<s.buttons.length;++r)r in t.lastGamepadValues[s.index][l].buttons||(t.lastGamepadValues[s.index][l].buttons[r]=!1),t.lastGamepadValues[s.index][l].buttons[r]!==s.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,pressed:s.buttons[r].pressed,device:"left"===n.handedness?xv.LeftController:xv.RightController,input:Ov[s.mapping]&&Ov[s.mapping][r]?Ov[s.mapping][r]:Cv.Trigger}),t.lastGamepadValues[s.index][l].buttons[r]=s.buttons[r].pressed),t.lastGamepadValues[s.index][l].buttons[r]&&null!=a&&e.move3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,device:"left"===n.handedness?xv.LeftController:xv.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{Mv(n);const r={...Iv(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:Av(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Ev(o);if(2===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture("TouchStart",t)}else if(1===r.length){const t={...l(Pv),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Ev(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(Pv),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=Ev(o);e.recognizeGesture("TouchEnd",t);const a={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=Ev(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},Rv.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void wv("\n          Can not forward events without a current renderer on the interactor.\n        ");const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),"TouchStart"===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture="Start");if("TouchEnd"===n)return"Pinch"===t.currentGesture&&(e.render(),e.endPinchEvent()),"Rotate"===t.currentGesture&&(e.render(),e.endRotateEvent()),"Pan"===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture="Start",void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=Ro(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=Ro(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,"TouchMove"===n)if("Start"===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture="Pinch";const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture="Rotate";const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture="Pan";const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if("Rotate"===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if("Pinch"===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if("Pan"===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener("visibilitychange",e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener("visibilitychange",e.handleVisibilityChange,!1)}const Vv={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vv,n),jt.obj(e,t),t._animationExtendedEnd=0,jt.event(e,t,"RenderEvent"),Rv.forEach((n=>jt.event(e,t,n))),jt.get(e,t,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),jt.setGet(e,t,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),jt.moveToProtected(e,t,["view"]),Dv(e,t)}var Bv={newInstance:jt.newInstance(Lv,"vtkRenderWindowInteractor"),extend:Lv,handledEvents:Rv,...bv};const{vtkErrorMacro:Nv,VOID:_v}=jt;function Fv(e,t){t.classHierarchy.push("vtkInteractorObserver");const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Bv.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):_v),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Nv("\n          The interactor must be set before subscribing to events\n        ")),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}const kv={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),jt.obj(e,t),jt.event(e,t,"InteractionEvent"),jt.event(e,t,"StartInteractionEvent"),jt.event(e,t,"EndInteractionEvent"),jt.get(e,t,["_interactor","enabled"]),jt.setGet(e,t,["priority","processEvents"]),jt.moveToProtected(e,t,["interactor"]),Fv(e,t)}var Uv={newInstance:jt.newInstance(Gv,"vtkInteractorObserver"),extend:Gv,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},zv={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Wv}=zv,Hv={Rotate:Wv.IS_ROTATE,Pan:Wv.IS_PAN,Spin:Wv.IS_SPIN,Dolly:Wv.IS_DOLLY,CameraPose:Wv.IS_CAMERA_POSE,WindowLevel:Wv.IS_WINDOW_LEVEL,Slice:Wv.IS_SLICE};function jv(e,t){t.classHierarchy.push("vtkInteractorStyle"),Object.keys(Hv).forEach((n=>{jt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Wv.IS_NONE&&(t.state=Hv[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:"StartInteractionEvent"}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},jt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Hv[n]&&(t.state=Wv.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:"EndInteractionEvent"}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),t.getRenderer=e=>t.focusedRenderer||e.pokedRenderer,e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case"r":case"R":t.getRenderer(e).resetCamera(),n.render();break;case"w":case"W":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case"s":case"S":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case"v":case"V":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}const Kv={state:Wv.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),Uv.extend(e,t,n),jt.setGet(e,t,["focusedRenderer"]),jv(e,t)}var qv={newInstance:jt.newInstance($v,"vtkInteractorStyle"),extend:$v,...zv};const{States:Xv}=zv;function Yv(e,t){t.classHierarchy.push("vtkInteractorStyleTrackballCamera"),e.handleMouseMove=n=>{const r=n.position,o=t.getRenderer(n);switch(t.state){case Xv.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:"InteractionEvent"})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==yv.RightController||n.input!==Tv.Trigger&&n.input!==Tv.TrackPad?!n||n.pressed||n.device!==yv.RightController||n.input!==Tv.Trigger&&n.input!==Tv.TrackPad||t.state!==Xv.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===Xv.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const n=t.getRenderer(e).getActiveCamera(),r=n.getPhysicalTranslation(),o=.025*n.getPhysicalScale(),a=n.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);n.setPhysicalTranslation(r[0]+a[0]*o,r[1]+a[1]*o,r[2]+a[2]*o)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case Xv.IS_DOLLY:e.endDolly();break;case Xv.IS_PAN:e.endPan();break;case Xv.IS_SPIN:e.endSpin();break;case Xv.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(t.getRenderer(n),n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=t.getRenderer(n).getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(t.getRenderer(n),o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(t.getRenderer(n),o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(t.getRenderer(n),o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&t.getRenderer(n).updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=t.getRenderer(e).getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=Ro(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=Ro(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(t.getRenderer(n),r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}const Zv={motionFactor:10,zoomFactor:10};function Qv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zv,n),qv.extend(e,t,n),jt.setGet(e,t,["motionFactor","zoomFactor"]),Yv(e,t)}var Jv={newInstance:jt.newInstance(Qv,"vtkInteractorStyleTrackballCamera"),extend:Qv};function ey(e){return e}function ty(e){return null===e||"null"===e?null:"true"===e||"false"!==e&&(void 0!==e&&"undefined"!==e?"["===e[0]&&"]"===e[e.length-1]?e.substring(1,e.length-1).split(",").map((e=>ty(e.trim()))):""===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var ny=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?ty:ey,o=new URLSearchParams(t);return o.forEach(((e,t)=>{t&&(n[t]=!e||r(e))})),n};function ry(e,t){t.classHierarchy.push("vtkRenderPass"),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${jt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}const oy={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function ay(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oy,n),jt.obj(e,t),jt.get(e,t,["currentOperation"]),jt.setGet(e,t,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),jt.moveToProtected(e,t,["currentParent"]),ry(e,t)}var iy={newInstance:jt.newInstance(ay,"vtkRenderPass"),extend:ay};const{Representation:sy}=ms,{vtkErrorMacro:ly}=jt;function cy(e){const t=yd.substitute(e.Fragment,"//VTK::RenderPassFragmentShader::Impl","\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ",!1);e.Fragment=t.result}function uy(e,t){t.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Ns.newInstance({numberOfComponents:3,values:e});o.setName("points");const a=Ns.newInstance({numberOfComponents:2,values:n});a.setName("tcoords");const i=Ns.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,"polys",sy.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=ef.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Kd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,"Float32Array",null),t.translucentRTexture=Kd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw(n[0],n[1],1,"Float32Array",null),t.translucentZTexture=Kd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw(n[0],n[1],"Float32Array",null),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"),"//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n","")},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||ly("Error setting vertexDC in copy shader VAO."),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"tcoordTC",t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||ly("Error setting vertexDC in copy shader VAO.")},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension("EXT_color_buffer_half_float")&&!i.getExtension("EXT_color_buffer_float"))return e.setCurrentOperation("translucentPass"),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation("opaqueZBufferPass"),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation("translucentPass"),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=Cd.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi("translucentRGBATexture",t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi("translucentRTexture",t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate();const s=r.getTiledSizeAndOrigin();i.scissor(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize),i.viewport(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize)},e.getShaderReplacement=()=>t._supported?cy:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}const dy={framebuffer:null,copyShader:null,tris:null};function py(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dy,n),iy.extend(e,t,n),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),t.tris=Pd.newInstance(),jt.get(e,t,["framebuffer"]),uy(e,t)}var fy={newInstance:jt.newInstance(py,"vtkOpenGLOrderIndependentTranslucentPass"),extend:py};function gy(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getRenderable().getRenderersByReference();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getViewNodeFor(i);if(i.getDraw()&&i.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation("queryPass"),s.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=ef.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation("zBufferPass"),s.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation("cameraPass"),s.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation("opaquePass"),s.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=fy.newInstance()),t.translucentPass.traverse(n,s,e)),t.volumeCount>0&&(e.setCurrentOperation("volumePass"),s.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation("overlayPass"),s.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}const my={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),iy.extend(e,t,n),jt.get(e,t,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),gy(e,t)}var vy={newInstance:jt.newInstance(hy,"vtkForwardPass"),extend:hy},yy=n(594),Ty=n.n(yy);const by=["lastShaderProgramBound","context","_openGLRenderWindow"];function xy(e,t){t.classHierarchy.push("vtkShaderCache"),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=yd.substitute(o,"VSOut","GSOut").result);const a=t._openGLRenderWindow.getWebgl2();let i="\n",s="#version 100\n";a?s="#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n":(t.context.getExtension("OES_standard_derivatives"),t.context.getExtension("EXT_frag_depth")&&(i="#extension GL_EXT_frag_depth : enable\n"),t.context.getExtension("EXT_shader_texture_lod")&&(i+="#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT")),o=yd.substitute(o,"//VTK::System::Dec",[`${s}\n`,a?"":"#extension GL_OES_standard_derivatives : enable\n",i,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let l=yd.substitute(e,"//VTK::System::Dec",[`${s}\n`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(a){l=yd.substitute(l,"varying","out").result,o=yd.substitute(o,"varying","in").result;let e="",t=0;for(;o.includes(`gl_FragData[${t}]`);)o=yd.substitute(o,`gl_FragData\\[${t}\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\n`,t++;o=yd.substitute(o,"//VTK::Output::Dec",e).result}return{VSSource:l,FSSource:o,GSSource:yd.substitute(r,"//VTK::System::Dec",s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=Ty().hash(o);if(!(a in t.shaderPrograms)){const o=yd.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}const Cy={lastShaderProgramBound:null,shaderPrograms:null,context:null};function Sy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cy,n),t.shaderPrograms={},jt.obj(e,t),jt.setGet(e,t,by),jt.moveToProtected(e,t,["openGLRenderWindow"]),xy(e,t)}var Ay={newInstance:jt.newInstance(Sy,"vtkShaderCache"),extend:Sy};const{vtkErrorMacro:Iy}=jt;function wy(e,t){t.classHierarchy.push("vtkOpenGLTextureUnitManager"),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&Iy("some texture units  were not properly released");t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}const Py={context:null,numberOfTextureUnits:0,textureUnits:0};function Oy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Py,n),jt.obj(e,t),t.textureUnits=[],jt.get(e,t,["numberOfTextureUnits"]),jt.setGet(e,t,["context"]),wy(e,t)}var Ry={newInstance:jt.newInstance(Oy,"vtkOpenGLTextureUnitManager"),extend:Oy};function My(e,t){t.classHierarchy.push("vtkRenderWindowViewNode"),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{jt.vtkErrorMacro("not implemented")},e.getPixelData=(e,t,n,r)=>{jt.vtkErrorMacro("not implemented")},e.createSelector=()=>{jt.vtkErrorMacro("not implemented")}}const Ey={size:void 0,selector:void 0};function Dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ey,n),t.size||(t.size=[300,300]),jt.getArray(e,t,["size"],2),jt.get(e,t,["selector"]),Zt.extend(e,t,n),My(e,t)}var Vy={newInstance:jt.newInstance(Dy,"vtkRenderWindowViewNode"),extend:Dy};const{vtkDebugMacro:Ly,vtkErrorMacro:By}=jt,Ny={position:"absolute",top:0,left:0,width:"100%",height:"100%"},_y=["activateTexture","deactivateTexture","disableCullFace","enableCullFace","get3DContext","getActiveFramebuffer","getContext","getDefaultTextureByteSize","getDefaultTextureInternalFormat","getDefaultToWebgl2","getGLInformations","getGraphicsMemoryInfo","getGraphicsResourceForObject","getHardwareMaximumLineWidth","getPixelData","getShaderCache","getTextureUnitForTexture","getTextureUnitManager","getWebgl2","makeCurrent","releaseGraphicsResources","registerGraphicsResourceUser","unregisterGraphicsResourceUser","restoreContext","setActiveFramebuffer","setContext","setDefaultToWebgl2","setGraphicsResourceForObject"];function Fy(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let ky=0;const Gy=[];function Uy(e){e.preventDefault()}function zy(e,t){let n;function r(){return n||(n=function(){const e=new Map,t={apply:(t,n,r)=>e.has(r[0])?e.get(r[0]):t.apply(n,r)},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply:(t,n,r)=>(e.set(a,r[0]),t.apply(n,r))}));var a},{get(e,t,r){if("__getUnderlyingContext"===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}()),n}t.classHierarchy.push("vtkOpenGLRenderWindow"),e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener("webglcontextlost",Uy,!1),t.canvas.addEventListener("webglcontextrestored",e.restoreContext,!1);const o=[0,0];let a;e.onModified((function(){t.renderable&&(t.size[0]===o[0]&&t.size[1]===o[1]||(o[0]=t.size[0],o[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.addMissingNodes(t.renderable.getChildRenderWindowsByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow?.(e)}))}},e.initialize=()=>{if(!t.initialized){if(t.rootOpenGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.rootOpenGLRenderWindow)t.context2D=e.get2DContext();else{t.context=e.get3DContext(),e.resizeFromChildRenderWindows(),t.context&&(ky++,Gy.forEach((e=>e(ky)))),t.textureUnitManager=Ry.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND)}t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&By("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>{const e=t.activeFramebuffer?.getSize();return e||t.size},e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},n=null;const o="undefined"!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(n=t.canvas.getContext("webgl2",e),n&&(t.webgl2=!0,Ly("using webgl2"))),n||(Ly("using webgl1"),n=t.canvas.getContext("webgl",e)||t.canvas.getContext("experimental-webgl",e)),new Proxy(n,r())},e.get2DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.canvas.getContext("2d",e)},e.restoreContext=()=>{const t=iy.newInstance();t.setCurrentOperation("Release"),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?By("Hardware does not support the number of textures defined."):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case Cs.CHAR:case Cs.SIGNED_CHAR:case Cs.UNSIGNED_CHAR:return 1;case n:case r:case Cs.UNSIGNED_SHORT:case Cs.SHORT:case Cs.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case Cs.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&Cs.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&Cs.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Ny,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(),t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=a)return a;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return a=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension("OES_texture_float"),o=n.getExtension("OES_texture_half_float"),a=n.getExtension("WEBGL_debug_renderer_info"),i=n.getExtension("WEBGL_draw_buffers"),s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),l=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",n.getParameter(n.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",n.getParameter(n.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",n.getParameter(n.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",n.getParameter(n.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",n.getParameter(n.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",n.getParameter(n.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",n.getParameter(n.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",n.getParameter(n.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",n.getParameter(n.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",n.getParameter(n.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",n.getParameter(n.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",n.getParameter(n.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",n.getParameter(n.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",n.getParameter(n.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[r&&Fy(n,n.RGBA,n.UNSIGNED_BYTE)?"RGBA":"",r&&Fy(n,n.RGB,n.UNSIGNED_BYTE)?"RGB":"",r&&Fy(n,n.LUMINANCE,n.UNSIGNED_BYTE)?"LUMINANCE":"",r&&Fy(n,n.ALPHA,n.UNSIGNED_BYTE)?"ALPHA":"",r&&Fy(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[o&&Fy(n,n.RGBA,o.HALF_FLOAT_OES)?"RGBA":"",o&&Fy(n,n.RGB,o.HALF_FLOAT_OES)?"RGB":"",o&&Fy(n,n.LUMINANCE,o.HALF_FLOAT_OES)?"LUMINANCE":"",o&&Fy(n,n.ALPHA,o.HALF_FLOAT_OES)?"ALPHA":"",o&&Fy(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[r&&Fy(n,n.RGBA,n.FLOAT)?"RGBA":"",r&&Fy(n,n.RGB,n.FLOAT)?"RGB":"",r&&Fy(n,n.LUMINANCE,n.FLOAT)?"LUMINANCE":"",r&&Fy(n,n.ALPHA,n.FLOAT)?"ALPHA":"",r&&Fy(n,n.LUMINANCE_ALPHA,n.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",n.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")],["WebGL Renderer","RENDERER",n.getParameter(n.RENDERER)],["WebGL Vendor","VENDOR",n.getParameter(n.VENDOR)],["WebGL Version","VERSION",n.getParameter(n.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",n.getParameter(n.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);e.copyParentContent(),t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect(),i=t.renderable;i.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const s=r.toDataURL(n);r.remove(),e.invokeImageReady(s)}();const n=t.renderable.getChildRenderWindowsByReference();for(let t=0;t<n.length;++t)e.getViewNodeFor(n[t])?.traverseAllPasses()},e.copyParentContent=()=>{const e=t.rootOpenGLRenderWindow;if(!e||!t.context2D||t.children.some((e=>!!e.getSelector?.())))return;const n=e.getCanvas(),r=t.canvas;t.context2D.drawImage(n,0,n.height-r.height,r.width,r.height,0,0,r.width,r.height)},e.resizeFromChildRenderWindows=()=>{const n=t.renderable.getChildRenderWindowsByReference();if(n.length>0){const t=[0,0];for(let r=0;r<n.length;++r){const o=e.getViewNodeFor(n[r])?.getSize();o&&(t[0]=o[0]>t[0]?o[0]:t[0],t[1]=o[1]>t[1]?o[1]:t[1])}e.setSize(...t)}},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=xf.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=jt.chain((()=>{t.context&&(ky--,Gy.forEach((e=>e(ky)))),e.setContainer(),e.setViewStream()}),(function(){t.canvas.removeEventListener("webglcontextlost",Uy),t.canvas.removeEventListener("webglcontextrestored",e.restoreContext)}),e.delete),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const i=e.setSize;e.setSize=(t,n)=>{const r=i(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.registerGraphicsResourceUser=(n,r)=>{t._graphicsResources.has(n)||e.setGraphicsResourceForObject(n,null,null),t._graphicsResources.get(n)?.users.add(r)},e.unregisterGraphicsResourceUser=(n,r)=>{const o=t._graphicsResources.get(n);o&&(o.users.delete(r),o.users.size||(o.oglObject?.releaseGraphicsResources(e),t._graphicsResources.delete(n)))},e.getGraphicsResourceForObject=e=>t._graphicsResources.get(e),e.setGraphicsResourceForObject=(n,r,o)=>{if(!n)return;const a=t._graphicsResources.get(n);a?.oglObject?.releaseGraphicsResources(e),t._graphicsResources.set(n,{coreObject:n,oglObject:r,hash:o,users:a?.users??new Set})},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach((t=>{let{oglObject:n}=t;e+=n.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach((t=>{let{oglObject:n}=t;n.releaseGraphicsResources(e)})),t._graphicsResources.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{e.getViewNodeFor(t)?.releaseGraphicsResources()}))};const s={...e};_y.forEach((n=>{e[n]=function(){return t.rootOpenGLRenderWindow?t.rootOpenGLRenderWindow[n](...arguments):s[n](...arguments)}}))}const Wy={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};const Hy=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wy,n),Vy.extend(e,t,n),t.canvas||(t.canvas=document.createElement("canvas"),t.canvas.style.width="100%"),t.selector||(t.selector=xf.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",t._textureResourceIds=new Map,t._graphicsResources=new Map,t._glInformation=null,t.myFactory=ln.newInstance(),t.shaderCache=Ay.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=vy.newInstance(),jt.get(e,t,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer","rootOpenGLRenderWindow"]),jt.setGet(e,t,["initialized","context","context2D","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"imageReady"),jt.event(e,t,"windowResizeEvent"),zy(e,t)}),"vtkOpenGLRenderWindow");function jy(e,t){t.classHierarchy.push("vtkWebGPUShaderModule"),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}pv("WebGL",Hy),rn("vtkRenderWindow",Hy);const Ky={device:null,handle:null};function $y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ky,n),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["device","handle"]),jy(e,t)}var qy={newInstance:jt.newInstance($y,"vtkWebGPUShaderModule"),extend:$y};function Xy(e,t){t.classHierarchy.push("vtkWebGPUShaderCache"),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=qy.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}const Yy={shaderModules:null,device:null,window:null};function Zy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yy,n),t._shaderModules=new Map,jt.obj(e,t),jt.setGet(e,t,["device","window"]),Xy(e,t)}var Qy={newInstance:jt.newInstance(Zy,"vtkWebGPUShaderCache"),extend:Zy,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join("\n"):n;let a=!1;-1!==e.search(t)&&(a=!0);let i="";r&&(i="g");const s=new RegExp(t,i),l=e.replace(s,o);return{replace:a,result:l}}};function Jy(e,t){t.classHierarchy.push("vtkWebGPUBindGroup"),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join("\n")}}const eT={device:null,handle:null,label:null};function tT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eT,n),jt.obj(e,t),t.bindables=[],t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","sizeInBytes","usage"]),jt.setGet(e,t,["label","device","arrayInformation"]),Jy(e,t)}var nT={newInstance:jt.newInstance(tT),extend:tT};function rT(e,t){t.classHierarchy.push("vtkWebGPUPipeline"),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);"vertex"===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint="main"),"fragment"===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint="main")}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}const oT={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function aT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oT,n),yt(e,t),t.layouts=[],t.shaderDescriptions=[],bt(e,t,["handle","pipelineDescription"]),At(e,t,["device","renderEncoder","topology","vertexState"]),rT(e,t)}var iT={newInstance:Dt(aT,"vtkWebGPUPipeline"),extend:aT};function sT(e,t){t.classHierarchy.push("vtkWebGPUShaderDescription"),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push("};"),o=n,r[r.length-1]+=",",r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=Qy.substitute(t.code,"//VTK::IOStructs::Input",r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push("};"),o=o.concat(e),t.code=Qy.substitute(t.code,"//VTK::IOStructs::Output",[`-> ${t.type}Output`]).result}t.code=Qy.substitute(t.code,"//VTK::IOStructs::Dec",o).result}}const lT={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function cT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lT,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],jt.obj(e,t),jt.setGet(e,t,["type","hash","code"]),jt.getArray(e,t,["outputTypes","outputNames","outputInterpolations"]),sT(e,t)}var uT={newInstance:jt.newInstance(cT,"vtkWebGPUShaderDescription"),extend:cT};const dT={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"float"},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"float"},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"sint"},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"uint"},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:"sint"},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:"float"},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"float"},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"float"},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"uint"},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"sint"},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:"uint"},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:"sint"},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"unfilterable-float"},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:"uint"},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:"sint"},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:"float"},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"rgba8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"float"},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"uint"},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"sint"},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"bgra8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:"float"},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:"uint"},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:"sint"},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:"unfilterable-float"},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:"uint"},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:"sint"},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:"float"},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:"uint"},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:"sint"},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:"unfilterable-float"},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"depth"},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:"depth"},"depth24plus-stencil8":{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:"mixed"},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"depth"}};var pT=function(e){return!e||e.length<6?0:e in dT==1?dT[e]:(et(`unknown format ${e}`),null)},fT=function(e){if(!e||e.length<5)return 0;let t=1;"x"===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},gT=function(e){if(!e||e.length<5)return 0;let t;if("f"===e[0])t="Float";else if("s"===e[0])t="Int";else{if("u"!==e[0])return void et(`unknown format ${e}`);t="Uint"}const n=e.split("x")[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+="Array",t;et(`unknown format ${e}`)},mT=function(e){let t;if("f"===e[0]||"n"===e[1])t="f32";else if("s"===e[0]&&"i"===e[1])t="i32";else{if("u"!==e[0]||"i"!==e[1])return void et(`unknown format ${e}`);t="u32"}let n=1;return"x"===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},hT=function(e){if(!e)return 0;let t=1;return"vec"===e.substring(0,3)?t=Number(e[3]):"mat"===e.substring(0,3)&&(t=e[3]*e[5]),4*t},vT=function(e){if(e)return e.includes("f32")?"Float32Array":e.includes("i32")?"Int32Array":e.includes("u32")?"Uint32Array":void et(`unknown format ${e}`)};function yT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}function TT(e,t){t.classHierarchy.push("vtkWebGPUVertexInput"),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"vertex",o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(yT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e="",n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=mT(a.format);n>0&&(e+=",\n"),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}const bT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function xT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bT,n),yt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],At(e,t,["created","device","handle","indexBuffer"]),TT(e,t)}var CT={newInstance:Dt(xT,"vtkWebGPUVertexInput"),extend:xT};const ST="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n",AT="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function IT(e,t){t.classHierarchy.push("vtkWebGPUSimpleMapper"),e.generateShaderDescriptions=(n,r,o)=>{const a=uT.newInstance({type:"vertex",hash:n,code:t.vertexShaderTemplate}),i=uT.newInstance({type:"fragment",hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp("//VTK::[^:]*::","g"),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];"replaceShaderIOStructs"!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.replaceShaderCode(null,n),t.getShaderDescription("fragment").replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set("replaceShaderRenderEncoder",e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Qy.substitute(i,"//VTK::Renderer::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");i=s.getCode(),i=Qy.substitute(i,"//VTK::Renderer::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderRenderer",e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Qy.substitute(i,"//VTK::Mapper::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");s.addBuiltinInput("bool","@builtin(front_facing) frontFacing"),i=s.getCode(),i=Qy.substitute(i,"//VTK::Mapper::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderMapper",e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription("vertex").addOutput("vec2<f32>","tcoordVS")},t.shaderReplacements.set("replaceShaderTCoord",e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=iT.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}const wT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:"triangle-list",UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function PT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wT,n),Zt.extend(e,t,n),t.textureViews=[],t.vertexInput=CT.newInstance(),t.bindGroup=nT.newInstance({label:"mapperBG"}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||AT,t.vertexShaderTemplate=t.vertexShaderTemplate||ST,t.shaderReplacements=new Map,jt.get(e,t,["pipeline","vertexInput"]),jt.setGet(e,t,["additionalBindables","device","fragmentShaderTemplate","interpolate","numberOfInstances","numberOfVertices","pipelineHash","shaderReplacements","SSBO","textureViews","topology","UBO","vertexShaderTemplate","WebGPURenderer"]),IT(e,t)}var OT={newInstance:jt.newInstance(PT,"vtkWebGPUSimpleMapper"),extend:PT};function RT(e,t){t.classHierarchy.push("vtkWebGPUFullScreenQuad"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position"),r.addOutput("vec4<f32>","vertexVC");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);","output.vertexVC = vec4<f32>(vertexBC, 1);"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,["vertexBC"]),t.numberOfVertices=6}}const MT={};function ET(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),OT.extend(e,t,n),RT(e,t)}var DT={newInstance:jt.newInstance(ET,"vtkWebGPUFullScreenQuad"),extend:ET};const VT=["setBindGroup","setIndexBuffer","setVertexBuffer","draw","drawIndexed"];function LT(e,t){t.classHierarchy.push("vtkWebGPURenderEncoder"),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!("depthStencil"in n))console.log("mismatched depth attachments"),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\n${o}\n versus pipeline\n${a}\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<VT.length;n++)e[VT[n]]=function(){return t.handle[VT[n]](...arguments)}}const BT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function NT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,BT,n),yt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:0,depthStoreOp:"store"}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = computedColor;"]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}},t.colorTextureViews=[],bt(e,t,["boundPipeline","colorTextureViews"]),At(e,t,["depthTextureView","description","handle","label","pipelineHash","pipelineSettings","replaceShaderCodeFunction"]),LT(e,t)}var _T={newInstance:Dt(NT,"vtkWebGPURenderEncoder"),extend:NT},FT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const kT=["getMappedRange","mapAsync","unmap"];function GT(e,t){t.classHierarchy.push("vtkWebGPUBuffer"),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=e.byteLength,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<kT.length;n++)e[kT[n]]=function(){return t.handle[kT[n]](...arguments)}}const UT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function zT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,UT,n),jt.obj(e,t),jt.get(e,t,["handle","sizeInBytes","usage"]),jt.setGet(e,t,["strideInBytes","device","arrayInformation","label","sourceTime"]),GT(e,t)}var WT={newInstance:jt.newInstance(zT),extend:zT,...FT};const{Representation:HT}=ms,{PrimitiveTypes:jT}=FT;class KT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function $T(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function qT(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=$T(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=$T(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=$T(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=$T(n,o,t),n.ibo[n.iboId++]=a}function XT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let YT;const ZT=new Uint32Array(1),QT=new Uint32Array(2),JT=new Uint32Array(3),eb={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)ZT[0]=t[n+a],YT(ZT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)QT[0]=t[n+a],QT[1]=t[n+a+1],YT(QT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)QT[0]=t[n+a],QT[1]=t[n+(a+1)%e],YT(QT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)QT[0]=t[n+a],QT[1]=t[n+a+1],YT(QT,r,o);for(let a=0;a<e-2;a++)QT[0]=t[n+a],QT[1]=t[n+a+2],YT(QT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)JT[0]=t[n],JT[1]=t[n+a+1],JT[2]=t[n+a+2],YT(JT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)JT[0]=t[n+a],JT[1]=t[n+a+1+a%2],JT[2]=t[n+a+1+(a+1)%2],YT(JT,r,o)}};function tb(e,t){t.classHierarchy.push("vtkWebGPUIndexBuffer"),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case jT.Points:return"points";case jT.Lines:return"lines";case jT.Triangles:case jT.TriangleEdges:return"polys";case jT.TriangleStripEdges:case jT.TriangleStrips:return"strips";default:return""}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new KT};let d=null;d=o===HT.POINTS||r===jT.Points?eb.anythingToPoints:o===HT.WIREFRAME||r===jT.Lines?eb[`${l}ToWireframe`]:eb[`${l}ToSurface`],YT=XT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format="uint16"):(u.ibo=new Uint32Array(u.iboSize),e.format="uint32"),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),YT=qT,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}const nb={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nb,n),WT.extend(e,t,n),jt.setGet(e,t,["flatIdToPointId","flatIdToCellId","flatSize","indexCount"]),tb(e,t)}var ob={newInstance:jt.newInstance(rb),extend:rb,...FT};const{BufferUsage:ab}=FT,{vtkErrorMacro:ib}=Kt,{VtkDataTypes:sb}=Ns;function lb(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,"packExtra")&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function cb(e,t,n,r){const o=[];return Ko([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),qo(o),o}function ub(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===ab.Index&&(n=ob.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=WT.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===ab.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===ab.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===ab.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===ab.PointArray){r=GPUBufferUsage.VERTEX;const t=gT(e.format),o=lb(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?"flat":"perspective"}])}if(e.usage===ab.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=gT(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=cb(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=lb(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:"flat"}])}return e.usage===ab.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push("vtkWebGPUBufferManager"),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case sb.UNSIGNED_CHAR:t="uint8";break;case sb.FLOAT:t="float32";break;case sb.UNSIGNED_INT:t="uint32";break;case sb.INT:t="sint32";break;case sb.DOUBLE:t="float32";break;case sb.UNSIGNED_SHORT:t="uint16";break;case sb.SHORT:t="sin16";break;default:t="float32"}switch(e.getNumberOfComponents()){case 2:t+="x2";break;case 3:t.includes("32")||ib(`unsupported x3 type for ${t}`),t+="x3";break;case 4:t+="x4"}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:ab.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=WT.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:"float32x3"}]),t.fullScreenQuadBuffer}}const db={device:null,fullScreenQuadBuffer:null};function pb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,db,n),yt(e,t),At(e,t,["device"]),ub(e,t)}var fb={newInstance:Dt(pb),extend:pb,...FT};function gb(e,t){t.classHierarchy.push("vtkWebGPUSampler"),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:"clamp-to-edge",t.options.addressModeV=n.addressModeV?n.addressModeV:"clamp-to-edge",t.options.addressModeW=n.addressModeW?n.addressModeW:"clamp-to-edge",t.options.magFilter=n.magFilter?n.magFilter:"nearest",t.options.minFilter=n.minFilter?n.minFilter:"nearest",t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:"nearest",t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}const mb={device:null,handle:null,label:null,options:null};function hb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mb,n),jt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","options"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label"]),gb(e,t)}var vb={newInstance:jt.newInstance(hb),extend:hb};function yb(e,t){t.classHierarchy.push("vtkWebGPUTextureView"),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=pT(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=pT(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r="f32";"sint"===t.bindGroupLayoutEntry.texture.sampleType?r="i32":"uint"===t.bindGroupLayoutEntry.texture.sampleType&&(r="u32");let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return"depth"===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=vb.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}const Tb={texture:null,handle:null,sampler:null,label:null};function bb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tb,n),jt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","texture"]),jt.setGet(e,t,["bindGroupLayoutEntry","label","sampler"]),yb(e,t)}var xb={newInstance:jt.newInstance(bb),extend:bb};const{BufferUsage:Cb}=fb;function Sb(e,t){t.classHierarchy.push("vtkWebGPUTexture"),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?"2d":"3d";t.format=n.format?n.format:"rgba8unorm",t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:"rgba8unorm",t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];if(n.canvas)return t.device.getHandle().queue.copyExternalImageToTexture({source:n.canvas,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0},[t.width,t.height,t.depth]),void(t.ready=!0);n.jsImageData&&!n.nativeArray&&(n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,n.nativeArray=n.jsImageData.data);const o=pT(t.format);let a=t.width*o.stride;const i=(e,t,n)=>{const r=e.length/(t*n)*e.BYTES_PER_ELEMENT,a=2===o.elementSize&&"float"===o.sampleType;if(a||r%256){const i=e,s=r/i.BYTES_PER_ELEMENT,l=o.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=jt.newTypedArray(a?"Uint16Array":i.constructor.name,u*t*n);for(let e=0;e<t*n;e++)if(a)for(let t=0;t<s;t++)d[e*u+t]=Vd.toHalf(i[e*s+t]);else d.set(i.subarray(e*s,(e+1)*s),e*u);return[d,c]}return[e,r]};if(n.nativeArray&&(r=n.nativeArray),n.image){const e=document.createElement("canvas");e.width=n.image.width,e.height=n.image.height;const t=e.getContext("2d");t.translate(0,e.height),t.scale(1,-1),t.drawImage(n.image,0,0,n.image.width,n.image.height,0,0,e.width,e.height),r=t.getImageData(0,0,n.image.width,n.image.height).data}const s=t.device.createCommandEncoder();if(3!==e.getDimensionality()){const e=Pu.generateMipmaps(r,t.width,t.height,t.mipLevel);let o=t.width,l=t.height;for(let r=0;r<=t.mipLevel;r++){const c=i(e[r],l,1);a=c[1];const u={dataArray:n.dataArray?n.dataArray:null,nativeArray:c[0],usage:Cb.Texture},d=t.device.getBufferManager().getBuffer(u);s.copyBufferToTexture({buffer:d.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:l},{texture:t.handle,mipLevel:r},[o,l,1]),o/=2,l/=2}t.device.submitCommandEncoder(s),t.ready=!0}else{const e=i(r,t.height,t.depth);a=e[1];const o={dataArray:n.dataArray?n.dataArray:null,usage:Cb.Texture};o.nativeArray=e[0];const l=t.device.getBufferManager().getBuffer(o);s.copyBufferToTexture({buffer:l.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:t.height},{texture:t.handle},[t.width,t.height,t.depth]),t.device.submitCommandEncoder(s),t.ready=!0}},e.getScale=()=>{const e=pT(t.format);return 2===e.elementSize&&"float"===e.sampleType?1:255},e.getNumberOfComponents=()=>pT(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?"2d":"3d");const o=xb.newInstance({label:n});return o.create(e,r),o}}const Ab={device:null,handle:null,buffer:null,ready:!1,label:null};function Ib(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ab,n),jt.obj(e,t),jt.get(e,t,["handle","ready","width","height","depth","format","usage"]),jt.setGet(e,t,["device","label"]),Sb(e,t)}var wb={newInstance:jt.newInstance(Ib),extend:Ib};function Pb(e,t){t.classHierarchy.push("vtkWebGPUOpaquePass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=wb.newInstance({label:"opaquePassColor"}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView("opaquePassColorTexture");t.renderEncoder.setColorTextureView(0,n),t.depthFormat="depth32float",t.depthTexture=wb.newInstance({label:"opaquePassDepth"}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("opaquePassDepthTexture");t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation("opaquePass"),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=_T.newInstance({label:"OpaquePass"}),t.renderEncoder.setPipelineHash("op")}}const Ob={renderEncoder:null,colorTexture:null,depthTexture:null};function Rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ob,n),iy.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),Pb(e,t)}var Mb={newInstance:jt.newInstance(Rb,"vtkWebGPUOpaquePass"),extend:Rb};function Eb(e,t){t.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=wb.newInstance({label:"translucentPassColor"}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView("oitpColorTexture");t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=wb.newInstance({label:"translucentPassAccumulate"}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView("oitpAccumTexture");t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=DT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash("oitpfsq"),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n")}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation("translucentPass"),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=_T.newInstance({label:"translucentRender"});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:void 0,clearValue:[1,0,0,0],loadOp:"clear",storeOp:"store"}],e.depthStencilAttachment={view:void 0,depthLoadOp:"load",depthStoreOp:"store"},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addOutput("f32","outAccum"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);","output.outColor = vec4<f32>(computedColor.rgb*w, w);","output.outAccum = computedColor.a;"]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash("oitpr"),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one"},alpha:{srcfactor:"one",dstFactor:"one"}}},{format:"r16float",blend:{color:{srcFactor:"zero",dstFactor:"one-minus-src"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=_T.newInstance({label:"translucentFinal"}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash("oitpf"),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}}const Db={colorTextureView:null,depthTextureView:null};function Vb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Db,n),iy.extend(e,t,n),jt.setGet(e,t,["colorTextureView","depthTextureView"]),Eb(e,t)}var Lb={newInstance:jt.newInstance(Vb,"vtkWebGPUOrderIndependentTranslucentPass"),extend:Vb};const{BufferUsage:Bb}=fb,{vtkErrorMacro:Nb}=jt;function _b(e,t){t.classHierarchy.push("vtkWebGPUUniformBuffer"),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?Nb(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:hT(n),offset:-1,nativeType:vT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:Bb.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Nb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Nb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join("\n")}}const Fb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function kb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"uniform"}},t.sendTime={},jt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,jt.get(e,t,["binding","bindGroupTime"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label","sizeInBytes"]),_b(e,t)}var Gb={newInstance:jt.newInstance(kb,"vtkWebGPUUniformBuffer"),extend:kb};const{BufferUsage:Ub}=fb,{vtkErrorMacro:zb}=jt;function Wb(e,t){t.classHierarchy.push("vtkWebGPUStorageBuffer"),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void zb(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=hT(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:vT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:Ub.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void zb(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void zb(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\n};\nstruct ${t.label}Struct\n{\n  values: array<${t.label}StructEntry>,\n};\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\n`),r.join("\n")},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}const Hb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function jb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},jt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"read-only-storage"}},jt.get(e,t,["bindGroupTime"]),jt.setGet(e,t,["device","bindGroupLayoutEntry","label","numberOfInstances","sizeInBytes"]),Wb(e,t)}var Kb={newInstance:jt.newInstance(jb,"vtkWebGPUStorageBuffer"),extend:jb};const $b="\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n",qb=new Float64Array(16),Xb=new Float64Array(16);function Yb(e,t){t.classHierarchy.push("vtkWebGPUVolumePassFSQ"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);"]).result,r.setCode(o),t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription("fragment");let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===zg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);")):(s.push(`  sampleColor = traverseVals[${e}];`),s.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);"));a=Qy.substitute(a,"//VTK::Volume::CompositeCalls",i).result,a=Qy.substitute(a,"//VTK::Volume::TraverseCalls",s).result,a=Qy.substitute(a,"//VTK::Volume::TraverseDec",[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===zg.COMPOSITE_BLEND?l=!0:n===zg.MAXIMUM_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.MINIMUM_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.AVERAGE_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.ADDITIVE_INTENSITY_BLEND&&(a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result)}l&&(a=Qy.substitute(a,"//VTK::Volume::Loop",["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result),o.setCode(a)},t.shaderReplacements.set("replaceShaderVolume",e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:"rgba8unorm"},r=n.getTextureManager().getTexture(e).createView("tfunTexture");t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:"r16float"},r=n.getTextureManager().getTexture(e).createView("ofunTexture");t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),d=r.getInputData();g(qb),b(qb,qb,o);const p=n.getMatrix();m(Xb,p),h(Xb,Xb),T(qb,Xb,qb);const f=d.getWorldToIndex();T(qb,f,qb);const v=d.getDimensions();g(Xb),x(Xb,Xb,[1/v[0],1/v[1],1/v[2]]),T(qb,Xb,qb);for(let t=0;t<16;t++)a[16*e+t]=qb[t];h(qb,qb);for(let t=0;t<4;t++)i[16*e+4*t]=qb[4*t],i[16*e+4*t+1]=qb[4*t+1],i[16*e+4*t+2]=qb[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/v[0],s[4*e+1]=1/v[1],s[4*e+2]=1/v[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const y=d.getSpacing();c[4*e]=y[0],c[4*e+1]=y[1],c[4*e+2]=y[2],c[4*e+3]=1;const C=t.textureViews[e+4].getTexture().getScale(),S=r.getIpScalarRange();u[4*e]=S[0]/C,u[4*e+1]=S[1]/C,u[4*e+2]=r.getFilterMode()}t.SSBO.addEntry("SCTCMatrix","mat4x4<f32>"),t.SSBO.addEntry("planeNormals","mat4x4<f32>"),t.SSBO.addEntry("shade","vec4<f32>"),t.SSBO.addEntry("tstep","vec4<f32>"),t.SSBO.addEntry("spacing","vec4<f32>"),t.SSBO.addEntry("ipScalarRange","vec4<f32>"),t.SSBO.setAllInstancesFromArray("SCTCMatrix",a),t.SSBO.setAllInstancesFromArray("planeNormals",i),t.SSBO.setAllInstancesFromArray("shade",l),t.SSBO.setAllInstancesFromArray("tstep",s),t.SSBO.setAllInstancesFromArray("spacing",c),t.SSBO.setAllInstancesFromArray("ipScalarRange",u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),y=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=pT(l),u={scale:[255],offset:[0]};2===c.elementSize&&"float"===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);y[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else y[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry("cScale","f32"),t.componentSSBO.addEntry("cShift","f32"),t.componentSSBO.addEntry("oScale","f32"),t.componentSSBO.addEntry("oShift","f32"),t.componentSSBO.addEntry("goShift","f32"),t.componentSSBO.addEntry("goScale","f32"),t.componentSSBO.addEntry("gomin","f32"),t.componentSSBO.addEntry("gomax","f32"),t.componentSSBO.setAllInstancesFromArray("cScale",d),t.componentSSBO.setAllInstancesFromArray("cShift",p),t.componentSSBO.setAllInstancesFromArray("oScale",f),t.componentSSBO.setAllInstancesFromArray("oShift",v),t.componentSSBO.setAllInstancesFromArray("goScale",A),t.componentSSBO.setAllInstancesFromArray("goShift",S),t.componentSSBO.setAllInstancesFromArray("gomin",y),t.componentSSBO.setAllInstancesFromArray("gomax",C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue("SampleDistance",r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=vb.newInstance({label:"clampSampler"}),t.clampSampler.create(t.device,{minFilter:"linear",magFilter:"linear"}))},e.computePipelineHash=()=>{t.pipelineHash="volfsq";for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}const Zb={volumes:null,rowLength:1024,lastVolumeLength:0};function Qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zb,n),DT.extend(e,t,n),t.fragmentShaderTemplate=$b,t.UBO=Gb.newInstance({label:"mapperUBO"}),t.UBO.addEntry("SampleDistance","f32"),t.SSBO=Kb.newInstance({label:"volumeSSBO"}),t.componentSSBO=Kb.newInstance({label:"componentSSBO"}),t.lutBuildTime={},jt.obj(t.lutBuildTime,{mtime:0}),Yb(e,t)}var Jb={newInstance:jt.newInstance(Qb,"vtkWebGPUVolumePassFSQ"),extend:Qb};const{Representation:ex}=ms,{BufferUsage:tx,PrimitiveTypes:nx}=fb,rx=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],ox="\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function ax(e,t){t.classHierarchy.push("vtkWebGPUVolumePass"),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=Jb.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=DT.newInstance(),t._volumeCopyQuad.setPipelineHash("volpassfsq"),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._copyUBO=Gb.newInstance({label:"mapperUBO"}),t._copyUBO.addEntry("tscale","vec2<f32>"),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Yo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray("tscale",[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray("tscale",[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=jt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:tx.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:nx.Triangles,representation:ex.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:tx.PointArray,format:"float32x4",hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,["vertexBC"]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+rx[e][0],l[n++]=r+rx[e][1],l[n++]=r+rx[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation("volumeDepthRangePass"),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=_T.newInstance({label:"VolumePass DepthRange"}),t._depthRangeEncoder.setPipelineHash("volr"),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor1"),t.addOutput("vec4<f32>","outColor2");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);","output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"max"},alpha:{srcfactor:"one",dstFactor:"one",operation:"max"}}},{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"min"},alpha:{srcfactor:"one",dstFactor:"one",operation:"min"}}}]}}),t._depthRangeTexture=wb.newInstance({label:"volumePassMaxDepth"}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView("maxTexture");t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=wb.newInstance({label:"volumePassDepthMin"}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView("minTexture");t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=wb.newInstance({label:"volumePassColor"}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView("volumePassColorTexture"),t._colorTextureView.addSampler(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._clearEncoder=_T.newInstance({label:"VolumePass Clear"}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),t._clearEncoder.setPipelineHash("volpf"),t._clearEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=_T.newInstance({label:"volumePassCopy"}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._copyEncoder.setPipelineHash("volcopypf"),t._copyEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=_T.newInstance({label:"volumePassMerge"}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash("volpf"),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}const ix={colorTextureView:null,depthTextureView:null,volumes:null};function sx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ix,n),iy.extend(e,t,n),t._mapper=OT.newInstance(),t._mapper.setFragmentShaderTemplate(ox),t._mapper.getShaderReplacements().set("replaceShaderVolumePass",((e,t,n)=>{t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")})),t._boundsPoly=Cu.newInstance(),t._lastMTimes=[],jt.setGet(e,t,["colorTextureView","depthTextureView"]),ax(e,t)}var lx={newInstance:jt.newInstance(sx,"vtkWebGPUVolumePass"),extend:sx};function cx(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e),t.opaquePass||(t.opaquePass=Mb.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation("queryPass"),i.traverse(e),e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Lb.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=lx.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=_T.newInstance({label:"forwardPassBlit"}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._finalBlitEncoder.setPipelineHash("fpf"),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}}),t._fsqSampler=vb.newInstance({label:"finalPassSampler"}),t._fsqSampler.create(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._fullScreenQuad=DT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash("fpfsq"),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._finalBlitOutputTextureView=xb.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}const ux={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function dx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ux,n),iy.extend(e,t,n),jt.setGet(e,t,["opaquePass","translucentPass","volumePass"]),cx(e,t)}var px={newInstance:jt.newInstance(dx,"vtkForwardPass"),extend:dx};const{VtkDataTypes:fx}=Ns;function gx(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format="r";break;case 2:e.format="rg";break;default:e.format="rgba"}switch(e.dataArray.getDataType()){case fx.UNSIGNED_CHAR:e.format+="8unorm";break;case fx.FLOAT:case fx.UNSIGNED_INT:case fx.INT:case fx.DOUBLE:case fx.UNSIGNED_SHORT:case fx.SHORT:default:e.format+="16float"}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format="rgba8unorm"),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.nativeArray=e.jsImageData.data),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=wb.newInstance();return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas)&&n.writeImageData(e),n}t.classHierarchy.push("vtkWebGPUTextureManager"),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=e=>{const r={time:e.getMTime()};return e.getInputData()?r.imageData=e.getInputData():e.getImage()?r.image=e.getImage():e.getJsImageData()?r.jsImageData=e.getJsImageData():e.getCanvas()&&(r.canvas=e.getCanvas()),n(r),r.mipLevel=e.getMipLevel(),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)}}const mx={handle:null,device:null};function hx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mx,n),jt.obj(e,t),jt.setGet(e,t,["device"]),gx(e,t)}var vx={newInstance:jt.newInstance(hx),extend:hx};class yx extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&"object"==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}function Tx(e,t){t.classHierarchy.push("vtkWebGPUDevice"),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro("layout not found"),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro("attempt to cache an object without a hash"),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}const bx={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function xx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bx,n),yt(e,t),At(e,t,["handle"]),bt(e,t,["bufferManager","shaderCache","textureManager"]),t.objectCache=new yx,t.shaderCache=Qy.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=fb.newInstance(),t.bufferManager.setDevice(e),t.textureManager=vx.newInstance(),t.textureManager.setDevice(e),t.pipelines={},Tx(e,t)}var Cx={newInstance:Dt(xx,"vtkWebGPUDevice"),extend:xx};function Sx(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelectionPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=wb.newInstance({label:"hardwareSelectorColor"}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView("hardwareSelectColorTexture");t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=wb.newInstance({label:"hardwareSelectorDepth"}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("hardwareSelectDepthTexture");t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation("cameraPass"),r.traverse(e),e.setCurrentOperation("opaquePass"),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=_T.newInstance({label:"HardwareSelectionPass"}),t.selectionRenderEncoder.setPipelineHash("sel"),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<u32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba32uint",blend:void 0}]}})}}const Ax={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function Ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ax,n),iy.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),Sx(e,t)}var wx={newInstance:jt.newInstance(Ix,"vtkWebGPUHardwareSelectionPass"),extend:Ix};const{SelectionContent:Px,SelectionField:Ox}=of,{FieldAssociations:Rx}=ll,{vtkErrorMacro:Mx}=jt;function Ex(e){return`${e.propID} ${e.compositeID}`}function Dx(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Vx(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=Dx(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=Dx(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Vx(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Vx(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Vx(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Vx(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Vx(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}function Lx(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelector"),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return Mx("Renderer and view must be set before calling Select."),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=WT.newInstance({label:"hardwareSelectColorBuffer"});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=WT.newInstance({label:"hardwareSelectDepthBuffer"}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:"depth-only"},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Vx(e,[n,t],0,u);if(r){const t=Ex(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=of.newInstance();switch(i.setContentType(Px.INDICES),e){case Rx.FIELD_ASSOCIATION_CELLS:i.setFieldType(Ox.CELL);break;case Rx.FIELD_ASSOCIATION_POINTS:i.setFieldType(Ox.POINT);break;default:Mx("Unknown field association")}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}const Bx={};function Nx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bx,n),Yp.extend(e,t,n),t._selectionPass=wx.newInstance(),jt.setGet(e,t,["_WebGPURenderWindow"]),jt.moveToProtected(e,t,["WebGPURenderWindow"]),Lx(e,t)}var _x={newInstance:jt.newInstance(Nx,"vtkWebGPUHardwareSelector"),extend:Nx};const Fx=Object.create(null);function kx(e,t){t.classHierarchy.push("vtkWebGPUViewNodeFactory")}const Gx={};function Ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gx,n),t.overrides=Fx,tn.extend(e,t,n),kx(0,t)}var zx={newInstance:jt.newInstance(Ux,"vtkWebGPUViewNodeFactory"),extend:Ux};const{vtkErrorMacro:Wx}=jt,Hx={position:"absolute",top:0,left:0,width:"100%",height:"100%"};function jx(e,t){t.classHierarchy.push("vtkWebGPURenderWindow"),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Wx("WebGPU is not enabled.");e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Wx("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),t.deleted||(t.device=Cx.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext("webgpu"))},e.releaseGraphicsResources=()=>{const n=iy.newInstance();n.setCurrentOperation("Release"),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Hx,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect(),l=t.renderable;l.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const c=r.toDataURL(n);r.remove(),e.invokeImageReady(c)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=WT.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Vd.fromHalf(r.colorValues[o]),s[n+1]=255*Vd.fromHalf(r.colorValues[o+1]),s[n+2]=255*Vd.fromHalf(r.colorValues[o+2]),s[n+3]=255*Vd.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=_x.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=jt.chain(e.delete,e.setViewStream)}const Kx={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:"pointer",containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const $x=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kx,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",Vy.extend(e,t,n),t.myFactory=zx.newInstance(),t.renderPasses[0]=px.newInstance(),t.selector||(t.selector=_x.newInstance(),t.selector.setWebGPURenderWindow(e)),jt.event(e,t,"imageReady"),jt.event(e,t,"initialized"),jt.get(e,t,["commandEncoder","device","presentationFormat","useBackgroundImage","xrSupported"]),jt.setGet(e,t,["initialized","context","canvas","device","renderPasses","notifyStartCaptureImage","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"windowResizeEvent"),jx(e,t)}),"vtkWebGPURenderWindow");var qx;pv("WebGPU",$x),qx=$x,Fx.vtkRenderWindow=qx;const Xx=ny(),Yx={margin:"0",padding:"0",position:"absolute",top:"0",left:"0",width:"100%",height:"100%",overflow:"hidden"},Zx={position:"absolute",left:"25px",top:"25px",backgroundColor:"white",borderRadius:"5px",listStyle:"none",padding:"5px 10px",margin:"0",display:"block",border:"solid 1px black",maxWidth:"calc(100% - 70px)",maxHeight:"calc(100% - 60px)",overflow:"auto"};function Qx(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}function Jx(e,t){t.classHierarchy.push("vtkFullScreenRenderWindow");const n=document.querySelector("body");function r(t){"c"===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement("div"),Qx(t.container,t.containerStyle||Yx),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height="100%",n.style.height="100%",n.style.padding="0",n.style.margin="0"),t.renderWindow=vv.newInstance(),t.renderer=uv.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(Xx.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Bv.newInstance(),t.interactor.setInteractorStyle(Jv.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?"block":"none")},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement("div"),Qx(t.controlContainer,t.controlPanelStyle||Zx),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener("keypress",r)},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=jt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,(()=>{t.rootContainer?.removeEventListener("keypress",r),window.removeEventListener("resize",e.resize)}),e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener("resize",e.resize),e.resize()}const eC={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function tC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eC,n),jt.obj(e,t),jt.get(e,t,["renderWindow","renderer","apiSpecificRenderWindow","interactor","rootContainer","container","controlContainer"]),Jx(e,t)}var nC={newInstance:jt.newInstance(tC),extend:tC},rC={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:oC,Scale:aC}=rC,{ScalarMappingTarget:iC}=El,{vtkDebugMacro:sC,vtkErrorMacro:lC,vtkWarningMacro:cC}=jt;function uC(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function dC(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function pC(e,t,n,r){const o=[],a=[];wa(t,o),wa(n,a);const i=[],s=[];uC(o,i),uC(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=dC(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=dC(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Pa(u,r)}function fC(e,t){t.classHierarchy.push("vtkColorTransferFunction"),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return lC("Midpoint outside range [0.0, 1.0]"),-1;if(s<0||s>1)return lC("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[],l=[n,r,o];return xa(l,s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];xa([n,r,o],u),xa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.getTable=(n,r,o,a)=>{const i=Number(n),s=Number(r);if(_a(i)||_a(s)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let l=0;const c=t.nodes.length;let u=0,d=0,p=0;0!==c&&(u=t.nodes[c-1].r,d=t.nodes[c-1].g,p=t.nodes[c-1].b);let f=0,g=0,m=0;const h=[0,0,0],v=[0,0,0];let y=0,T=0;const b=[];let x=t.scale===aC.LOG10;x&&(x=t.mappingRange[0]>0);let C=0,S=0,A=0;x&&(C=Math.log10(i),S=Math.log10(s));for(let n=0;n<o;n++){const r=3*n;if(o>1?x?(A=C+n/(o-1)*(S-C),f=10**A):f=i+n/(o-1)*(s-i):x?(A=.5*(C+S),f=10**A):f=.5*(i+s),t.discretize){const e=t.mappingRange;if(f>=e[0]&&f<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)f=e[0]+r/2;else{const t=(f-e[0])/r,o=Eo(n*t);f=e[0]+o/(n-1)*r}}}for(;l<c&&f>t.nodes[l].x;)l++,l<c&&(g=t.nodes[l-1].x,m=t.nodes[l].x,x&&(g=Math.log10(g),m=Math.log10(m)),h[0]=t.nodes[l-1].r,v[0]=t.nodes[l].r,h[1]=t.nodes[l-1].g,v[1]=t.nodes[l].g,h[2]=t.nodes[l-1].b,v[2]=t.nodes[l].b,y=t.nodes[l-1].midpoint,T=t.nodes[l-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(f>t.mappingRange[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=u,a[r+1]=d,a[r+2]=p));else if(f<t.mappingRange[0]||La(f)&&f<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):c>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===l&&(Math.abs(f-i)<1e-6||t.discretize))c>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=x?(A-g)/(m-g):(f-g)/(m-g),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),T>.99){if(e<.5){a[r]=h[0],a[r+1]=h[1],a[r+2]=h[2];continue}a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}if(T<.01){if(t.colorSpace===oC.RGB)a[r]=(1-e)*h[0]+e*v[0],a[r+1]=(1-e)*h[1]+e*v[1],a[r+2]=(1-e)*h[2]+e*v[2];else if(t.colorSpace===oC.HSV){const n=[],o=[];ba(h,n),ba(v,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],xa(i,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===oC.LAB){const t=[],n=[];wa(h,t),wa(v,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Pa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===oC.DIVERGING?(pC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):lC("ColorSpace set to invalid value.",t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*T):e>.5&&(e=1-.5*(2*(1-e))**(1+10*T));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===oC.RGB)for(let e=0;e<3;e++)u=v[e]-h[e],d=(1-T)*u,a[r+e]=i*h[e]+s*v[e]+l*d+c*d;else if(t.colorSpace===oC.HSV){const e=[],n=[];ba(h,e),ba(v,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-T)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);xa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===oC.LAB){const e=[],t=[];wa(h,e),wa(v,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-T)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Pa(n,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===oC.DIVERGING?(pC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):lC("ColorSpace set to invalid value.");for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return lC("Attempting to lookup a value with no points in the function"),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(lC("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return lC("Index out of range!"),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>{if(t.indexedLookup&&e.getSize())return e.getSize();if(t.tableSize)return t.tableSize;const n=t.nodes?.length??0;return Math.max(4094,n)},e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=e.getRange();if(a[1]===o[1]&&a[0]===o[0])return;if(o[1]===o[0])return void lC("attempt to set zero width color range");const i=(o[1]-o[0])/(a[1]-a[0]),s=o[0]-a[0]*i;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*i+s;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):sC("Transfer Function Has No Points!")},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void cC("Transfer Function Has No Points!");const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===iC.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===iC.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===iC.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===iC.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=oC[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(lC(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=oC.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}const gC={clamping:!0,colorSpace:oC.RGB,hSVWrap:!0,scale:aC.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function mC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gC,n),El.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},jt.obj(t.buildTime),jt.get(e,t,["buildTime","mappingRange"]),jt.setGet(e,t,["useAboveRangeColor","useBelowRangeColor","discretize","numberOfValues",{type:"enum",name:"colorSpace",enum:oC},{type:"enum",name:"scale",enum:aC}]),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"]),fC(e,t)}var hC={newInstance:jt.newInstance(mC,"vtkColorTransferFunction"),extend:mC,...rC},vC={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:yC,ScaleModes:TC}=vC,{vtkErrorMacro:bC}=jt;function xC(e,t){t.classHierarchy.push("vtkGlyph3DMapper"),e.getOrientationModeAsString=()=>jt.enumToString(yC,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(yC.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(yC.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(yC.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>jt.enumToString(TC,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(TC.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(TC.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(TC.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Fa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===TC.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(bC("Cannot scale by components since scale array does not have 3 components."),a=null);const l=r.getBounds(),c=[];Wi.getCorners(l,c),t.bounds[0]=Wi.INIT_BOUNDS[0],t.bounds[1]=Wi.INIT_BOUNDS[1],t.bounds[2]=Wi.INIT_BOUNDS[2],t.bounds[3]=Wi.INIT_BOUNDS[3],t.bounds[4]=Wi.INIT_BOUNDS[4],t.bounds[5]=Wi.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const y=t.normalArray.buffer,w=[],P=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,P),t.orientationMode){case yC.MATRIX:T(n,n,[...P.slice(0,3),0,...P.slice(3,6),0,...P.slice(6,9),0,0,0,0,1]);break;case yC.ROTATION:I(n,n,P[2]),S(n,n,P[0]),A(n,n,P[1]);break;case yC.DIRECTION:if(0===P[1]&&0===P[2])P[0]<0&&A(n,n,3.1415926);else{const e=$o(P),t=[];t[0]=(P[0]+e)/2,t[1]=P[1]/2,t[2]=P[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case TC.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=$o(w,s),m[1]=m[0],m[2]=m[0];break;case TC.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case TC.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)Vn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(y,36*e,9);se(r,n),ge(r,r),fe(r,r)}const O=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&O&&(R.build(),t.colorArray=R.mapScalars(O,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}const CC={orient:!0,orientationMode:yC.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:TC.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function SC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,CC,n),uc.extend(e,t,n),jt.algo(e,t,2,0),t.buildTime={},jt.obj(t.buildTime,{mtime:0}),t.boundsTime={},jt.obj(t.boundsTime,{mtime:0}),jt.setGet(e,t,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),jt.get(e,t,["colorArray","matrixArray","normalArray","buildTime"]),xC(e,t)}var AC={newInstance:jt.newInstance(SC,"vtkGlyph3DMapper"),extend:SC,...vC};const{vtkErrorMacro:IC}=jt;function wC(e,t){t.classHierarchy.push("vtkPiecewiseFunction"),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";default:return"Varied"}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(IC("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return IC("Index out of range!"),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return IC("Midpoint outside range [0.0, 1.0]"),-1;if(a<0||a>1)return IC("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,y=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>y?y:o[v]}}}}const PC={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PC,n),jt.obj(e,t),t.nodes=[],jt.setGet(e,t,["allowDuplicateScalars","clamping"]),jt.setArray(e,t,["range"],2),jt.getArray(e,t,["range"]),wC(e,t)}var RC={newInstance:jt.newInstance(OC,"vtkPiecewiseFunction"),extend:OC};const{InterpolationType:MC,OpacityMode:EC}=Ug,{vtkErrorMacro:DC}=jt;function VC(e,t){t.classHierarchy.push("vtkVolumeProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(DC("Bad index - must be between 0 and 3"),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=RC.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=hC.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=RC.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return DC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(DC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(MC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(MC.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(MC.FAST_LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(MC,t.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=jt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=jt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]}))}const LC={colorMixPreset:null,independentComponents:!0,interpolationType:MC.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,LC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:EC.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}jt.setGet(e,t,["colorMixPreset","independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),VC(e,t)}var NC={newInstance:jt.newInstance(BC,"vtkVolumeProperty"),extend:BC,...Ug};const{vtkDebugMacro:_C}=jt;function FC(e,t){t.classHierarchy.push("vtkVolume"),e.getVolumes=()=>e,e.makeProperty=NC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){_C("Recomputing bounds..."),t.mapperBounds=n.map((e=>e));const r=[];Wi.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}var r;return t.bounds},e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}const kC={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function GC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kC,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper"]),jt.getArray(e,t,["bounds"],6),FC(e,t)}var UC={newInstance:jt.newInstance(GC,"vtkVolume"),extend:GC};const{BlendMode:zC,FilterMode:WC}=Wg,HC={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=RC.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function jC(e,t){t.classHierarchy.push("vtkVolumeMapper");const n={...e};e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.update=()=>{e.getInputData()},e.setBlendModeToComposite=()=>{e.setBlendMode(zC.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(zC.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(zC.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(zC.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(zC.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(zC.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>jt.enumToString(zC,t.blendMode),e.setAverageIPScalarRange=(t,n)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>jt.enumToString(WC,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(WC.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(WC.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(WC.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(Ma(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(Ma(e,0,1)),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),e.setAnisotropy=e=>n.setAnisotropy(Ma(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Eo(Ma(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}const KC={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:zC.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:WC.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function $C(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KC,n),zs(e,t,n),jt.setGet(e,t,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","volumeShadowSamplingDistFactor","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius"]),jt.setGetArray(e,t,["ipScalarRange"],2),jt.event(e,t,"lightingActivated"),jC(e,t)}var qC={newInstance:jt.newInstance($C,"vtkVolumeMapper"),extend:$C,...HC};const{InterpolationType:XC}=pg,{vtkErrorMacro:YC}=jt;function ZC(e,t){t.classHierarchy.push("vtkImageProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].rGBTransferFunction!==a&&(t.componentData[o].rGBTransferFunction=a,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].piecewiseFunction!==a&&(t.componentData[o].piecewiseFunction=a,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=t,o=n;return Number.isInteger(t)||(o=t,r=0),e.setPiecewiseFunction(r,o)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return YC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(YC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(XC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(XC.LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(XC,t.interpolationType)}const QC={independentComponents:!1,interpolationType:XC.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function JC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,QC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}jt.setGet(e,t,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),ZC(e,t)}var eS={newInstance:jt.newInstance(JC,"vtkImageProperty"),extend:JC};const{vtkDebugMacro:tS}=jt;function nS(e,t){t.classHierarchy.push("vtkImageSlice"),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=eS.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){tS("Recomputing bounds..."),t.mapperBounds=n.map((e=>e)),e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),Wi.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}var r;return t.bounds},e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!Wi.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),Wi.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}if(null!==t.property){let n=t.property.getMTime();e=n>e?n:e,null!==t.property.getRGBTransferFunction()&&(n=t.property.getRGBTransferFunction().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}const rS={mapper:null,property:null,forceOpaque:!1,forceTranslucent:!1,bounds:[...Wi.INIT_BOUNDS]};function oS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rS,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper","forceOpaque","forceTranslucent"]),jt.getArray(e,t,["bounds"],6),nS(e,t)}var aS={newInstance:jt.newInstance(oS,"vtkImageSlice"),extend:oS};function iS(e,t){t.classHierarchy.push("vtkAbstractImageMapper"),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(jt.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),Fa())}const sS={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};var lS=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sS,n),zs(e,t,n),jt.setGet(e,t,["slice","useCustomExtents"]),jt.setGetArray(e,t,["customDisplayExtent"],6),jt.setGetArray(e,t,["backgroundColor"],4),iS(e,t)};function cS(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA("vtkImageArrayMapper")?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Mn(c,c);const u=ii.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:uS,otherStaticMethods:dS}=Kl,{SlicingMode:pS}=yg;function fS(e,t){function n(){let n;switch(t.slicingMode){case pS.X:n=0;break;case pS.Y:n=1;break;case pS.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=ka(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push("vtkImageMapper"),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case pS.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case pS.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case pS.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case pS.I:l=Ma(a[0],i[0],i[1]);break;case pS.J:l=Ma(a[1],i[2],i[3]);break;case pS.K:l=Ma(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case pS.I:case pS.J:case pS.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case pS.X:e.setSlice(r[0]);break;case pS.Y:e.setSlice(r[1]);break;case pS.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(pS.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(pS.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(pS.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(pS.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(pS.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(pS.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case pS.X:n[0]=1;break;case pS.Y:n[1]=1;break;case pS.Z:n[2]=1;break;case pS.I:ea(r,[1,0,0],n);break;case pS.J:ea(r,[0,1,0],n);break;case pS.K:ea(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==pS.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Fa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case pS.I:r[0]=a,r[1]=a;break;case pS.J:r[2]=a,r[3]=a;break;case pS.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Fa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case pS.I:a[0]=s-r,a[1]=s+r;break;case pS.J:a[2]=s-r,a[3]=s+r;break;case pS.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=cS(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=cS(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}const gS={slicingMode:pS.NONE,closestIJKAxis:{ijkMode:pS.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function mS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gS,n),lS(e,t,n),jt.get(e,t,["slicingMode"]),jt.setGet(e,t,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),Kl.implementCoincidentTopologyMethods(e,t),fS(e,t)}var hS={newInstance:jt.newInstance(mS,"vtkImageMapper"),extend:mS,...uS,...dS,...yg};const{vtkErrorMacro:vS}=jt;function yS(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}function TS(e,t){t.classHierarchy.push("vtkAppendPolyData"),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void vS("No input specified.");if(1===o)return void(r[0]=n[0]);const a=Cu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===Xs.SINGLE?s=Cs.FLOAT:t.outputPointsPrecision===Xs.DOUBLE&&(s=Cs.DOUBLE);const v=Sc.newInstance({dataType:s});v.setNumberOfPoints(i);const y=v.getData(),T=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Ns.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Ns.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Ns.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];y.set(t.getPoints().getData(),3*i),yS(T,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),yS(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),yS(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),yS(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(T),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}const bS={outputPointsPrecision:Xs.DEFAULT};function xS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bS,n),jt.setGet(e,t,["outputPointsPrecision"]),jt.obj(e,t),jt.algo(e,t,1,1),TS(e,t)}var CS={newInstance:jt.newInstance(xS,"vtkAppendPolyData"),extend:xS};function SS(e,t){t.classHierarchy.push("vtkConeSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=jt.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Kf().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=Cu.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}const AS={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:"Float64Array"};function IS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AS,n),jt.obj(e,t),jt.setGet(e,t,["height","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),SS(e,t)}var wS={newInstance:jt.newInstance(IS,"vtkConeSource"),extend:IS};function PS(e,t){t.classHierarchy.push("vtkCylinderSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=jt.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Ns.newInstance({numberOfComponents:3,values:u,name:"Normals"}),p=new Float32Array(2*a),f=Ns.newInstance({numberOfComponents:2,values:p,name:"TCoords"}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],y=[0,0],T=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],y[0]=Math.abs(2*e/t.resolution-1),T[0]=y[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],y[1]=0,T[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],y[0]=h[0],T[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],y[1]=h[2],T[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*r+e]=T[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Kf().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=Cu.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}const OS={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function RS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,OS,n),jt.obj(e,t),jt.setGet(e,t,["height","initAngle","otherRadius","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),PS(e,t)}var MS={newInstance:jt.newInstance(RS,"vtkCylinderSource"),extend:RS};function ES(e,t){t.classHierarchy.push("vtkArrowSource"),e.requestData=function(e,n){if(t.deleted)return;const r=MS.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();jf().rotateZ(-90).apply(a).apply(i);const s=wS.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Kf().translate(1-.5*t.tipLength,0,0).apply(c);const u=CS.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Kf().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Kf().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Kf().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}const DS={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:"Float64Array"};function VS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,DS,n),jt.obj(e,t),jt.setGet(e,t,["tipResolution","tipRadius","tipLength","shaftResolution","shaftRadius","invert"]),jt.setGetArray(e,t,["direction"],3),jt.algo(e,t,0,1),ES(e,t)}var LS={newInstance:jt.newInstance(VS,"vtkArrowSource"),extend:VS};function BS(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];jf().translate(...n).apply(e.getPoints().getData())}function NS(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=e.getPoints().getBounds(),o=[0,0,0];o[t]=n?-r[2*t+1]:-r[2*t],jf().translate(...o).apply(e.getPoints().getData())}function _S(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Ns.newInstance({name:"color",numberOfComponents:3,values:a}))}function FS(e,t){t.classHierarchy.push("vtkAxesActor");const n=uc.newInstance();e.setMapper(n),e.update=()=>{let e={...t.config,...t.xConfig};const r=LS.newInstance({direction:[1,0,0],...e}).getOutputData();t.config.recenter?BS(r):NS(r,0,e.invert),_S(r,...e.color),e={...t.config,...t.yConfig};const o=LS.newInstance({direction:[0,1,0],...e}).getOutputData();t.config.recenter?BS(o):NS(o,1,e.invert),_S(o,...e.color),e={...t.config,...t.zConfig};const a=LS.newInstance({direction:[0,0,1],...e}).getOutputData();t.config.recenter?BS(a):NS(a,2,e.invert),_S(a,...e.color);const i=CS.newInstance();i.setInputData(r),i.addInputData(o),i.addInputData(a),n.setInputConnection(i.getOutputPort())},e.update();const r=jt.debounce(e.update,0);e.setXAxisColor=t=>e.setXConfig({...e.getXConfig(),color:t}),e.setYAxisColor=t=>e.setYConfig({...e.getYConfig(),color:t}),e.setZAxisColor=t=>e.setZConfig({...e.getZConfig(),color:t}),e.getXAxisColor=()=>t.getXConfig().color,e.getYAxisColor=()=>t.getYConfig().color,e.getZAxisColor=()=>t.getZConfig().color,t._onConfigChanged=r,t._onXConfigChanged=r,t._onYConfigChanged=r,t._onZConfigChanged=r}function kS(e){return{config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1,...e?.config},xConfig:{color:[255,0,0],invert:!1,...e?.xConfig},yConfig:{color:[255,255,0],invert:!1,...e?.yConfig},zConfig:{color:[0,128,0],invert:!1,...e?.zConfig}}}function GS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};bs.extend(e,t,kS(n)),jt.setGet(e,t,["config","xConfig","yConfig","zConfig"]),FS(e,t)}var US={newInstance:jt.newInstance(GS,"vtkAxesActor"),extend:GS};const zS="resetcamera",WS="orientation",HS={MODE_RESET_CAMERA:zS,MODE_ORIENTATION:WS,MODE_SAME:"same"};function jS(e,t){t.classHierarchy.push("vtkCameraSynchronizer");const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._srcRendererChanged=a,t._dstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName("position"),s=e.getReferenceByName("focalPoint"),l=e.getReferenceByName("viewUp"),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===WS?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],qo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===zS&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}const KS={mode:WS,focalPoint:[0,0,0],distance:6.8,active:!0};function $S(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KS,n),yt(e,t),At(e,t,["mode","active","srcRenderer","dstRenderer","distance"]),Pt(e,t,["focalPoint"],3,0),jS(e,t)}var qS={newInstance:Dt($S,"vtkCameraSynchronizer"),extend:$S,SynchronizationMode:HS};const XS={},YS={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=qS.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:qS.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var ZS=function(e,t,n){const r=e.get("synchronizedViewId").synchronizedViewId;if(!t.behaviors||!r)return;XS[r]||(XS[r]={});const o=XS[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=qS.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];YS[e.type]?o[r]=new YS[e.type](n,e):console.log("No mapping for",e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const QS={},JS=/instance:\${([^}]+)}/,eA={},tA=[],nA={},rA={vtkPoints:Sc,vtkCellArray:vc,vtkDataArray:Ns};function oA(e){return e.map((e=>JS.exec(e))).filter((e=>e)).map((e=>e[1]))}function aA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),aA(e,t)})),t}function iA(e,t,n,r){if(!t)return Promise.reject(new Error("No instance provided."));const o=QS[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function sA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=QS[e];return n&&n.build?n.build(t):(console.log("No builder for",e),null)}function lA(){Object.keys(QS).forEach((e=>{delete QS[e]}))}function cA(){Object.keys(eA).forEach((e=>{delete eA[e]}))}function uA(e){if(1===e[1].length)return-1===tA.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===tA.indexOf(e[1][n]);return t}function dA(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(nA[r]){const{key:n,value:o}=nA[r];if(!n||e.properties[n]===o)return void tA.push((e=>`instance:\${${e}}`)(t))}let o=n.getInstance(t);o||(o=sA(r,{managedInstanceId:t}),n.registerInstance(t,o)),iA(r,o,e,n)})),t.calls&&t.calls.filter(uA).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=JS.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:"addArray",a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:"vtkDataArray",l=rA[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log("Error fetching array",JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error("Error in array handling for state",JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function pA(e,t,n){eA[t.id]||dA(e,t,n),eA[t.id]=!0}function fA(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function gA(e){const t=e.name?`_${e.name}`:"";return`${e.hash}_${e.dataType}${t}`}function mA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=gA(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=gA(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),fA(t.getPointData(),i.pointData),fA(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=dA(t,s,r);return r.end(),l}}const hA=mA(["points","polys","verts","lines","strips"]),vA=mA([]);function yA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:dA;sA||iA?QS[e]={build:t,update:n}:delete QS[e]}const TA={vtkMapper:["vtkOpenGLPolyDataMapper","vtkCompositePolyDataMapper2","vtkDataSetMapper"],vtkProperty:["vtkOpenGLProperty"],vtkRenderer:["vtkOpenGLRenderer"],vtkCamera:["vtkOpenGLCamera"],vtkColorTransferFunction:["vtkPVDiscretizableColorTransferFunction"],vtkActor:["vtkOpenGLActor","vtkPVLODActor"],vtkLight:["vtkOpenGLLight","vtkPVLight"],vtkTexture:["vtkOpenGLTexture"],vtkImageMapper:["vtkOpenGLImageSliceMapper"],vtkVolumeMapper:["vtkFixedPointVolumeRayCastMapper"]},bA={vtkAxesActor:{build:US.newInstance,update:dA},vtkRenderWindow:{build:vv.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(uA).filter((e=>"removeRenderer"===e[0])).forEach((e=>{oA(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),dA(e,t,n),ZS(e,t,n)}},vtkRenderer:{build:uv.newInstance,update:function(e,t,n){dA(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=aA(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(uA).filter((e=>"removeViewProp"===e[0])).forEach((e=>{oA(e[1]).forEach((e=>{const t=n.getInstance(e).get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:Nl.newInstance,update:dA},vtkCamera:{build:$h.newInstance,update:pA},vtkPolyData:{build:Cu.newInstance,update:hA},vtkImageData:{build:vl.newInstance,update:vA},vtkMapper:{build:uc.newInstance,update:dA},vtkGlyph3DMapper:{build:AC.newInstance,update:dA},vtkProperty:{build:ms.newInstance,update:dA},vtkActor:{build:bs.newInstance,update:dA},vtkLight:{build:Zh.newInstance,update:dA},vtkColorTransferFunction:{build:hC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Pu.newInstance,update:dA},vtkVolume:{build:UC.newInstance,update:dA},vtkVolumeMapper:{build:qC.newInstance,update:dA},vtkVolumeProperty:{build:NC.newInstance,update:dA},vtkImageSlice:{build:aS.newInstance,update:dA},vtkImageMapper:{build:hS.newInstance,update:dA},vtkImageProperty:{build:eS.newInstance,update:dA},vtkPiecewiseFunction:{build:RC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:$u.newInstance,update:dA},vtkScalarBarActor:{build:Fp.newInstance,update:dA}};function xA(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];e&&lA(),Object.keys(bA).forEach((e=>{const t=bA[e];yA(e,t.build,t.update)}))}function CA(){Object.keys(TA).forEach((e=>{TA[e].forEach((t=>{QS[t]=QS[e]}))}))}xA(),CA(),nA.vtkPVLight={};var SA={build:sA,update:iA,genericUpdater:dA,oneTimeGenericUpdater:pA,setTypeMapping:yA,clearTypeMapping:lA,getSupportedTypes:function(){return Object.keys(QS)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return cA();let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete eA[e]})),r},updateRenderWindow:function(e,t,n){return iA("vtkRenderWindow",e,t,n)},excludeInstance:function(e,t,n){nA[e]={key:t,value:n}},setDefaultMapping:xA,applyDefaultAliases:CA,alwaysUpdateCamera:function(){yA("vtkCamera",$h.newInstance),CA()}};const AA={};function IA(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if("string"==typeof t&&(i=Wm(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log("Error getting data array:"),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function wA(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function PA(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Et(t,n,"progressEvent"),Et(t,n,"progressDone"),t}function OA(){const e={};let t="default";return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function RA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"default",t=AA[e];return t||(t={...IA(),...wA(),...PA(),...OA()},AA[e]=t),t}function MA(e,t){let n=-1,r=100;const o=e=>e.get("managedInstanceId").managedInstanceId,a=()=>Bt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get("synchronizedViewId").synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),SA.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){SA.clearOneTimeUpdaters(a())}}}function EA(e,t){t.classHierarchy.push("vtkSynchronizableRenderWindow"),t.synchronizerContext||(t.synchronizerContext=RA(t.synchronizerContextName));const n=MA(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}const DA={synchronizerContextName:"default",synchronizerContext:null,synchronizedViewId:null};function VA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,DA,n),vv.extend(e,t),bt(e,t,["synchronizerContext"]),EA(e,t)}var LA={newInstance:Dt(VA,"vtkSynchronizableRenderWindow"),extend:VA,getSynchronizerContext:RA,setSynchronizerContext:function(e,t){AA[e]=t},clearSynchronizerContext:function(e){if(e&&AA[e]&&delete AA[e],!e){const e=Object.keys(AA);for(let t=0;t<e.length;t++)delete AA[e[t]]}},decorate:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default";const n=MA(e,RA(t));return{...n,...e,delete:Vt(e.delete,n.delete)}},createInstanceMap:wA,createArrayHandler:IA,createProgressHandler:PA,createSceneMtimeHandler:OA,vtkObjectManager:SA};const{vtkErrorMacro:BA,vtkDebugMacro:NA}=jt;let _A=0;function FA(e){const t=document.querySelector(`.webResource[data-url="${e}"]`);return t?t.innerHTML:null}function kA(e){return"/"===e[0]?e.substr(1):e}const GA={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=FA(kA(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=FA(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=kA([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/")),s=FA(i);if(null===s)a(new Error(`No such array ${i}`));else{if("string"===n.dataType){let e=atob(s);r.compression&&(e=Mh(Ph(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(Wm(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Mh(Ph(new Uint8Array(n.buffer))):n.buffer=Ph(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Nh!==n.ref.encode&&Nh&&(NA(`Swap bytes of ${n.name}`),_h(n.buffer,xs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&BA(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--_A&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url="${e}"]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};jm("html",(e=>GA));const{vtkErrorMacro:UA,vtkDebugMacro:zA}=jt;function WA(e){return function(e){return"/"===e[0]?e.substr(1):e}(function(e){return new URL(e,"http://any").pathname}(e))}const HA=function(e){let t=!1,n=0,r=null,o="";var a;return(a=e.zipContent,new Promise(((e,t)=>{"string"==typeof a?e(function(e,t){if(t){for(var n=new $m(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(Oh)return Oh.encode(e);var o=e.length,a=new $m(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new $m(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return hh(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error("Invalid datatype to unpack."))}))).then((n=>{r=Lh(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith("index.json")&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\.json$/,""),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||UA("ERROR!!! zip not ready...");const u=WA([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join("/"));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if("string"!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&("string"===e.dataType||"JSON"===e.dataType?e.buffer=Mh(Ph(new Uint8Array(e.buffer))):e.buffer=Ph(new Uint8Array(e.buffer)).buffer),"JSON"===e.ref.encode?e.values=JSON.parse(e.buffer):(Nh!==e.ref.encode&&Nh&&(zA(`Swap bytes of ${e.name}`),_h(e.buffer,xs[e.dataType])),e.values=jt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&UA(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(Mh(Ph(r))):JSON.parse(r),n()}}(i,s.compression,d);e(Mh(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];if(a.compression){if("gz"===a.compression){const e=Mh(Ph(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error("Invalid compression"))}return Promise.resolve(JSON.parse(Mh(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Mh(Lh(s))):Promise.reject(new Error("Invalid compression")):Promise.resolve(Mh(s))},fetchImage(e,n){const a=WA(n);t||UA("ERROR!!! zip not ready...");const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=zm(i.buffer);n.src=`data:image/${function(e){const t=e.split(".").pop().toLowerCase();return"jpg"===t?"jpeg":t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Ph(s).buffer):Promise.reject(new Error("Invalid compression")):Promise.resolve(s.buffer)}}};jm("zip",(e=>HA(e)));var jA=n(892),KA=n.n(jA),$A=n(760),qA=n.n($A),XA=n(311),YA=n.n(XA),ZA=n(192),QA=n.n(ZA),JA=n(60),eI=n.n(JA),tI=n(865),nI=n.n(tI),rI=n(34),oI={};oI.styleTagTransform=nI(),oI.setAttributes=QA(),oI.insert=YA().bind(null,"head"),oI.domAPI=qA(),oI.insertStyleElement=eI(),KA()(rI.Z,oI);var aI=rI.Z&&rI.Z.locals?rI.Z.locals:void 0;let iI=!0;function sI(e){e.preventDefault(),e.stopPropagation()}function lI(e,t){iI=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=nC.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:"100%",width:"100%",position:"absolute"}}).getRenderWindow(),o=LA.getSynchronizerContext(),a=LA.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement("div");n.setAttribute("class",aI.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=jt.formatBytesToProperUnit(e.loaded)};t.fileURL?zh.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Km("zip",{zipContent:t,callback:e=>{r.fetchJSON(null,"index.json").then(i)}})})):zh.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Km("zip",{zipContent:t.file,callback:t=>{e.fetchJSON(null,"index.json").then(i)}})}else if(t.base64Str){const e=Wm(t.base64Str),n=Km("zip",{zipContent:e,callback:e=>{n.fetchJSON(null,"index.json").then(i)}})}}function cI(e){iI=!1;const t=document.querySelector(".content"),n=document.querySelector("body"),r=e||t||n;r!==e?(r.classList.add(aI.fullScreen),n.style.margin="0",n.style.padding="0"):(n.style.margin="0",n.style.padding="0");const o=document.createElement("div");o.innerHTML=`<div class="${aI.bigFileDrop}"/><input type="file" accept=".zip,.vtksz" style="display: none;"/>`,r.appendChild(o);const a=o.querySelector("input");function i(e){sI(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(".").slice(-1)[0];lI(r,{file:n[0],ext:e})}}a.addEventListener("change",i),o.addEventListener("drop",i),o.addEventListener("click",(e=>a.click())),o.addEventListener("dragover",sI)}const uI=ny();if(uI.url||uI.fileURL){const e=document.querySelector(".content"),t=document.querySelector("body"),n=e||t;n&&(n.classList.add(aI.fullScreen),t.style.margin="0",t.style.padding="0"),iI=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>lI(n,uI)))}setTimeout((()=>{iI&&cI()}),100),window.OfflineLocalView={initLocalFileLoader:cI,load:lI}},793:function(e){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,o,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=a),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),t.push(u))}},t}},490:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},22:function(e){"use strict";e.exports=function(e){return e[1]}},145:function(e,t,n){"use strict";var r=n(426),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||"function"==typeof(o=r)&&"[object Function]"===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},903:function(e,t,n){"use strict";e.exports=function(){if("object"==typeof globalThis)return globalThis;var e;try{e=this||new Function("return this")()}catch(e){if("object"==typeof window)return window;if("object"==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},152:function(e){"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},491:function(e){"use strict";"undefined"!=typeof self?e.exports=self:"undefined"!=typeof window?e.exports=window:e.exports=Function("return this")()},177:function(e,t,n){"use strict";var r=n(145),o=n(491),a=n(486),i=n(999),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},486:function(e,t,n){"use strict";var r=n(491);e.exports=function(){return"object"==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},999:function(e,t,n){"use strict";var r=n(145),o=n(486);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,"globalThis");t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,"globalThis",{configurable:!0,enumerable:!1,value:e,writable:!0})}else"object"==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},444:function(e,t,n){"use strict";var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(511),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===a.call(e),r=i(e),s=t&&"[object String]"===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&"prototype"===v||!o.call(e,v)||p.push(String(v));if(l)for(var y=function(e){if("undefined"==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),T=0;T<u.length;++T)y&&"constructor"===u[T]||!o.call(e,u[T])||p.push(u[T]);return p}}e.exports=r},426:function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(511),a=Object.keys,i=a?function(e){return a(e)}:n(444),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},511:function(e){"use strict";var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r="[object Arguments]"===n;return r||(r="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),r}},640:function(e,t,n){var r=n(64),o=n(115),a=n(965),i=n(332),s=n(65),l=n(182),c=n(293);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},64:function(e,t,n){var r;!function(e,o,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},182:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},115:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},65:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},332:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},965:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},293:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(a)]}}():e,3),r),f=new g(r),T=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return T.int32=function(){return 0|f.g(4)},T.quick=function(){return f.g(4)/4294967296},T.double=T,v(y(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(T,p,"global"in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function v(e,t){for(var n,r=e+"",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(706)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},594:function(e){e.exports=function(e){"use strict";var t=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function n(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function o(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function a(e){var t,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,r(e.substring(t-64,t)));for(o=(e=e.substring(t-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<o;t+=1)a[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}function i(e){var n,r="";for(n=0;n<4;n+=1)r+=t[e>>8*n+4&15]+t[e>>8*n&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=i(e[t]);return e.join("")}function l(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function u(){this.reset()}return s(a("hello")),"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),u.prototype.append=function(e){return this.appendBinary(l(e)),this},u.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,o=this._buff.length;for(t=64;t<=o;t+=64)n(this._hash,r(this._buff.substring(t-64,t)));return this._buff=this._buff.substring(t-64),this},u.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},u.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},u.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},u.prototype._finish=function(e,t){var r,o,a,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(n(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,n(this._hash,e)},u.hash=function(e,t){return u.hashBinary(l(e),t)},u.hashBinary=function(e,t){var n=s(a(e));return t?c(n):n},u.ArrayBuffer=function(){this.reset()},u.ArrayBuffer.prototype.append=function(e){var t,r,a,i,s,l=(r=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(r.byteLength+a.byteLength)).set(new Uint8Array(r)),s.set(new Uint8Array(a),r.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,t=64;t<=c;t+=64)n(this._hash,o(l.subarray(t-64,t)));return this._buff=t-64<c?new Uint8Array(l.buffer.slice(t-64)):new Uint8Array(0),this},u.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.ArrayBuffer.prototype.getState=function(){var e,t=u.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},u.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),u.prototype.setState.call(this,e)},u.ArrayBuffer.prototype.destroy=u.prototype.destroy,u.ArrayBuffer.prototype._finish=u.prototype._finish,u.ArrayBuffer.hash=function(e,t){var r=s(function(e){var t,r,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,o(e.subarray(t-64,t)));for(r=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<r;t+=1)a[t>>2]|=e[t]<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}(new Uint8Array(e)));return t?c(r):r},u}()},34:function(e,t,n){"use strict";var r=n(22),o=n.n(r),a=n(793),i=n.n(a),s=n(490),l=n.n(s),c=new URL(n(352),n.b),u=i()(o()),d=l()(c);u.push([e.id,".viewer-module-fullScreen_bbk9Y {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: black;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.viewer-module-fullParentSize_ETopO {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.viewer-module-bigFileDrop_aqCgh {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  background-image: url("+d+");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n  border-radius: 10px;\n  width: 50px;\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\n  cursor: pointer;\n}\n\n.viewer-module-progress_cYjQJ {\n  flex: none;\n  font-size: 50px;\n  color: black;\n  z-index: 1;\n  background: rgba(128,128,128,.5);\n  padding: 20px;\n  border-radius: 10px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\nbody {\n  margin: 0;\n}\n\nhtml { \n  overflow: hidden; \n}\n",""]),u.locals={fullScreen:"viewer-module-fullScreen_bbk9Y",fullParentSize:"viewer-module-fullParentSize_ETopO",bigFileDrop:"viewer-module-bigFileDrop_aqCgh",progress:"viewer-module-progress_cYjQJ"},t.Z=u},396:function(e,t,n){var r=n(819),o=n(903);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},892:function(e){"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d="".concat(c," ").concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},311:function(e){"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},60:function(e){"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},192:function(e,t,n){"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},760:function(e){"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var o=void 0!==n.layer;o&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,o&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},865:function(e){"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},352:function(e,t,n){"use strict";e.exports=n.p+"138e7b1469f64156810a.jpg"},706:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p="",n.b=document.baseURI||self.location.href,n.nc=void 0,n(396)}();
</script>
<script>
var container = document.querySelector('.content');
var base64Str = "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";

OfflineLocalView.load(container, { base64Str });
</script>
</body>
</html>
